{"pages":[{"title":"","text":"个人简介 诸葛亮诫子书愿共勉： “夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！“ 个人信息： 软件工程专业JAVA后端开发魔方咸鱼玩家游戏手残玩家 博客信息 网站采用的Icarus主题 在原作者项目基础上修改配置而成 原站点blog.tao421.xyz欢迎访问 更新日志：–2020.11.24：完成博客迁移，可以继续记录学习内容–2020.11.25：在项目基础下进行修改配置建立新站点–2020.11.24：域名需要开始备案，原站点不能访问，wordpress太慢，准备弃坑 计划2021计划 2021-GOALS 待定","link":"/about/index.html"},{"title":"","text":"留言都会回复哟","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看 var gitalk = new Gitalk({ clientID: '966837d7c763617cda0d', clientSecret: '637d4169f4ae86b16d6c6c3e14f4173054b34187', id: '6666', repo: 'liaotao421.github.io', owner: 'liaotao421', admin: \"liaotao421\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"二、配置文件","text":"摘要： springboot 配置文件 二、配置文件1、配置文件springboot使用的一个全局配置文件,配置文件的名称是固定的 application.properties application.yml 配置文件的作用：修改springboot自动配置的默认值 springboot在底层都已经给我们配置好了 YAML (YAML Ain’t Markup Language) 标记语言： ​ 以前的配置文件,大多都是.xml文件； ​ 以数据为中心，比json，xml更适合做配置文件； ​ YAML: 12server: port: 80 2、YAML语法1、基本语法k:空格v：表示一对键值对（空格必须有） 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 80 path: /hello 属性和值大小写敏感 2、值的写法字面量：普通的值（数字，字符串，布尔）； k: v:字面直接来写： ​ 字符串默认不用加上单引号或双引号： ​ “ ”：双引号：不会转义字符串里的特殊字符；特殊字符作为本身想表示的意思 ​ ’ ‘：单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串输出 对象：（属性和值）（键值对）； k: v :在下一行写属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friend： name: zhangsan age: 20 行内写法： 1friend：{name: zhangsan,age: 20} 数组：（list，set）; 用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件: 123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2018/12/12 maps: {key1: v1,key2: 12} list: - lisi - wangwu dog: name: wangwang age: 4 javabean: @ConfigurationProperties(prefix = “person”) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 将配置文件配置每个属性的值映射到组件中 */@ConfigurationProperties(prefix = \"person\")@Componentpublic class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; list; private Dog dog; public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getBoss() { return boss; } public void setBoss(Boolean boss) { this.boss = boss; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getList() { return list; } public void setList(List&lt;Object&gt; list) { this.list = list; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } @Override public String toString() { return \"Person{\" + \"lastName='\" + lastName + '\\'' + \", age=\" + age + \", boss=\" + boss + \", birth=\" + birth + \", maps=\" + maps + \", list=\" + list + \", dog=\" + dog + '}'; }} 可以导入配置文件处理器，以后编写配置就有提示: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1、@Value获取值和@ConfigurationProperties获取值比较@ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持(lastName —- last-name) 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件是yml还是properties都能获取到值； 如果说我们只是在某个业务逻辑中获取一下配置文件中的某项值，就是用@Value 如果说我们专门编写了一个javabean来和配置文件进行映射，那么使用@ConfigurationProperties 2、配置文件注入值数据校验12345@Validatedpublic class Person { @Email private String lastName; 3、@PropertySource 与 @ImportResource@PropertySource 用于加载指定的配置文件 123456789101112131415161718@ConfigurationProperties(prefix = \"person\")@PropertySource(value = {\"classpath:person.properties\"})@Component@Validatedpublic class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; list; private Dog dog; ...} @ImportResource 导入spring的配置文件，让配置文件里面的内容生效 springboot里面没有spring的注解，我们自己编写的配置文件也不能自动识别 想让spring的配合文件生效，加载进来。@ImportResource标注在一个配置类上 12@ImportResource(locations = {\"classpath:bean.xml\"})//导入spring的配置文件 springboot推荐给容器中添加组件的方式；使用全注解的方式 配置类 – spring配置文件 @Bean注解 将方法的返回值加到spring容器中 id默认为方法名 123456789101112/** * @Configuration 指明当前类是一个配置类 */@Configurationpublic class Myconfig { //将方法的返回值添加到容器中;容器中默认id方法名 @Bean public HelloService helloService() { return new HelloService(); }} 4、配置文件的占位符1、随机数12${random.uuid}${random.int} 2、占位符获取之间配置的值，如果没有可以使用冒号设置默认值1234567person.last-name=zhangsan${random.uuid}person.age=${random.int}person.boss=falseperson.birth=2020/1/1person.maps.k1 = 12person.maps.k2 = 11person.dog.name = ${person.hello:hello}_dog 5、Profile1、多Profile文件我们在编写配置文件的时候，文件名可以是 application - {profile}.properties/yml 默认使用的是application.properties/yml 2、YML支持对文档块方式只需写一个配置文件 123456789101112131415server: port: 80spring: profiles: active: product---server: port: 8081spring: profiles: dev---server: port: 8084spring: profiles: product #指定属于哪个环境 3、激活指定的profile 在配置文件中指定 spring.prifiles.active = dev 命令行： –spring.properties.active = dev 可以直接在测试的时候，传入命令行参数 虚拟机参数： -Dspring.properties.active = dev 6、配置文件加载位置spring 启动会扫描以下位置的application.properties或者application.yml文件作为springboot的默认配置文件 -file: ./config/ -file: ./ -classpath: /config/ -classpath: / 优先级由高到低，高优先级的配置会覆盖低优先级的配置； springboot会从这四个位置全部加载主配置文件；互补配置 我们可以通过spring.config.location来改变默认配置文件路径 已经将项目打包后，命令行参数启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用，形成互补配置 7、外部配置的加载顺序springboot也可以从以下位置加载配置；优先级从高到低；互补配置； 命令行参数 加载多个参数使用空格隔开 优先加载带profile jar包外向jar包内 @Configuration注解类上的@PropertySource 所有支持配置的加载参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理 配置文件能配置的属性参照 1、自动配置原理：（springboot版本不一样，与课程有所不同）1）、springboot启动的时候，加载主配置类，开启了自动配置功能@EnableAutoConfiguration 2）、@EnableAutoConfiguration 作用： ​ 利用AutoConfigurationImportSelector为容器中导入一些组件 12@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { 可以查看getAutoConfigurationEntry方法内容 12List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);//获取候选的配置 ​ 进入 getCandidateConfigurations 方法 1List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(...); 进入loadFactoryNames 方法 1return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); 调用了loadSpringFactories方法 1Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); 扫描所有jar包路径下 META-INF/spring.factories ​ 把扫描到的文件的这些内容包装成properties对象 ​ 从properties中获取到EnableAutoConfiguration对应的值添加到容器中 1234567# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\... 将类路径下 META-INF/spring.factories 里面所有配置了EnableAutoConfiguration的值加入到容器中 3）、每一个自动配置类进行自动配置功能 4）、以 HttpEncodingAutoConfiguration 为例解释自动配置原理 12345678910111213141516171819202122232425262728293031@Configuration( //这是一个配置类 可以给容器中添加组件 proxyBeanMethods = false)@EnableConfigurationProperties({ServerProperties.class}) //@ConditionalOnWebApplication( //Spring底层@Conditional注解 根据不同的条件，如果只满足指定的条件，整个配置类的配置才会生效 判断当前应用是否是web应用 type = Type.SERVLET)@ConditionalOnClass({CharacterEncodingFilter.class}) //判断当前项目有没有这个类//CharacterEncodingFilter :springMVC进行乱码解决的过滤器@ConditionalOnProperty( //配置文件是否存在某个配置 如果不存在，帕努单也是成立 prefix = \"server.servlet.encoding\", value = {\"enabled\"}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { private final Encoding properties; //只有一个有参构造器的情况下，参数的值就从容器中拿 public HttpEncodingAutoConfiguration(ServerProperties properties) { this.properties = properties.getServlet().getEncoding(); } @Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); ... return filter; } 根据当前的不同条件判断，决定这个配置类是否生效 一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件能配置的属性都是在xxxProperties类封装着；配置文件能配置是什么可以参照这个功能对应的这个属性类 12345@ConfigurationProperties( //从配置文件获取指定的值和bean的属性进行绑定 prefix = \"server\", ignoreUnknownFields = true)public class ServerProperties { 精髓： springboot启动会加载大量的自动配置类 我们需要的功能有没有springboot写好的默认配置类 我们再来看这些配置类中配置了哪些组件；（有要使用的，就不需要再配置） 给容器中自动配置类添加组件，会从properties类中获取某些属性，我们就可以在配置文件中指定这些属性的值 xxxAutoConfiguration : 自动配置类；给容器中添加组件 ​ xxxProperties:封装配置文件中的相关属性； 2、细节1、@Conditional派生注解（spring注解版原生的@Conditional）作用：必须是Condition指定的条件成立，才给容器添加组件，配置里面的内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效了？ 我们可以通过debug = true 让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效 123456789101112131415161718192021222324252627282930313233============================CONDITIONS EVALUATION REPORT============================Positive matches:（自动配置启用的）----------------- AopAutoConfiguration matched: - @ConditionalOnProperty (spring.aop.auto=true) matched (OnPropertyCondition) AopAutoConfiguration.ClassProxyingConfiguration matched: - @ConditionalOnMissingClass did not find unwanted class 'org.aspectj.weaver.Advice' (OnClassCondition) - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition) DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition) - found 'session' scope (OnWebApplicationCondition)Negative matches:（没有启用的）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition) AopAutoConfiguration.AspectJAutoProxyingConfiguration: Did not match: - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition) ArtemisAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition)","link":"/posts/2d9963a8/"},{"title":"idea插件,设置推荐","text":"摘要： 之前将完成的一些项目保存在本地，一是分享的时候需要打包再发送，二是怕重装系统什么的搞没了，虽然都是小项目，但还是花费了不少的时间编写，还是有必要把项目托管到github上。（ps:据说前几个月github把一批代码埋到了北极，保存1000年，详情，要是之前上传过还可以吹一波什么emmmm…） 今天在重组系统的时候idea被初始化的时候所有的插件设置都没有了，记录下开发常用的一些插件防止以后遇到此类情况 1. 设置背景图片不需要安装插件，在设置里找到就行，还可以调整图片的属性 在设置里点击Appearance -&gt; Background Image Opacity用来设置透明度 点击OK,设置成功 2. 设置字体选择一种好看的字体还是很影响写代码的心情，而且提高阅读代码的舒适度 推荐 JetBrain Mono JetBrain公司发布的一款字体，需要前往官网下载（版本较新的idea自带） 再按照官网的操作后在设置界面选择字体并调整大小即可 效果 3.翻译插件在阅读源码或者变量命名的时候，对于英语不好的朋友是极不友好的，此时可以使用一款翻译插件在编辑器内进行中英互译，还拥有单词本的功能，可谓是学英语，学编程两不误 在插件界面搜索“Translation”安装即可 4.热部署插件jrebel在编写web项目时，修改代码不需要重启服务器就可以生效，节省了开发的时间 5.这个很强https://www.bilibili.com/video/BV1XE411K7Fz?t=982","link":"/posts/eb48756e/"},{"title":"Vue入门（二）","text":"摘要： 第二部分的入门主要是通过axios(应该没拼错)通过调用接口拿到数据在展示在页面上，在开发中较为多的使用 1、axiosaxios简单使用 12345678910111213141516//发送get请求axios.get(\"https://autumnfish.cn/api/joke/list?num=1\") .then(function(res){ console.log(res);},function(err){ console.log(err);})//发送post请求document.querySelector(\".post\").onclick = function() { axios.post(\"https://autumnfish.cn/api/user/reg\",{username:\"西蓝花嘤嘤嘤\"}) .then(function(res){ console.log(res); },function(err){ console.log(err); })} 2、案例-天气预报1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;天知道&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/reset.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot; id=&quot;app&quot;&gt; &lt;div class=&quot;search_form&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;img src=&quot;img/logo.png&quot; alt=&quot;logo&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;form_group&quot;&gt; &lt;input type=&quot;text&quot; v-model = &quot;city&quot; class=&quot;input_txt&quot; placeholder=&quot;请输入查询的天气&quot; @keyup.enter=&quot;weatherSerach&quot; /&gt; &lt;button class=&quot;input_sub&quot; @click=&quot;weatherSerach&quot;&gt; 搜 索 &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;hotkey&quot;&gt; &lt;a href=&quot;javascript:;&quot; @click=&quot;search('北京')&quot;&gt;北京&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click=&quot;search('上海')&quot;&gt;上海&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click=&quot;search('广州')&quot;&gt;广州&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; @click=&quot;search('深圳')&quot;&gt;深圳&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;weather_list&quot;&gt; &lt;li v-for=&quot;item in weatherList&quot;&gt; &lt;div class=&quot;info_type&quot;&gt;&lt;span class=&quot;iconfont&quot;&gt;{{ item.type }}&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;info_temp&quot;&gt; &lt;b&gt;{{ item.low }}&lt;/b&gt; ~ &lt;b&gt;{{ item.high }}&lt;/b&gt; &lt;/div&gt; &lt;div class=&quot;info_date&quot;&gt;&lt;span&gt;{{ item.date }}&lt;/span&gt;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 自己的js --&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ city:&quot; &quot;, weatherList:[], }, methods:{ weatherSerach(){ var that = this; axios.get('http://wthrcdn.etouch.cn/weather_mini?city='+this.city).then(function(res){ console.log(res.data.data.forecast); that.weatherList = res.data.data.forecast; }) }, search(city){ this.city = city; this.weatherSerach(); } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、案例-音乐播放器挺有意思的一个小项目， 运行地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;悦听player&lt;/title&gt; &lt;!-- 样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;!-- 播放器主体区域 --&gt; &lt;div class=&quot;play_wrap&quot; id=&quot;player&quot;&gt; &lt;div class=&quot;search_bar&quot;&gt; &lt;img src=&quot;images/player_title.png&quot; alt=&quot;&quot; /&gt; &lt;!-- 搜索歌曲 --&gt; &lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; v-model=&quot;query&quot; @keyup.enter=&quot;searchMusic&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;center_con&quot;&gt; &lt;!-- 搜索歌曲列表 --&gt; &lt;div class='song_wrapper'&gt; &lt;ul class=&quot;song_list&quot;&gt; &lt;li v-for=&quot;item in musicList&quot;&gt;&lt;a href=&quot;javascript:;&quot; @click=&quot;playMusci(item.id)&quot;&gt;&lt;/a&gt; &lt;b&gt;{{item.name}}&lt;/b&gt; &lt;span @click=&quot;playMv(item.mvid)&quot; v-if=&quot;item.mvid!=0&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;img src=&quot;images/line.png&quot; class=&quot;switch_btn&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 歌曲信息容器 --&gt; &lt;div class=&quot;player_con&quot; :class=&quot;{playing:isPlaying}&quot;&gt; &lt;img src=&quot;images/player_bar.png&quot; class=&quot;play_bar&quot; /&gt; &lt;!-- 黑胶碟片 --&gt; &lt;img src=&quot;images/disc.png&quot; class=&quot;disc autoRotate&quot; /&gt; &lt;img :src=&quot;musicSrc&quot; class=&quot;cover autoRotate&quot; /&gt; &lt;/div&gt; &lt;!-- 评论容器 --&gt; &lt;div class=&quot;comment_wrapper&quot;&gt; &lt;h5 class='title'&gt;热门留言&lt;/h5&gt; &lt;div class='comment_list'&gt; &lt;dl v-for=&quot;item in hotComments&quot;&gt; &lt;dt&gt;&lt;img :src=&quot;item.user.avatarUrl&quot; alt=&quot;&quot;&gt;&lt;/dt&gt; &lt;dd class=&quot;name&quot;&gt;{{ item.user.nickname }}&lt;/dd&gt; &lt;dd class=&quot;detail&quot;&gt; {{item.content}} &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;img src=&quot;images/line.png&quot; class=&quot;right_line&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;audio_con&quot;&gt; &lt;audio @play=&quot;play&quot; @pause=&quot;pause&quot; ref='audio' :src=&quot;musicUrl&quot; controls autoplay loop class=&quot;myaudio&quot;&gt;&lt;/audio&gt; &lt;/div&gt; &lt;div class=&quot;video_con&quot; v-show=&quot;isShow&quot; style=&quot;display: none;&quot;&gt; &lt;video :src=&quot;mvUrl&quot; controls=&quot;controls&quot; &gt;&lt;/video&gt; &lt;div class=&quot;mask&quot; @click=&quot;hide&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue({ el:&quot;#player&quot;, data:{ query:&quot;&quot;, musicList:[ ], musicUrl:&quot;&quot;, musicSrc:&quot;&quot;, hotComments:[], isPlaying:false, isShow:false, mvUrl:&quot;&quot; }, methods:{ searchMusic:function(){ var that = this; axios.get(&quot;https://autumnfish.cn/search?keywords=&quot;+this.query).then(function(res){ that.musicList =res.data.result.songs; console.log(that.musicList); }) }, playMusci:function(id){ var that = this; axios.get(&quot;https://autumnfish.cn/song/url?id=&quot;+id).then(function(res){ // console.log(res.data.data[0].url) that.musicUrl = res.data.data[0].url; }) //https://autumnfish.cn/playlist/detail?id=24381616 axios.get(&quot;https://autumnfish.cn/song/detail?ids=&quot;+id).then(function(res){ // console.log(res.data.songs[0].al.picUrl) that.musicSrc = res.data.songs[0].al.picUrl; // console.log(that.musicSrc); }) // /comment/music?id=186016&amp;limit=1 获取歌曲评论 axios.get(&quot;https://autumnfish.cn/comment/music?id=&quot;+id+&quot;&amp;limit=1&quot;).then(function(res){ // console.log(res.data.songs[0].al.picUrl) console.log(res.data.hotComments); that.hotComments = res.data.hotComments; }) }, play:function(){ console.log(&quot;play&quot;); this.isPlaying = true; }, pause:function(){ console.log(&quot;pause&quot;); this.isPlaying = false; }, playMv:function(id){ var that = this; axios.get(&quot;https://autumnfish.cn/mv/url?id=&quot;+id).then(function(res){ console.log(&quot;------------------------------------&quot;) console.log(res.data.data.url); that.mvUrl = res.data.data.url; that.isShow = true; }) }, hide:function(){ this.isShow = false; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简简单单四小时的入门结束！，现在考虑将假期未实现的魔方比赛系统使用springboot + vue 重构，并实现未实现的功能。使用软件工程的方法来设计这个系统","link":"/posts/56a9c9b0/"},{"title":"五、Docker","text":"摘要： docker 简单使用 1、简介Docker是一个开源的应用容器引擎； Docker支持将软件编写成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，使用者可以直接使用这个镜像 运行中的这个镜像称为容器，容器启动是非常快速的 2、核心概念docker主机（Host）：安装了Docker程序的机器（Docker直接按照在操作系统之上） docker客户端（Client）：客户端通过命令行或其他工具连接Docker主机进行操作 docker仓库（Registy）：Docker仓库用来存放镜像 docker容器（Container）：镜像启动之后的实例；容器是独立运行的一个或一组应用 使用Docker步骤： 1、安装Docker 2、去Docker仓库找到软件的镜像 3、使用Docker运行镜像，镜像生成一个容器 4、对容器的启动停止就是对软件的启动，停止 3、安装Docker直接使用云服务器 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 使用阿里云的镜像加速，否则下载镜像很慢 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 4、Docker常用命令&amp;操作1）、镜像操作操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02","link":"/posts/7ff872e6/"},{"title":"一.操作系统引论","text":"摘要： 操作系统引论 一 .操作系统引论1.1_1 操作系统的概念，功能和目标123456789101112131415161718192021221.概念： 操作系统（Operating System,OS）是指控制和管理整个计算机系统的硬件和软件资源， 并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境， 它是计算机系统中最基本的系统软件 2.操作系统的功能与目标 作为系统资源的管理者 目标 安全，高效 * 处理机管理 * 存储器管理 * 文件管理 * 设备管理 作为用户和计算机硬件之间的接口 * 命令接口 * 联机命令接口 （交互式的命令接口） 用户说一句 操作系统执行一句 * 脱机命令接口 （批处理命令接口） 用户说一堆 操作系统执行一堆 .bat文件 * 程序接口 由一组系统调用组成（系统调用=程序接口=广义指令），只能通过用户程序简介只用 * GUI（图形用户界面） 用户通过形象的图形界面进行操作 作为最接近硬件的层次 实现对硬件机器的拓展 1.1_2 操作系统的特征1234567891011121314151617181920212223241.并发 并发：指两个或多个事件在同一时间间隔内发生，这些事件在宏观上是同时发生的，但微观上是交替发生的 --并行：两个或多个事件在同一时刻同时发生 操作系统的并发性：计算机系统中同时存在着多个运行着的程序 一个单核处理机（cpu）在同一时刻只能执行一个程序，操作系统会负责协调多个程序的交替执行2.共享 共享：资源共享，系统中的资源可供内存中的多个并发执行的进程共同使用 *互斥共享方式：一个时间段内只允许一个进程访问该资源 *同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问 “同时”：往往是宏观上的， 并发 共享 互为存在条件3.虚拟 虚拟：把一个物理上的实体变为若干个逻辑上的对应物。物理实体是存在的，而逻辑上的对应物是用户感受到的 *背景知识：一个程序需要放入内存并给它分配CPU才能执行 *虚拟技术中的“空分复用技术” -&gt; 电脑的运行内存只有4g，但可以同时gta5,网易云，qq,idea *虚拟技术中的“时分复用技术” -&gt;单核cpu qq,浏览器，微信...4.异步 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停， 以不可预知的速度向前推进，这就是程序的异步性 *只有系统拥有了并发性，才有可能导致异步性 1.1_3 操作系统的发展与分类1234567891011121314151617181920212223242526272829303132333435363738391.手工操作阶段 主要缺点：用户独占全机，人机速度矛盾导致资源利用率较低2.批处理阶段 （1）单道批处理系统 引入脱机输入/输出输出（用磁带完成），并监督程序（操作系统的）负责完成作业的输入，输出 主要优点：换届了一定程度的人机速度矛盾，资源利用率有所提升 主要缺点：内存中只能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。cpu有大量 的时间是在空闲等待I/O完成，资源利用率依然很低 （2）多道批处理系统 每次往内存中输入多道程序 操作系统正式诞生，并引入了中端技术，由操作系统负责管理这些程序的运行，各个程序并发执行 主要优点：多道程序并发执行，共享计算机资源，资源利用率大大提升，cpu和其他资源保持“忙碌” 状态，系统的吞吐量增大 主要缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业后只能等待计算机处理完成， 中间不能控制自己的作业执行）3.分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 主要优点：用户 请求可以被即时响应，解决了人机交互功能，允许多个用户同时使用一台计算机，并且用户 对计算机的操作互相独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急的任务，操作系统对各个用户/作业都是完全公平的，循环的为每个用户/作业 服务一个时间片，不区分人任务的紧急性4.实时操作系统 主要优点：能够优先响应一些紧急的任务，某些紧急任务不需要时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时处理，并且要求在严格的时限内处理完成事件， 实时操作系统的主要特点是及时性和可靠性 *硬实时系统：必须在绝对严格的规定时间内完成处理 *软实时系统：能偶尔接收违反时间约定5.其他几种 *网络操作系统 *分布式操作系统 *个人计算机操作系统 1.1_4 操作系统的运行机制和体系结构1234567891011121314151617181920212223242526272829303132331.两种指令，两种处理器状态，两种程序*c语言代码 -&gt;“翻译” 机器语言指令指令就是cpu能识别，执行的最基本命令特权指令 核心态 内核程序非特权指令 用户态 应用程序2.操作系统内核内核：是计算机配置的底层软件，是操作系统最基本，最核心的部分 实现操作系统内核功能那些程序就是内核程序 * 时钟管理： 实现计时功能 * 中断处理：负责实现中端机制 * 原语： * 是一种特殊的程序 * 处于操作系统的最底层，最接近硬件的部分 * 原子性 * 运行时间较短，调用频繁 * 对系统资源进行管理 * 进程管理 * 存储器管理 * 设备管理3.操作系统的体系结构 操作系统的体系结构：大内核和微内核 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 微内核：只把最基本的功能保留在内核 优点：结构清晰，易于维护 缺点：需要频繁的在用户态和内核态之间切换，性能低 1.1_5 中断和异常123456789101112131415161718192021222324251.中断机制的诞生 本质：发生中断就意味着需要操作系统介入，开展管理工作2.中断的概念和作用 当中断发生时：cpu立即进入核心态 当中断发生后：当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同的处理 由于操作系统的管理工作（进程切换，分配I/O设备等）需要使用特权指令，因此cpu需要从用户态转化 为核心态。中断可以使cpu从用户态转换为核心态，使操作系统获取计算机的控制权。有了中断，才能实现多道程序的并发执行 用户态，核心态之间的转换是怎么实现的？ 用户态-&gt;核心态 是通过中断实现的，并且中断时唯一途径 核心态-&gt;用户态 是通过执行一个特权指令，将程序状态字（PSW）的标志改为“用户态”3.中断的分类 内中断（异常，例外，陷入）信号来源：cpu内部 与当前执行的指令有关 自愿中断 --指令中断 强迫中断 --硬件故障，软件中断 外中断（中断）信号来源：cpu外部 与当前执行的指令无关 外设请求 人工干预4.外中断的处理过程 每条指令执行结束后，cpu检查是否有外部中断信号 若有外部中断信号。则需要保护被中断进程的cpu环境（打游戏的时候门开了，急需存档） 根据中断信号的类型转入相应的中断处理程序（游戏存档） 恢复原进程的cpu环境并退出中断，返回原进程继续往下执行（继续游戏） 1.1_6 系统调用1234567891011121314151617181920212223242526272829303132333435363738391.什么是系统调用，有何作用 “系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序 调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务 应用程序通过系统调用请求操作系统的服务，系统中的各种共享资源都由操作系统统一掌管，因此在用户 程序中，凡是与资源有关的操作（如存储分配,I/O操作，文件管理），都必须通过系统调用的方式向操作系统提出服务请求， 由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户非法操作 按功能分类 * 设备管理 完成设备的 请求/释放/启动 等功能 * 文件管理 完成文件的 读/写/创建/删除 等功能 * 进程控制 完成进程的 创建/撤销/阻塞/唤醒 等功能 * 进程通信 完成进程之间的 消息传递/信号传递 等功能 * 内存管理 完成内存的 分配/回收 等功能 这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行2.系统调用与库函数的区别 应用程序 -- 汇编语言 -- 系统调用 -- 操作系统 应用程序 -- C语言 -- 库函数 -- 系统调用 -- 操作系统 编程语言：向上提供库函数，有时会将系统调用封装成库函数，隐藏系统调用的一些细节，使上层进行系统调用更方便3.系统调用背后的过程 用户程序（高级语言视角） write(&quot;abc&quot;) 用户程序（汇编语言视角） movl指令（将“abc”作为系统调用的参数放到某个通用寄存器中） int x 指令（trap/陷入执行） 处理系统调用的相关代码（运行在核心态） 完成处理返回 * int x 指令 参数x指明了系统调用号，此处的int不是整数的意思，而是interrupt的缩写 传递系统调用参数-&gt;执行陷入指令（用户态）-&gt;执行系统调用相应的服务程序（核心态）-&gt;返回应用程序 注意 1.陷入指令只在用户态执行，执行陷入指令后立即引发一个内中断，从而cpu进入核心态 2.发出系统调用请求是在用户态，而系统调用的相应处理在核心态下进行 3.陷入指令是唯一一个只能在用户态下执行，不能在核心态下执行的指令","link":"/posts/7568c2fe/"},{"title":"Vue入门（一）","text":"摘要： 入门springboot之后，模板引擎themeleaf，jsp等开发方式可能已经被时代抛弃，大势所趋的前后端分离使得不得不学习一点Vue,以便开发小型的项目继续，在b站发现黑马某四小时快速入门课，确实感觉使用起来很方便。（有点类似微信小程序，或者说微信小程序开发有点类似Vue,微信小程序早忘了）入门较为简单，只记录代码 1、vue基础123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; {{ message }}&lt;/div&gt;&lt;script&gt; var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、挂载点123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;p class=&quot;app&quot;&gt; {{ message }} &lt;span&gt; {{ message }} &lt;/span&gt;&lt;/p&gt;&lt;body&gt; &lt;script&gt; var app = new Vue({ el:&quot;.app&quot;, data:{ message:&quot;cyfwlp&quot; } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、数据对象12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; {{ message }} &lt;h2&gt;{{ school.name }}&lt;/h2&gt; {{ campus[0] }} &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:\"#app\", data:{ message:\"你好，小黑！\", school:{ name:\"黑马程序员\", mobile:\"3234232131\" }, campus:[\"111\",\"222\",\"333\"] } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、v-text指令123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h2 v-text=&quot;message + '就这就这'&quot;&gt;1111&lt;/h2&gt; &lt;h2 v-text=&quot;info + '就这就这'&quot;&gt;1111&lt;/h2&gt; &lt;h2&gt;{{ message +'就这就这'}}1111&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ message:&quot;你好，小黑！!!&quot;, info:&quot;cyfwlp&quot; } })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、v-html指令12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h2 v-html=&quot;info&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ message:&quot;你好，小黑！!!&quot;, info:&quot;&lt;a href = 'www.baidu.com'&gt;cyfwlp&lt;/a&gt;&quot; } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6、v-on指令12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;事件绑定1&quot; @click=&quot;changeFood&quot;&gt; &lt;h2&gt;{{ food }}&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ food:&quot;西蓝花&quot; }, methods:{ dolt:function(){ alert(&quot;1111&quot;) }, changeFood:function(){ console.log(this.food); this.food += &quot;好吃&quot;; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7、案例-计数器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;button @click=&quot;sub&quot;&gt; - &lt;/button&gt; &lt;span&gt;{{ number }}&lt;/span&gt; &lt;button @click=&quot;add&quot;&gt; + &lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ number:1 }, methods:{ add:function(){ if(this.number&lt;10){ this.number++; }else{ alert(&quot;最大了&quot;) } }, sub:function(){ if(this.number&gt;0){ this.number--; }else{ alert(&quot;最小了&quot;) } } } }) &lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8、v-show指令123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;change&quot; value=&quot;change&quot;&gt;change&lt;/button&gt; &lt;img v-show = &quot;isShow&quot; src=&quot;http://www.67373upup.xyz:88/wordpress/wp-content/uploads/2020/09/36593305aeb94dbfee9a57128578369a.jpg&quot;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ isShow:true }, methods:{ change:function(){ this.isShow = !this.isShow } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9、v-if指令123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;isShow&quot;&gt;这是一个标签&lt;/p&gt; &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ isShow:true }, methods:{ change:function(){ this.isShow = ! this.isShow } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 10、v-bind指令1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;style&gt; .active{ border:1px solid red; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img :src = &quot;imgSrc&quot; :title=&quot;imgTitle&quot; :class = &quot;{active:isActive}&quot;&gt; &lt;button @click=&quot;change&quot;&gt;dwdw&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ imgSrc:&quot;http://www.67373upup.xyz:88/wordpress/wp-content/uploads/2020/09/36593305aeb94dbfee9a57128578369a.jpg&quot;, imgTitle:&quot;springboot&quot;, isActive:false }, methods:{ change:function(){ this.isActive = ! this.isActive; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 11、案例-图片切换123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img :src=&quot;imgArr[index]&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;prev&quot; v-show = &quot;index != 0&quot;&gt;上一张&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;next&quot; v-show = &quot;index != imgArr.length - 1&quot;&gt;下一张&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ imgArr:[&quot;./images/1.JPG&quot;, &quot;./images/2.JPG&quot;, &quot;./images/3.JPG&quot;, &quot;./images/4.JPG&quot;], index:0 }, methods:{ prev:function(){ this.index--; }, next:function(){ this.index++; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12、v-for指令123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in arr&quot;&gt; {{ index + 1 }} 黑马校区：{{ item }} &lt;/li&gt; &lt;/ul&gt; &lt;h2 v-for = &quot;item in vegetavles&quot;&gt; {{ item.name }} &lt;/h2&gt; &lt;button @click= &quot;add&quot;&gt;add&lt;/button&gt; &lt;button @click=&quot;push&quot;&gt;push&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ arr:[&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;], vegetavles:[ {name:&quot;111&quot;}, {name:&quot;222&quot;} ] }, methods:{ add:function(){ this.vegetavles.push({name:&quot;333&quot;}); }, push:function(){ this.vegetavles.shift(); } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 13、v-on指令补充1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; @click=&quot;doit(666,'老谭')&quot;&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, methods:{ doit:function(p1,p2){ alert(p2); } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14、v-model指令12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; {{message}} &lt;button @click=&quot;change&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;,//挂载 data:{ message:&quot;cyfwlp&quot; }, methods:{ change:function(){ this.message = &quot;1111111&quot;; } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 15、案例-记事本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;小黑记事本&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot; /&gt; &lt;meta name=&quot;googlebot&quot; content=&quot;noindex, nofollow&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 主体区域 --&gt; &lt;section id=&quot;todoapp&quot;&gt; &lt;!-- 输入框 --&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;小黑记事本&lt;/h1&gt; &lt;input autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; v-model=&quot;inputValue&quot; @keyup.enter = &quot;add&quot; /&gt; &lt;/header&gt; &lt;!-- 列表区域 --&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todo-list&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;{{ index+1 }}.&lt;/span&gt; &lt;label&gt;{{ item }}&lt;/label&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(index)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;!-- 统计和清空 --&gt; &lt;footer class=&quot;footer&quot;&gt; &lt;span class=&quot;todo-count&quot; v-show=&quot;list.length != 0&quot;&gt; &lt;strong&gt;{{list.length}}&lt;/strong&gt; items left &lt;/span&gt; &lt;button class=&quot;clear-completed&quot; @click=&quot;destory&quot; v-show=&quot;list.length != 0&quot;&gt; Clear &lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;!-- 底部 --&gt; &lt;footer class=&quot;info&quot;&gt; &lt;p&gt; &lt;a href=&quot;http://www.itheima.com/&quot; &gt;&lt;img src=&quot;./img/black.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;/p&gt; &lt;/footer&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue({ el:&quot;#todoapp&quot;, data:{ list:[&quot;写代码&quot;,&quot;吃饭饭&quot;,&quot;睡觉觉&quot;], inputValue:&quot;好好学习，天天睡觉&quot;, }, methods:{ add:function(){ this.list.push(this.inputValue); }, remove:function(index){ this.list.splice(index,1); }, destory:function(){ this.list = []; } } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在springboot折磨了几天后看前端是真轻松不得不说哈哈","link":"/posts/66bf2568/"},{"title":"一、Spring Boot 入门","text":"摘要： Spring Boot 入门 一、Spring Boot 入门1、SpringBoot 简介 简化spring开发的一个框架 整个spring技术栈的一个整合 J2EE的一站式解决方案 2、微服务2014，Martin Fowler 微服务：架构风格 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 详细参照微服务文档 3、环境准备1、MAVEN设置给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、idea设置设置maven 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接收并处理，响应Hello World字符串 1、创建一个maven工程2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写主程序：启动spring boot应用1234567891011/** * @SpringBootApplication 标注一个主程序，说明这是一个spring boot的应用 */@SpringBootApplicationpublic class HelloWordMainApplication { public static void main(String[] args) { // spring应用启动起来 SpringApplication.run(HelloWordMainApplication.class,args); }} 4、编写相关的controller,service123456789101112131415package com.cyfwlp.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController { @ResponseBody @RequestMapping(\"/hello\") public String hello() { return \"HelloWorld!!\"; }} 5、运行主程序测试如果需要更改端口号 在src/resources 新建文件 application.properties 1server.port= xxx 6、简化部署将应用打包为jar包 直接使用java -jar运行 5、Hello World探究1、POM文件1、父项目123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;它的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;它来真正管理Spring Boot应用里面的所有依赖版本&lt;!-- Dependency versions --&gt; &lt;activemq.version&gt;5.14.5&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.59&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;1.5.5&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt; &lt;assertj.version&gt;2.6.0&lt;/assertj.version&gt; &lt;atomikos.version&gt;3.9.3&lt;/atomikos.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;caffeine.version&gt;2.3.5&lt;/caffeine.version&gt; ................... Spring Boot的版本仲裁中心： 以后我们导入依赖默认是不需要写版本(没有在dependencies里面管理的依赖自然需要声明版本) 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web ​ spring-boot-starter：spring-boot的场景启动器；帮我们导入了web某块正常运行所相关的依赖 Spring-Boot将所有的功能场景都抽取出来，做成一个个的starter(启动器)：只需要在项目中引入这些starter就可以导入相关的依赖 2、主程序类，主入口类1234567891011/** * @SpringBootApplication 标注一个主程序，说明这是一个spring boot的应用 */@SpringBootApplicationpublic class HelloWordMainApplication { public static void main(String[] args) { // spring应用启动起来 SpringApplication.run(HelloWordMainApplication.class,args); }} @SpringBootApplication ：说明这个类是springboot的主配置类，springboot就应该运行这个类的main方法来启动spring应用 12345678910111213141516@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication { @SpringBootConfiguration：springboot的配置类 ​ 标注在某个类上，表示这是一个springboot的配置类 ​ @Configuration：配置类上标注这个配置类 ​ 配置类 —– 配置文件；配置类也是容器中的一个组件 @EnableAutoConfiguration： ​ 以前我们需要配置的东西，springboot帮我们自动配置； 123@AutoConfigurationPackage@Import({EnableAutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { @AutoConfigurationPackage：自动配置包 ​ @Import({Registrar.class})； ​ spring的底层注解@Import,给容器中导入一个组件； ​ 将主配置类（@SpringBootApplication 标注的类）所在的包下面以及所有子包里面的所有组件扫描到spring容器； ​ @Import({EnableAutoConfigurationImportSelector.class}) ​ 给容器中导入组件 ​ EnableAutoConfigurationImportSelector ：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了手动编写配置和注入功能组件等工作 ​ SpringFactoriesLoader(EnableAutoConfiguration.class,classLoader); ​ springboot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入容器中，自动配置类自动生效，帮我们进行自动配置的工作;以前我们需要自己配置的东西，自动帮我们配置了 J2EE的整体解决方案和自动配置都在springframework\\boot\\spring-boot-autoconfigure\\1.5.9.RELEASE\\spring-boot-autoconfigure-1.5.9.RELEASE.jar 6、使用Spring Initializer 快速创建Spring Boot项目IDE 都支持使用springboot项目创建向导快速创建一个spring boot项目 选择我们需要的某块：向导会联网创建springboot项目 默认生成的sprinboot 主程序已经生成好了，我们只需要写自己的逻辑 resources文件夹目录结构 static：保存所有的静态资源 templates:保存所有的模板引擎（springboot默认jar包使用嵌入式的tomcat，默认不支持jsp页面）；可以使用模板引擎（freemarker,thymeleaf）； application.properties：springboot的应用的配置文件；可以修改一些默认配置 ​ ​","link":"/posts/8175c19e/"},{"title":"github上传自己的项目","text":"摘要： 之前将完成的一些项目保存在本地，一是分享的时候需要打包再发送，二是怕重装系统什么的搞没了，虽然都是小项目，但还是花费了不少的时间编写，还是有必要把项目托管到github上。（ps:据说前几个月github把一批代码埋到了北极，保存1000年，详情，要是之前上传过还可以吹一波什么emmmm…） 1、进入gethub首页，点击 New repository 新建一个项目 123456Repository name : 项目名Description : 项目描述Public/Private:所有可见/指定人可见Add a README file : 在项目里自动添加readme.md文件gitignore: 创建一个gitigore文件用于存放git忽略的文件，如maven的target目录，.idea目录等license: 开源许可证，这玩意分类挺多，选MIT协议就行，它允许别人用你的代码做任何事情，但必须保证你的所有权，并且你无须承担代码使用产生的风险，参考自 https://zhuanlan.zhihu.com/p/51331026 完成输入选择后点击Create repository 2、点击Code获取到一个地址，复制它备用 3、本地操作，需下载git工具 下载链接，没有梯子会比较慢，附上一个蓝奏云链接 找到你的项目，点击右键 弹出操作框 将前面复制到的地址拿过来 git clone https://github.com/liaotao421/-.git 这时发现问文件目录多了一个文件夹，文件夹名就是github上的项目名 将项目复制到这个文件内（我的项目名莫名其妙变成了-…） cd 项目名 //进入项目文件夹 配置git上的用户名和邮箱 git cinfig –global user.name “liaotao421” git cinfig –global user.email 1984457659@qq.com 依次输入 git add .//注意点之前的空格! git commit -m “first commit” git push -u orgin master git push -u origin master //此时弹出登录框登录 刷新发现项目已经成功上传","link":"/posts/8f610a4b/"},{"title":"java web 项目中实现短信验证码登录，注册","text":"摘要： 今日在写项目时，注册登录功能沿用了邮箱验证，已经几个项目都使用邮箱验证，感觉有点弱，加上进来几乎所有应用都有短信验证码的功能，感觉需要掌握这个方法 选择第三方服务商 应该有很多厂商都提供了短信服务，我使用的是榛子云（传送门），其他的话流程应该差不多 注册，登录 依次点击应用管理，我的应用，可以查看到AppId，和AppSecret，这两个值在后面会用到 导入jar包或maven坐标 这一步直接看官方的文档就行（传送门） 实现业务逻辑 如使用项目的界面 在输入手机号，点击发送验证码后将手机号发送给后台处理 12345678910111213141516@RequestMapping(\"/sendSms\") public @ResponseBody Map sendSms(@RequestBody String phoneNumber, HttpServletRequest request) throws Exception { Map res = new HashMap(); //生成随机验证码4位 String captcha = RandomStringUtils.random(4,false,true); //发送到注册手机 ZhenziSmsClient client = new ZhenziSmsClient(\"https://sms_developer.zhenzikj.com\", \"105254\", \"60b64026-9aaa-4459-83f3-0aaad82383d3\"); String result = client.send(phoneNumber, \"验证码: \" + captcha + \",你正在注册喜瑞斯账号，验证码在5分钟内有效\"); System.out.println(result); //验证码存入session request.getSession().setAttribute(\"captcha\",captcha); //返回结果 res.put(\"type\",\"success\"); res.put(\"msg\",\"发送成功\"); return res; } 对ZhenziSmsClient的三个参数简单说明 123apiUrl:https://sms_developer.zhenzikj.com //个人用户使用这个url就行appId:105551 //替换为你的appidappSecret:60b64026-9aaa-4459-83f3-0aafd81383d3 //替换为你的appSercet 具备基本开发经验的话应该理解这段代码的问题不大 点击后 再点击注册后再将输入的验证码与session域里的验证码比较即可，注意验证成功后将session域里的验证码删除掉 这里需要注意开发者测试的话短信的署名只能是榛子云体验，企业的话可以使用企业的名称 大概三秒左右就能收到短信，速度还可以 既然使用了短信验证注册，再登录时也可以选择短信验证登录和传统的账号密码登录 业务逻辑就不在此过多叙述","link":"/posts/52c7f62f/"},{"title":"一周flag!!","text":"距离上次深夜感慨正好一个月，有点巧，相比九月，十月到开始到现在就是颓废了，还莫名的焦虑起来，得立一波flag了 学习 日更一篇博客，灌水什么都行 java数据结构与算法结束树部分 六级词汇记忆三个List 魔方 每天10把棱块盲，10个字母编码，微博打卡 三速20把， 生活 早上7:00起来跑一圈或者晚上9:00 1km 传统手艺活 – 游戏随缘 睡觉随缘，上课补觉 发现杨姐直播真心不错，荧光棒续牌，晚上听听歌 直面内心的自己，不去表演自己，不去恐惧或躲避 加油吧！冲冲冲！","link":"/posts/585fbb88/"},{"title":"二.进程，处理机调度与死锁（一）","text":"摘要： 进程的定义，组成，组织方式，特征 调度算法 2.1_1 进程的定义，组成，组织方式，特征12345678910111213141516171819202122232425262728293031323334353637383940414243444546471.进程的定义 *程序：就是一个指令序列 进程的定义：程序段，数据段，PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体 简称为进程，例如，所谓的创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销 进程实体中的PCB，PCB是进程存在的唯一标识 PCB:系统为每个运行的程序配置了一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息 （如程序代码存放的位置，设备的使用情况等等） 存不同的角度，进程可以有不同的定义 强调“动态性” (1).进程是程序的一次执行过程 (2).进程是一个程序及其数据在CPU上顺序执行时所发生的动作 (3).进程是具有独立功能的程序在数据集合上的运行过程，它是系统进行资源分配和调用的一个独立单位 引入了进程实体的概念后，可把进程定义为 进程是进程实体的运行过程，数系统进行资源分配和调度的一个独立单位 注：严格来说，进程实体和很进程不一样，进程是动态的，进程实体是静态的。除非题目特地考察二者的 区别，否则可以认为进程实体就是进程，因此我们可以说“进程由程序段，数据段，PCB三部分组成” 程序段 程序代码即存放在此 数据段 程序运行时产生，使用的运算数据 PCB 操作系统通过PCB来管理进程，因此PCB中应包含操作系统对进程进行管理所需的各种信息 PCB:只要是操作系统所需的数据都在PCB中 进程描述信息 * 进程标识符 PID *用户标识符 UID 进程控制和管理信息 * 进程当前状态 * 进程的优先级 资源分配清单 * 程序段指针 * 数据段指针 * 键盘 * 鼠标 处理机的相关信息 各种寄存器值2.进程的组织 链接方式：按照进程状态将PCB分成多个队列，操作系统持有指向各个队列的指针 执行指针 就绪队列指针 阻塞队列指针 索引方式：根据进程状态的不同，建立几张索引表，操作系统持有各个索引表的指针 执行指针 就绪表指针 阻塞表指针3.进程的特征 动态性：进程是程序的一次执行过程 并发性：内存中有多个进程实体，各进程可并发执行 独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位 异步性：各进程按各自独立的，不可预知的速度向前推进（操作系统要提供“进程同步机制”解决异步问题） 结构性：进程由程序段，数据段，PCB组成 2.1_2 进程的状态与转换12345678910111213141.三种基本状态 运行态：占有cpu,并在cpu上运行 就绪态：已具备了运行的条件，但由于没有空闲cpu，而暂时不能运行 阻塞态：因等待某一事件暂时不能运行2.另外两种状态 创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB 终止态：进程正在系统中被撤销，操作系统会回收进程拥有的资源，撤销PCB3.进程状态的转换 就绪态 -&gt; 运行态：进程被调度 运行态 -&gt; 就绪态：时间片到，或cpu被其他优先级高的进程抢占 运行态 -&gt; 阻塞态：等待资源分配，或等待某个事件发生(主动行为) 阻塞态 -&gt; 就绪态：资源分配完成，等待的时间发生（被动行为） 创建态 -&gt; 就绪态：系统完成创建进程的相关工作 运行态 -&gt; 终止态：进程运行结束或运行过程遇到不可修复的错误 2.1_3 进程控制1234567891011121314151617181920212223242526272829303132333435363738391.进程控制 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现 进程转换等功能 简化理解：进程控制就是要实现进程状态转换2.原语 原语的特点是执行期间不允许中断，只能一气呵成 这种不可被打断的操作即原子操作 原语采用“关中断指令”和“开中断指令” -&gt;&gt; 特权指令，核心态下进行3.进程控制的相关原语 无论哪个原语，执行三件事 更新PCB信息 将PCB插入合适的队列 分配/回收资源 进程的创建 创建原语 申请空白PCB 为新进程分配所需资源 初始化PCB 将pcb插入就绪队列 进程的终止 撤销原语 从PCB集合中找到终止进程的PCB 若进程正在运行，立即剥夺cpu,将cpu分配给其他进程 终止所有子进程 将该进程拥有的资源归还给操作系统或父进程 删除PCB 进程的阻塞 阻塞原语： 找到要阻塞的进程对应PCB 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程的运行 将PCB进程插入阻塞队列 唤醒原语： 在阻塞队列中找到PCB 将PCB从阻塞队列移除，设置进程为就绪态 将PCB插入就绪队列 进程的切换 切换原语 将运行环境信息存入PCB PCB移入相应队列 选择一个进程执行，并更新其PCB 根据PCB恢复进程所需的运行环境 2.1_4 进程通信12345678910111213141516171819202122232425262728进程通信：进程之间的信息交换进程是分配系统资源的单位，因此各进程拥有的内存地址互相独立1.共享存储 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现） （1）基于数据结构的共享 比如在共享空间只能存放一个长度为10的数组，这种方式速度慢，限制多，低级通信方式 （2）基于存储区的共享 在内存中画出一块共享存储区，数据的形势，存放位置都由进程控制，而不是操作系统 这种共享方式速度更快，是一种高级通信方式2.管道通信 管道：用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区 （1）管道只能采用半双工通信，某一时间内只能实现单向的传输，如果要实现双向同时通信，则需要设 置两个管道 （2）各进程需要互斥的访问管道 （3）数据已字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待写入的 数据被取走。当读进程把数据全部取走后，管道变空，此时读进程的read()系统调用被阻塞 （4）如果没写满，就不允许读。如何没读完，就不允许写 （5）数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能有读错数据的 情况3.消息传递 进程间的数据交换已格式化消息（Message）为单位，进程通过操作系统提供的“发出/接受消息”两个原 语进行数据交换 （1）直接通信方式 消息直接挂在进程的消息缓存队列上 （2）间接通信方式（信箱通信方式）消息要先发送到中间实体（信箱） 2.1_5 线程概念 多线程模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546471.什么是线程，为什么要引入线程 有的进程可能需要“同时”做很多事情而传统的进程只能串行的执行一系列程序，从而引入了线程， 来增加并发度 线程：轻量级进程 线程是一个基本的cpu执行单元，也是程序执行流的最小单位 引入线程带来的额变化 （1）进程是资源分配的基本单位，线程是调度的基本单位 （2）各线程之间也可以并发，提升了并发度 （3）如果是同一进程的线程切换，则不需要切换进程环境，并发所带来的的系统开销减少2.线程的属性 线程是处理机调度的单位 多CPU环境中，各个线程可占用不同的cpu 每个线程都有一个线程ID,线程控制块(TCB) 线程也有就绪，阻塞，运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程之间共享进行的资源 由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大3.线程的实现方式 用户级线程 由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换） “用户级线程”就是“从用户视角能看到的线程” 内核级线程 线程的管理由操作系统内核来完成，线程的调度，切换必须在核心态下完成 “内核级线程”就是“从操作系统内核视角看到的线程” ** 操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机调度的基本单位4.多线程模型 在同时支持用户级线程和内核级线程的系统中，由多个用户级线程映射到多个内核级线程的问题引出了 “多线程模型”问题 多对一：多个用户级线程映射到一个内核级线程 优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，进程管理的系统开销小 效率高 缺点：一旦一个线程发送了阻塞导致其他线程也阻塞，导致并发度不高，多个线程不能在多核的 处理机上并行执行 一对一：一个用户级线程对应一个内核级线程 优点：当一个线程被阻塞，其他用户级线程可以继续执行，并发性能强，多个线程可以在多核 处理机下并行执行 缺点：进程的切换在内核空间进行，线程的管理成本高，开销大 多对多：n个用户级线程映射到M个内核级线程（n &gt;= m） 克服了多对一并发度不高的缺点，又客服了一对一模型系统开销大的缺点 2.2_1 处理机调度 概念，层次1234567891011121314151617181920212223242526272829303132333435363738391.调度的基本概念 调度：有一堆任务需要处理，但不限同时处理，这时候就需要确定某种规则来决定处理这些任务 的顺序 在多道程序系统中，进程的数量往往是多于处理机个数的，这样不可能并行的处理各个进程 处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，已实现进程的并发执行 2.处理机调度的三个层次 高级调度 由于内存空间有限，操作系统无法将用户提交的所有作业全部加载进内存，因此需要某种规则来决定 将作业调入内存的顺序 高级调度（作业调度），按照一定的顺序从外存上处于后备队列的作业中选择一个或多个作业，给它 门分配内存等必要资源，建立相应进程的PCB，以使他们获得竞争处理机的权利 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会创建PCB 作业调出时才撤销PCB。高级调度主要是指调入问题，因为只有调入的时机需要操作系统来决定，但 调出的时机必然是作业运行结束 中级调度 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件或内存稍有空闲 ，再重新调入内存 这么做的目的是提高内存利用率和系统吞吐量 暂时调到外存的进程状态为挂起态，值得注意的是，处于挂起态的进程，PCB并不会调到外存，而是在内存记录 进程数据在外存存放的位置，进程状态等信息，操作系统通过PCB来保持对各个进程的监控，管理，被挂起进程 的PCB会被放入到挂起队列 中级调度（内存调度），就是要决定将哪个挂起态的进程重新调入内存 一个进程可能多次被调入，调出内存，因此中级调度发生的频率比高级调度更高 ********************************************************************************** 补充知识：进程的挂起态和七状态模型 暂时调到外存等待的进程状态为挂起状态 挂起状态又可以分为：就绪挂起，阻塞挂起 挂起和阻塞的区别 ：两种状态都是进程暂时不能获取cpu资源,挂起是把进程调度到外存，阻塞进程还在内存中 ********************************************************************************** 低级调度 低级调度（进程调度）按照某中规则从就绪队列中选择一个进程，将处理机分配给它 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须进行进程调度 进程调度的频率很高，一般几十毫秒一次 2.2_2 进程调度的时机切换与进程调度方式12345678910111213141516171819202122232425262728293031323334353637383940411.进程调度（低级调度）按照一定的算法从就绪队列中选择一个进程为其分配处理机 需要进行进程调度与切换的情况 主动放弃处理机 被动放弃处理机 不能进行进程调度和切换的情况 在处理中断的过程 进程在操作系统内核程序临界区 在原子操作过程中（原语） 进程在处于临界区时不能进行处理机调度 × 临界资源：一段时间内只允许一个进程使用的资源，各进程需要互斥的访问临界资源 临界区：访问临界资源的代码 内核程序临界区：一般是用来访问内核某种数据结构，比如进程的就绪队列（有各就绪进程的PCB组成）2.进程调度的方式 非剥夺调度方式，又称非抢占方式 只允许进程主动放弃处理机，在运行过程中即便有更紧急的任务到达，当前进程依然会使用处理机，直到该进程终止 或主动要求进入阻塞态 实现简单，系统开销小，但是无法处理紧急任务，适合早期的批处理系统 剥夺调度方式，又称抢占式 当一个进程在处理机上运行时，如果有一个更紧急的任务需要处理机，则立即暂停正在执行的进程，将处理机分配给 更紧急的那个进程 可以优先处理紧急的进程，也可以实现让各进程按时间片轮流执行的功能，适合于分时操作系统和实时操作系统3.进程的切换与过程 “狭义的进程调度”与“进程切换”的区别 狭义的进程调度是指按照一定的算法从就绪队列中选择一个要运行的进程（这个进程可以使刚刚被暂停执行的进程，也可以是 另一个进程，后一种情况就需要进程切换） 进程切换：是指让一个进程让出处理机，由另一个进程占用处理机的过程 广义的进程调度 包含了选择一个进程和进程切换两个步骤 进程切换的过程主要完成了 （1）对原来的运行进程的各种数据保存 （2）对新的进程各种数据进程恢复 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然会使整个系统的效率降低，使系统大部分时间花在了 进程切换上，而真正执行进程的时间减少 2.2_3 调度算法的评价指标123456789101112131415161718192021222324252627282930313233341.cpu利用率 cpu忙碌实现/总时间 利用率 = 忙碌时间/总时间2.系统吞吐量 计算机希望尽可能少的时间完成尽可能多的作业 系统吞吐量：单位时间内完成了多少道作业 系统吞吐量 = 总共完成了多少道作业/总时间3.周转时间 作业提交给系统开始，到作业完成这段时间间隔 （作业）周转时间=作业完成时间-作业提交时间 平均周转时间=各作业周转时间之和/作业数 带权周转时间=作业周转时间/作业实际运行的时间 平均带权周转时间 = 带权周转时间/作业数4.等待时间 进程/作业处于等待处理机状态的时间之和，等待时间越长，用户满意度越低 对于进程来说，等待时间就是在进程建立后等待被服务的时间之和（等待I/O完成时不计入等待时间） 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列等待的时间 一个作业要被CPU服务多久，使用多久的I/O设备一般是不变的，因此调度算法只会影响作业/进程的等待时间， “平均等待时间”评价整体性能5.响应时间 用户提出请求到首次产生响应的时间 2.2_4 FCFS,SJF,HRRN调度算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Tips:各种调度算法的学习思路 1. 算法思想 2. 算法规则 3. 用于作业调度还是进程调度 4. 抢占式？非抢占式？ 5. 优点和缺点 6. 是否会导致饥饿 饥饿：某个进程/作业长期得不到服务先来先服务（FCFS,First Come First Serve） 算法思想：“公平”，类似生活中排队 算法规则：按照作业/进程到达的先后顺序进行服务 用于进程/作业调度： 用于进程调度，考虑哪个进程先到达就绪队列 对于作业调度，考虑哪个作业先到达后备队列 是否抢占：非抢占式的算法（类似排队的时候插队不行） 优缺点： 优点：公平，算法实现简单 缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短时间来说用户体验不好 即，FCFS算法对长作业有利，对短作业不利（Eg:排队上厕所） 是否会导致饥饿：不会 短作业优先（SJF,Shortest Job First） 算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间 算法规则：最短的作业/进程最先得到服务（“最短”是指服务时间最短） 用于进程/作业调度： 既可以用于作业调度，也可以用于进程调度 用于进程调度时称为“短进程优先（SPF,Shortest Process First）算法” 是否抢占：SJF和SPF是非抢占式算法，但是也有抢占式版本--最短剩余时间优先算法（SRTN,Shortest Remaining Time Next) 优缺点： 优点：得到“最短”平均等待时间，平均周转时间 缺点：不公平，对短作业有利，对长作业不利，可能产生饥饿现象 是否会导致饥饿：会，如果源源不断的有短作业/进程到来，可能使长作业/进程得不到服务，产生“饥饿现象”,如果一直得不到服务， 则成为饿死FCFS,SJF 的思考 FCFS选择等待时间最长的作业理解：可以理解为先来先等待（去网吧等空机子，先去的先等待） 考虑一种算法，既考虑到各个作业的等待时间，又兼顾到作业的运行时间高响应比优先算法（HRRN,Hign Responce Ratio Next） 算法思想：综合考虑作业/进程的等待时间和要求服务的时间 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 响应比 = （等待时间+要求服务时间）/要求服务时间 （&gt;1） 用于进程/作业调度： 既可以用于作业调度，也可以用于进程调度 是否抢占：非抢占式算法，因为只有进程/作业主动放弃处理机时，才需要调度，才需要计算响应比 优缺点： 优点：综合考虑了等待时间和运行时间 等待时间相同时，要求服务时间短的优先（SJF的优点） 要求服务时间（运行时间）相同时，等待时间长的优先（FCFS的优先） 对于长作业来说，随着等待时间越来越久，响应比也会越来越大，从而避免了长作业饥饿的问题 是否会导致饥饿：不会 总结：这几种算法主要关系用户的公平性，平均周转时间，平均等待时间等评价系统整体性能的指标，但是不关心响应时间，也不区分 任务的紧急程度，因此对用户来说，交互性很糟糕，因此这三种算法一般适合于早期的批处理系统，当然，FCFS算法也进程结合 其他算法使用，选择也用的比较多。适用于交互式调度算法将在下个小结介绍 例题：各进程到达就绪队列的时间，需要的运行时间如下表所示，依次使用FCFS,SJF,SRTN,HRRN 调度算法，计算各进程的等待时间 ，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。 进程 到达时间 运行时间 p1 0 7 p2 2 4 p3 4 1 p4 5 4 FCFCS &amp;&amp; SJF SRTN HRRN 2.2_5 时间片轮转，优先级，多级反馈队列调度算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899Tips:各种调度算法的学习思路1. 算法思想2. 算法规则3. 这种调度算法是作业调度还是进程调度4. 抢占式？非抢占式5. 优点和缺点6. 是否会导致饥饿1.时间片轮转(RR,Round-Robin) 算法思想：公平的，轮流的为各个进程服务，让每个进程在一定的时间间隔内都可以得到相应 算法规则： 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程 未在一个时间片内执行完则剥夺处理机，将进程重新放回就绪队列队尾排队 用于进程/作业调度： 只能用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机 时间片） 是否抢占： 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，所以时间片轮转调度算法 属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到 优缺点： 优点：公平，响应快，适合于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度 是否会导致饥饿：不会 补充：时间片太大或太小的影响 如何时间片太大，导致每一个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化 为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大 *增大响应时间理解：比如系统中有十个进程并发执行，如果时间片为1s，则一个进程被响应 可能需要等待9s 如何时间片太小，进程的调度，切换是有代价的（保存，恢复运行环境），导致进程切换过于 频繁，系统会话大量的时间来处理切换进程，导致用于执行进程的时间减少 （一般来说，设计时间片要让切换进程的开销比不超过1%）2. 优先级调度算法 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的 紧急程度来决定处理顺序 算法规则： 每个作业/进程都有各自的优先级，调度时选择优先级最高的作业/进程 用于进程/作业调度： 既可以用于作业调度也可以用于进程调度，甚至还会用于之后学习的I/O调度中 是否抢占： 抢占式，非抢占式都有，在计算的时候，非抢占式只需在进程主动放弃处理机时进行调度即可 而抢占式还需要在就绪队列发送时，检查是否会发生抢占 优缺点： 优点：使用优先级区分任务的紧急程度，适用于实时操作系统 缺点：如果源源不断的有高优先级的作业/进程到来，可能会导致饥饿，甚至饿死 是否会导致饥饿：会（圆源源不断的有高优先级的进程到来） 补充： 就绪队列未必只有一个，可以按照不同的优先级组织，另外，也可以把优先级高的进程排在更靠近 队头的位置 根据优先级是否可以动态改变 可以将优先级分为 静态优先级 和 动态优先级两种 静态优先级：创建进程时确定，然后一直保持不变 动态优先级：创建进程时有一个初始值，之后会动态的调整优先级 思考：如何合理的设置进程的优先级 系统进程的优先级 高于 用户进程 前台进程的优先级 高于 后台进程 操作系统更偏好I/O型进程（或称I/O繁忙型进程） 与I/O型进程对应的是计算型进程（或称cpu繁忙进程） 思考：如果采用动态优先级，什么时候跳转 可以从追求公平，提升资源利用率角度考虑 如果某进程在就绪队列等待了很长时间，可以适当提高优先级 如果某进程占用了处理机很长时间，可以适当降低其优先级 如果发现一个进程频繁的进程I/O操作，可以适当的提高优先级 思考： FCFS优点 公平 SJF优点 平均等待时间/周转时间等比较短 时间片轮转优点 每个进程得到及时的响应 优先级调度算法优点 灵活的调整每个进程被服务的机会 有没有一种算法结合上面所有优点？？3.多级反馈队列调度算法 算法思想：对其他算法的折中权衡 算法规则： 1. 设置多级就绪队列，各级就绪队列的优先级从高到低，时间片从大到小 2. 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束 则进程进入下一队列队尾，如果此时已经是在最下列的队列，则会放回改队列的队伍 3. 只有当K级队列为空时，才会为k+1级队头的进程分配时间片 用于进程/作业调度：用于进程调度 是否抢占：抢占式算法，在K级队列的进程运行过程中，若更上级的队列中存入了一个新进程，则由于新 进程处于优先级更高的队列中，新进程会抢占处理机，原来运行的进程放回k级队列队尾 优缺点： 优点：对各个进程相对公平(FCFS优点)；每个新到达的进程都可以很快得到响应（RR的优点）；短进程 只需要很少的时间就能完成（SPF的优点）；不必实现估计进程运行时间（避免用户造假）；可以灵活 的跳转各类进程的偏好程度，比如cpu密集型进程，i/o密集型进程（拓展：可以将因I/O阻塞的进程 重新放回原队列，这样I/O进程就可以保持较高的优先级） 是否会导致饥饿：会（源源不断的短进程） 比起早期的批处理系统，由于计算机造假大幅降低，因此之后出现的交互式操作系统（包括分时操作系统， 实时操作系统）更注重系统的响应时间，公平性，平衡性等指标。而这几种算法也恰好的满足交互式系统的 需求。因此这三种算法适合用于交互式系统（UNIX使用的就是多级反馈队列调度算法） 一定要做习题！！！！！！！！！！（明天） 例题1：12345678各进程到达就绪队列的时间，需要运行的时间如下表所示进程 到达时间 运行时间p1 0 5p2 2 4p3 4 1p4 5 6使用时间片轮转（RR）算法,分析时间片大小是2,5时进程的运行情况 例题2：12345678各进程到达就绪队列的时间，需要运行的时间，进程优先数如图所示。分别使用非抢占式的优先级调度算法，分析进程运行的情况（注：优先数越大，优先级越高）进程 到达时间 运行时间 优先数p1 0 7 1p2 2 4 2p3 4 1 3p4 5 4 2 例题3：123456各进程到达就绪队列的时间，需要的运行时间如下图。使用多级反馈队列调度算法，分析进程运行的过程进程 到达时间 运行时间p1 0 8p2 1 4p3 5 1","link":"/posts/8b5271f8/"},{"title":"三、springboot与日志","text":"摘要： springboot与日志 SLF4J + Logback 三、springboot与日志1、日志框架小张；开发一个大型系统； ​ 1、System.out.println(“”);将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架；zhanglogging.jar ​ 3、高大上的几个功能？异步模式？自动归档？……………… zhanglogging-good.jar ​ 4、将以前框架卸下，换上新的框架，重新修改api ​ 5、JDBC – 数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar ​ 给项目中导入具体的日志实现就可以了；我们之前的日志框架都是实现的抽象层 市面上的日志框架； ​ JUL、JCL、Jboss-logging、log4j、slf4J…… ​ 左边选一个门面（抽象层），右边选一个实现； 日志门面 ：SLF4J 日志实现：Logback springboot：底层是spring框架，spring框架默认使用的是JCL; ​ springboot选用的是SLF4J和Logback 2、SLF4J使用1、如何在系统中使用SLF4J以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用抽象层里的方法； 给系统导入SLF4J的jar 和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); }} ​ 每一个日志的实现框架都有自己的配置文件，使用SLF4J以后，配置文件还是做成日志实现框架自己本身的配置文件 2、遗留问题a (slf4j + logback) : spring(commons-logginf) Hibernate(jboss-logginf),mybatis………… 统一日志记录，即使别的框架和我们一起使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； 将系统中其他日志框架先排除出去； 用中间包来替换原有的日志框架； 我们再来导入slf4j其他的实现 3、springboot日志关系123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; springboot使用它来做日志功能 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 底层依赖关系（新版本不一样啊。。。） 总结： springboot底层也是使用slf4j+ logback的方式进行日志记录 springboot也把其他的日志都替换成了slf4j 中间替换包 如果我们要引入其他框架？一定要移除框架的默认日志依赖 ​ spring框架使用的是commons-logging ​ 新版本不一样（吐血） spring能自动适应所有的日志而且底层使用的是slf4j + logback的方式记录日志，引入其他框架时，只需要把这个框架依赖的日志框架排除掉 4、日志使用1、默认配置spring默认帮我们配置好了日志； 1234567891011//System.out.println();Logger logger = LoggerFactory.getLogger(getClass());//日志的级别;//由低到高 trace debug info warn error//可以调整需要输出的日志级别;日志就只会在这个级别以及以后的高级别生效//springboot默认info级别logger.trace(\"这是trance日志\");logger.debug(\"这是debug日志\");logger.info(\"这是info日志\");logger.warn(\"这是warn日志\");logger.error(\"这是error日志\"); 5、切换日志框架看饱了，直接跳","link":"/posts/fbe4c5bd/"},{"title":"二.进程，处理机调度与死锁（二）","text":"摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁 2.3_1 进程同步，进程互斥123456789101112131415161718192021222324252627282930311.什么是进程同步 进程的异步，各个并发的进程，以各自独立的，不可预知的速度向前推进 同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在 某些位置上协调他们的工作次序而产生制约关系，进程间的直接制约关系就是源于他们之间的相互 合作2.什么是进程互斥 进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如 内存，打印机，摄像头这样的I/O设备） 我们把一时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头，打印机） 都属于临界资源。此外还有许多变量，数据，内存缓冲区都属于临界资源 对临界资源的访问，必须互斥的进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界 资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束时，释放 资源后，另一个进程才能去访问临界资源 对临界资源的互斥访问，可以在逻辑上分为四个部分 进入区 负责检查是否可以进入临界区，若可进入，则应设置正在访问临界区的标志（上锁）， 以阻止其他进程同时进入临界区 临界区 访问临界资源的那段代码 退出区 负责解除正在访问临界资源的标志（解锁） 剩余区 做其他处理 为了实现对临界进程的互斥访问，同时保证系统的整体性，需要遵循以下原则 1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 2.忙则等待。已经有程序进入临界区时，其他试图进入临界区的进程必须等待 3.有限等待。对请求访问的进程，应保证在有限的时间内进入临界区 4.让权等待。当进程不能进入处理机，应立即释放处理机，防止进程忙等待 2.3_2 进程互斥的软件实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Tips: 1.理解各个算法的思想，原理 2.结合上小结学习“实现互斥的四个逻辑部分”，重点理解各算法在进入区，退出区都做了什么 3.分析各算法存在的缺陷（结合“进程互斥的四个原则”进程分析）1.单标志法 算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程访问 临界区的权限只能由另一个进程赋予 int turn = 0; //turn 表示当前允许进入临界区的进程号 p0进程： p1进程 while(turn != 0); while(turn != 1); critical section; critical section; turn = 1; turn = 0; remainder section; remainder section; 对于临界区的访问，一定是按p0 -&gt; p1 -&gt; p0 -&gt; p1 这样轮流访问的。这种必须轮流访问带来的问题是 ，如果此时允许进入临界区的进程是p0,而p0一直不访问临界区，那么此时临界区空闲，但是并不允许p1 访问 因此但单标志法存在的主要问题是：违背“空闲让进”原则2.双标志先检查法 算法思想：设置一个布尔类型的数组flag[]，数组中的各个元素用来标记各个进程想进入临界区的意愿， 比如“flag[0] = ture”意味着零号进程现在想要进入临界区，每个进程在进入临界区之前先检查当前 有没有别的进程想进入临界区，如果没有，则把自身对应的flag[i]设置为true,之后开始访问临界区 bool flag[2]; //表示进入临界区意愿的数组 flag[0] = false; flag[1] = false; //刚开始两个进程都不想进入临界区 p0进程： p1进程： while(flag[1]); 1 while(flag[0]); 5 flag[0] = true; 2 flag[1] = true; 6 cirtical section; 3 critical section; 7 flag[0] = false; 4 flag[1] = false; 8 remainder section; remainder section; 如果按照 1 5 2 6 3 7 4 8 的顺序执行，p0,p1将会同时访问临界区 双标志法存在的主要问题：违背“忙则等待”原则 原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换3.双标志后检查法 算法思想：双标志先检查法，前一个算法的问题是先“检查”，后“上锁”，但是这两个操作又无法一气呵成， 因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法来避免上述 问题 bool flag[2]; //表示进入临界区意愿的数组 flag[0] = false; flag[1] = false; //刚开始两个进程都不想进入临界区 p0进程： p1进程： flag[0] = true; 1 flag[1] = true; 5 while(flag[1]); 2 while(flag[0]); 6 cirtical section; 3 critical section; 7 flag[0] = false; 4 flag[1] = false; 8 remainder section; remainder section; 如果按照 1 5 2 6 执行 p0和p1都无法进入临界区 双标志后检查法虽然解决了“忙则等待”的问题，但又导致了“空闲让进”，“有限等待”的原则， 会因各进程长期无法访问临界区资源而产生“饥饿”现象4.Peterson算法 算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后都无法进入临界区。 Gary L.Peterson 想到了一种方法，如果双方都争着进入临界区，那可以让进程尝试“孔融让梨”， 主动让对方先进入临界区 bool flag[2];//表示进入临界区意愿的数组，初始值都是false int turn = 0;//turn 表示优先让哪个进程进入临界区 p0进程： flag[0] = true; 1 turn = 1; 2 while(flag[1] &amp;&amp; turn == 1); 3 critical section; flag[0] = false; remainder section; p1进程： flag[1] = ture; 4 turn = 0; 5 while(flag[0] &amp;&amp; turn = 0); 6 critical section; flag[1] = false; remainder section; Peterson算法解决了进程互斥问题，遵循“空闲让进”，“忙则等待”，“有限等待”三个原则，但依然未能遵循 “让权等待”,想比之前三种算法，是最好的，但是依然不够好 2.3_3 进程互斥的硬件实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Tips: 1.理解各个方法的原理 2.了解各个方法的优缺点1.自断屏蔽方法 利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被 中断，也就不能实现进程切换，因此避免了同时访问临界区） ... 关中断； 关中断即不允许当前进程被中断，也必然不会发生进程切换 临界区； 开中断； 直到进程访问完临界区，再执行开中断指令，才有可能别的进程上处理机并访问临界区 ... 优点：简单，高效 缺点：不适合多处理机的操作系统；只使用与内核进程，不使用用户进程（开/关中断指令只能运行在内核态 这组指令让用户随意使用会很危险）2.TestAndSet 简称TS指令，也有地方TestAndSetLock指令，或TSL指令 TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下使用c语言实现的逻辑 //bool共享变量lock 表示当前临界区是否加锁 //true 表示已经加锁，false 表示未加锁 bool TestAndSet(bool *lock){ bool old; old = *lock; //old存放lock原来的值 *lock = true; //加锁 return old; //返回lock原来的值 } while(TearAndSet(&amp;lock));//上锁并检查 临界区代码段... lock = false //解锁 剩余区代码段... 相比软件实现的方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作 优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境 缺点：不满足“让权等待” 产生忙等现象3.Swap 有的地方也叫Exchange指令，或简称XCHG指令。 swap指令是硬件实现的执行的过程不允许被中断，只能一气呵成，以下是C语言逻辑 //Swap指令的作用是交换两个变量的值 Swap(bool *a,bool *b){ bool temp; temp = *a; *a = *b; *b = temp; } // bool型 lock 表示当前临界区是否被加锁 bool old = true; while(old == true) swap(&amp;lock,&amp;old); 临界区代码段... lock = false; 剩余区代码段... 逻辑上个和TS无太大区别 相比软件实现的方法，SWAP指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作 优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境 缺点：不满足“让权等待” 产生忙等现象 2.3_4 信号量机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题？进程互斥的四种软件实现方式（单标志法，双标志法先检查，双标志后检查，Peterson）进程互斥的三种硬件实现方式（中断屏蔽法，TS/TSL指令，Swap/XCHG指令） 1.单标志检查法只能轮换的执行进程，不满足“空闲让进”2.双标志先检查法，进入区的“检查”，“上锁”操作无法一气呵成，从而导致了两个进程可能同时进入临界区 不满足：“忙则等待”3.双标志后检查法，进去区的“上锁”，“检查”操作无法一气呵成，导致了两个进程都无法进入临界区 不满足：“空闲让进”，“有限等待”4.peterson算法,无法实现“让权等待”5.所有解决方案都无法实现“让权等待”1965年,荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥，同步的方法 -- 信号量机制1.信号量机制 用户进程可以通过操作系统提供的一对原语来对信号量进行操作，从而方便的实现了进程互斥与同步 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量表示系统中 某种资源的数量 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由开中断/关中断指令实现的。软件解决方 案的主要问题是“进入区的操作不能一气呵成”，因此如果把进入区，退出区的操作使用原语实现，使这些操作 一气呵成，就能解决问题 一对原语：wait(S),signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号 里的信号量S其实就是函数调用时传入的一个参数 wait,signal原语常简称为P,V（来自荷兰语）因此，做题的时候可能遇到P(S),V(S)2.整型信号量 用一个整数型的变量作为信号量，用来表示系统中某种资源的数量 与普通整数型变量的区别:对信号量操作只有三种 初始化，P操作，V操作 -------------------------------------------------------------------- EG:某系统只有一台打印机 int S = 1;//初始整数型信号量S，表示当前系统中可用的打印机资源数 void wait(int S){ while(S&lt;=0); //如果资源数不够，就一直循环等待 存在的问题：不满足让权等待，会发生忙等 S = S - 1; //如果有资源数够，则占用一个资源 } void signal(int S){ S = S + 1; //释放资源 } 进程p0: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... 进程p1: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... ------------------------------------------------------------------- 3.记录型信号量 （*超高频出题点） 整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构标志信号量 /*记录型信号量的定义*/ typedef struct { int value; //剩余资源数 struct process *L; //等待队列 } semaphore void wait(S){ S.value --; if(S.value &lt; 0){ //如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（阻塞队列） block(S.L); } } void signal(S){ S.value ++; if(S.value &lt;= 0){ //释放资源后，若还有别的进程在等待使用这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程 从阻塞态变为就绪态 wakeup(S.L); } } --------------------------------------------------------------------------- EG:某计算机系统中有两台打印机，则可在初始化信号量S时将value设为1，就绪队列S设为空 typedef struct { int value; //剩余资源数 ==2 struct process *L; //等待队列 ==null } semaphore 进程p0: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... 进程p1: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... 进程p2: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... 进程p3: ... wait(S) //进入区，申请资源 使用打印机资源 //临界区，访问资源 signal(S) // 退出区，释放资源 ... （纸上运行一遍....） --------------------------------------------------------------------------- block原语进行了自我阻塞（当前运行进程从运行态-&gt;就绪态）主动放弃处理机，满足“让权等待” 住：若考试中出现了P(S),V(S)操作，除非特殊说明，默认S为记录型信号量 2.3_5 信号量机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571.信号量机制实现进程互斥 （1）分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区） （2）设置互斥信号量mutex,初值为1 （3）在临界区之前执行P(mutex) （4）在临界区之后执行V(mutex) /*信号量机制实现互斥*/ semaphore mutex = 1; //初始化信号量 p1(){ ... P(mutex); 临界区代码段... V(mutex); ... } p2(){ ... P(mutex); 临界区代码段... V(mutex); ... }2.信号量机制实现进程同步 进程同步：要让并发执行的进程有序的推进 （1）分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码） （2）设置同步信号量S，初值为0 （3）在“前操作”之后执行V(S) //前V后P （4）在“后操作”之前执行P(S) 要求：代码p4执行一定是在p2之后 /*信号量机制实现同步*/ semaphore S = 0； //初始化信号量 P1(){ 代码1; 代码2; P(S); 代码3; } P1(){ V(S); 代码4; 代码5; 代码6; }3.信号量实现进程的前驱关系 每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作） 因此： （1）要为每一对前驱关系各设置一个同步变量 （2）在“前操作”之后相对应的同步变量执行V操作 （3）在“后操作”之前相对应的同步变量执行P操作 2.3_6 生产者消费者问题系统中有一组生产者进程和一组消费者进程，生产者进程每次产生一个产品放入缓存区，消费者进程每次从缓冲区拿出一个进程并使用（注：这里的产品理解为某种数据）生产者，消费者共享一个初始为空，大小为n的缓冲区 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从缓冲区取出产品，否则必须等待 缓冲区 是临界资源，各进程必须互斥的访问 pv操作题目分析步骤：1.关系分析。找出题目中描述的各个进程，分析它们之间的同步，互斥关系 2.整理思路。根据各进程的操作流程确定P,V操作的大致顺序 3.设置信号量。设置需要的信号量，并根据题目条件确定信号量初值（互斥信号量一般为1，同步信号量的初始值要看对应资源的初始值是多少） 12345678910111213141516171819202122232425semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问semaphore empty = n; //同步信号量，表示空闲缓冲区的数量semaphore full = 0; // 同步信号量，表示产品的数量（非空缓冲区的数量）producer() { while(1) { 生产一个产品； P(empty);//消耗一个空闲缓冲区 p(mutex); 把产品放入缓冲区; V(mutex); V(full);//增加一个产品 }}consumer() { while(1) { P(full);//消耗一个产品（非空缓冲区） p(mutex); 从缓冲区拿出一个产品; V(mutex); V(empty);//增加一个空闲缓冲区 使用产品; }} 思考：能否改变相邻的P,V操作顺序 不能，会发生死锁现象 实现互斥的P操作一定要放在实现同步的P操作之后 V操作不会导致进程阻塞，因此 两个V操作的顺序可以交换 知识回顾与重要考点生产者消费者问题是一个互斥，同步的综合问题，对于初学者来说最难的是发现题目中隐含的两对同步关系，有时候是消费者需要等待生产者，有时候是生产者要等待消费者，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量 2.3_7 多生产者消费者问题问题描述桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放 橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才 可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。 问题分析互斥关系：对缓冲区（盘子）的访问需要互斥的进行 同步关系（一前一后）： 父亲将苹果放入盘子后，女儿才能取到苹果 母亲将橘子放入盘子后，儿子才能取得橘子 只有盘子为空时，父亲或母亲才能放入水果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748semaphore mutex = 1;//实现对互斥访问盘子（缓冲区）semaphore apple = 0;//表示盘子里有几个苹果semaphore orange = 0;//表示盘子里有几个橘子semaphore plate = 0;//表示盘子里还能放多少个水果dad() { while(1) { 准备放一个苹果； P(palte); p(mutex); 把苹果放入盘子； V(mutex) V(apple); }}mom() { while(1) { 准备放一个橘子； P(plate); p(mutex); 把橘子放入盘子； Vmutex); V(orange); }}sun() { while(1) { P(orange); p(mutex); 从盘子中取出苹果； Vmutex); V(plate); 吃掉苹果； }}daughter() { while(1) { P(apple); p(mutex); 从盘0子中取出橘子； V(mutex); V(plate); 吃掉橘子; }} 去掉实现互斥访问缓冲区的信号量mutex，不会发生多个进程同时访问临界区的现象 原因在于：本题中缓冲区的大小为1，在任何时刻，apple,orange,plate三个同步信号量中最多只有一个是1，因此在任何一个时刻，至少有一个进程的P操作不会被阻塞，并顺利的进入临界区 知识回顾与重要考点 在生产者消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现访问缓冲区的功能，当然这不是绝对的，要根据问题具体分析 如果在考试过程中来不及分析，可以加上互斥信号量，保证各进程一定互斥的访问临界区，再次注意，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起死锁 解决多生产者消费者问题的关键在于理清复杂的同步关系，在分析同步问题的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做两种“事件的前后关系“ 2.3_8 吸烟者问题问题描述假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷 起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、 第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌 子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供 应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟） 问题分析物品组合 组合1:纸 + 胶水 组合2:烟草 + 胶水 组合3: 烟草 + 纸 互斥关系： 桌子可以抽象为容量为1的缓冲区，需要互斥访问（缓冲区容量为1可以不设置互斥信号量） 同步关系（从事件的角度分析） 桌上有组合1 -&gt; 第一个吸烟者取走东西 桌上有组合2-&gt; 第二个吸烟者取走东西 桌上有组合3 -&gt; 第三个吸烟者取走东西 发出完成信号 -&gt; 供应者将下一个组合放到桌上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//缓冲区容量为1无需设置互斥信号线semphore s1 = 0; //桌子上组合1的数量semphore s2 = 0;//桌子上组合2的数量semphore s3 = 0;//桌子上组合3的数量sephore finish = 0;//是否有人完成吸烟pruducer(){ int i = 1; while (1) { if (i == 1) { P(finish); 把组合1放到桌子上； V(S1); } else if (i == 2) { P(finish); 把组合2放到桌子上； V(S2); } else { P(finish); 把组合3放到桌子上； V(S3); } i = (i + 1) % 3; }}smoker1() { while (1) { P(s1); 从桌上拿走组合1，卷烟，吸烟； V(finish); }}smoker2() { while (1) { P(s2); 从桌上拿走组合2，卷烟，吸烟； V(finish); }}smoker3() { while (1) { P(s3); 从桌上拿走组合3，卷烟，吸烟； V(finish); }} 2.3_9 读者-写者问题问题描述有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不 会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致 数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者 往文件中写信息;③任一写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作 前，应让已有的读者和写者全部退出。 问题分析两类进程：读进程，写进程 互斥关系：写进程 - 写进程 ，写进程-读进程。读进程与读进程不存在互斥问题 写进程与任何进程都互斥，设置一个信号量rw，在写进程访问共享文件前后分别执行P,V操作。 读者进程和写者进程也要互斥，因此读者进程访问共享文件前后也要对rw执行P,V操作 如果所有读者进程在访问共享文件时都执行P(rw)操作会导致各个读进程之间也无法同时访问文件 读者-写者问题的核心–怎么解决该问题 P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问。而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程加锁，让最后一个访问共享文件的读进程解锁。设置一个整型变量count来记录当前有几个读进程在访问文件 12345678910111213141516171819202122232425262728293031323334seamphore rw = 1;//用于实现对文件的互斥访问，表示当前是否有进程在访问共享文件int count = 0; //记录当前有几个读进程在访问文件semaphore mutex = 1; //用于保证对于count变量的互斥访问semaphore w = 1; //用于实现“写优先”(解决写进程饥饿)writer() { while(1) { P(w); P(rw); //写之前“加锁” 写文件...； V(rw); //写之后“解锁” V(w); }}reader() { while(1) { p(W); P(mutex); //各读进程互斥的访问count if (count == 0) { P(rw); //第一个读进程负责“加锁” } count ++; //访问文件的进程数 +1 V(mutex); V(w); 读文件； P(mutex); count --; //访问文件的进程数-1 if (count == 0) { V(rw); //最后一个读进程负责“解锁” } V(mutex); }} 知识回顾与重要考点读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。 其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的进程数，我们可以用count的值来判断当前进入的进程是否是第一个/最后一个进程，从而做出不同的处理。 另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果要实现“一气呵成”，自然应该想到使用互斥信号量 最后，还需要体会是如何解决写饥饿问题的 2.3_10 哲学家进餐问题问题描述一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学 家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时， 才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲 学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。 问题分析1.关系分析：系统中有五个哲学家进程，五位哲学家与左右邻居对其中间筷子的访问是互斥关系 2.整理思路：这个问题中只有互斥关系，但与之前的问题不同的是，每个哲学家进程需要同时拥有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓 3.信号量设置：定义互斥信号量数组chopstick[5] = {1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0-4编号，哲学界左边的筷子编号为i，右边筷子的编号为（i + 1）% 5。 如何防止死锁的发生 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家正好相反。用这种方式可以保证如果两个相邻两个哲学家都想吃饭，那么只会有一个可以拿起第一只筷子，另一个就会被阻塞，这就避免了占有一只再等待另一只的情况 仅当哲学家左右都有筷子时才允许进餐 （这种方法不能保证当两边的筷子可用时，哲学家可以进餐） 1234567891011121314semaphore chopstick[5] = {1,1,1,1,1};semaphore mutex = 1; //表示哲学家左右是否有筷子pi() { while(1) { P(mutex); P(chopstick[i]); P(chopstick[(i+1)%5]); V(mutex); 吃饭...; V(chopstick[i]); V(chopstick[(i+1)%5]); 思考...; }} 知识回顾与重要考点哲学家进餐问题的关键是解决进餐死锁 这些进程之间只存在互斥关系，但与之前不同的是每个进程需要持有两个临界资源，因此有了“死锁”的问题隐患 如果在考试中遇到了一个进程需要持有多个临界资源的情况，应该参考哲学家问题的思想，分析题目中的进程之间是否会发生循环等待，是否会发生死锁 可以参考哲学家就餐问题解决死锁的三种思路 2.3_11 管程（1）为什么要引入管程信号量机制存在到的问题：编写程序困难，易出错 能不能设计一种机制，让程序员写程序时不需要关注复杂的P,V操作，让写代码更加轻松 1973年，Brinch Hansen 首次在程序设计语言（Pascal）中引入了“管程”成分——一种高级同步机制 （2）管程的定义和基本特征管程是一种特殊的软件模块，有这些部分组成 局域于管程的共享数据结构说明； 对该数据结构进行操作的一组过程； 对局部与管程的共享数据设置初始值的语句； 管程有一个名字； 管程的基本特征： 局部与管程的数据只能被局部与管程的过程所访问 一个进程只有通过调用管程内的过程才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 拓展1：使用管程解决生产者消费者问题1234567891011121314151617181920212223242526272829303132333435363738monitor ProducerConsumer { condition full,empty; //条件变量用来实现同步 int count = 0; //缓冲区中的产品数 void insert (Item item) { if (count == N) { wait(full); } count ++: insert_item(item); if (count == 1) { signal(empty); } } Item remove() { if (count == 1) { wait(empty); } count --; if (count == N - 1) { signal(full); } return remove_item(); }}producer() { while(1) { item = 生产一个产品; ProducerConsumer.insert(item); }}consumer() { while(1) { item = PruducerConsumer.remove(); 消费产品item; }} 引入管程的目的无非就是更方便的实现进程互斥和同步 需要在管程中定义共享数据 需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数 只有通过这些“入口”才能访问共享数据 管程中有很多“入口”，但是每次只能开放其中一个入口，且每次只能让一个进程或者线程进入（注意：互斥是由编辑器实现的） 可以在管程中设置条件变量及等待/唤醒操作解决同步问题，可以让一个进程或者线程在条件变量上等待；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒 拓展2 java中类似管程的机制synchronized关键字 12345678static class monitor { private Item buffer[] = new Item[N]; private int count = 0; public synchronized void insert(Item item) { ... }} 2.4_1 死锁的概念（1）什么是死锁在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 （2）死锁，饥饿，死循环的区别死锁：在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。 死循环：某进程执行过程中一直跳不出某个循环的现象，有时是程序逻辑bug导致，有时是程序员设计 （3）死锁产生的必要条件 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁 不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放 请求和保持条件：进程已经保持了一个至少一个资源，但是又提出了新的资源请求，而资源已经被其他进程占有，此时请求被阻塞，但是又对自己已有资源保持不放 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求 如果同类资源数大于1，即时有循环等待也未必发生死锁 但如果同类资源只有一个，发生循环等待必定发生死锁 （4）什么时候会发生死锁 对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能会引起死锁，对可剥夺的资源（CPU）是不会引起死锁的 进程推进顺序非法。请求和释放资源的顺序不当 信号量的使用不当 总之，对不可剥夺资源的不合理分配，可能导致死锁 （5）死锁的处理策略 预防死锁。破坏死锁产生的四个必要条件中的一个或几个 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法） 死锁的检测和解除。允许死锁的发生，不过操作系统会检测出死锁的发生，然后采取某种措施解除死锁 2.4_2 死锁的处理——预防死锁（1）破坏互斥条件互斥条件：只有对必须互斥使用的资源争抢才会导致死锁 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术，操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备 缺点：并不是所有设备可以改为共享设备，为了系统安全，有很多地方必须保持这种互斥条件，因此很多时候不能破坏互斥条件 （2）破坏不剥夺条件不剥夺条件：进程所获得得资源在未使用完之前，不能由其他进程强行夺走，只能主动释放 方案1：当某个进程请求新的资源得不到满足时，它必须立即释放所保持的所有资源，待以后需要的使用重新申请。也就是说，即时某些资源尚未使用完，也要主动释放，从而破坏了不可剥夺条件 方法2:当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将需要的资源强行剥夺。这种方式一般考虑进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用) 缺点： 实现起来比较复杂 释放已获得的资源可能会导致前一阶段的工作实效。因此这种方法一般使用与易宝存和恢复状态的资源，如cpu 反复的申请和释放资源会增加系统开销，降低系统的吞吐量 若采用方案1，会导致饥饿 *（3）破坏请求和保持条件请求和保证条件：进程已经持有了至少一个资源，又需要一个被其他进程持有的资源，此时请求进程被阻塞但又不释放已经持有的资源 可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在他的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，改进程就不会再请求别的任何资源了 改策略实现起来简单，但也有缺点 有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源换利用率极低。此外，可能导致某些进程饥饿 （4）破坏循环等待条件循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完 原理分析：一个进程只有已经占有小编号的资源时，才有资格更申请大编号的资源，按此规则，已经持有大编号资源的进程不可能逆向的回来申请小编号的资源，从而不会产生循环等待现象 缺点： 不方便添加新的设备，可能需要重新下编号 进程实际使用资源的顺序可能和编号递增的顺序不一致，会导致资源浪费 必须按照规定次序申请资源，用户编程很麻烦 2.4_3 死锁的处理策略——避免死锁（1）什么是安全序列你是一位成功的银行家，手里掌握着100个亿的资金… 有三个企业想找你贷款，分别是企业B、企业A、企业T，为描述方便，简称BAT。 B表示:“大哥，我最多会跟你借70亿…” A表示:“大哥，我最多会跟你借40亿…” 干表示:“大哥，我最多会跟你借50亿..” 然而…江湖中有个不成文的规矩:如果你借给企业的钱总数达不到企业提出的最 大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了…. 刚开始，BAT三个企业分别从你这儿借了20、10、30亿…. （2）安全状态，不安全状态，死锁的联系安全序列：系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态，当然，安全序列可以有多个 如果分配了资源后，系统找不到任何一个安全序列，系统就进入了不安全状态，就以为着之后可能所有进程都无法顺利的执行下去，当然，如果有进程提前归还了一部分资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁 因此可以在系统分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源的分配请求。这也是“银行家算法”的核心思想。 （3）银行家算法银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况，后来算法被用在操作系统中，用于避免死锁。 核心思想：在进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞 思考：bat的例子中，只有一种类型的资源——钱，但是在计算机系统中有多种资源，怎么将算法拓展为多种资源的情况呢 （4）知识回顾于重要考点数据结构: 长度为m的一维数组 Available表示还有多少可用资源 n_m矩阵Max表示各进程对资源的最大需求数 n_m矩阵Allocation表示已经给各进程分配了多少资源 Max-Allocation = Need矩阵表示各进程最多还需要多少资源 用长度为m的一位数组 Request表示进程此次申请的各种资源数 银行家算法步骤: ①检查此次申请是否超过了之前声明的最大需求数 ②检查此时系统剩余的可用资源是否还能满足这次请求 ③试探着分配，更改各数据结构 ④用安全性算法检查此次分配是否会导致系统进入不安全状态 安全性算法步骤: 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁 2.4_4 死锁的处理策略——死锁的检测和解除（1）死锁的检测为了能对系统中是否已经发生了死锁进行检测，必须： 用某种数据结构来保存资源请求和分配信息 提供一种算法，根据上述信息来检测系统是否已进入死锁状态 资源分配图 两种节点 进程节点：对应一个进程 资源节点：对应一类资源，一类资源可能有多个 两种边 进程节点 -&gt; 资源节点 ：表示进程想要申请几个资源（每一条边代表一个） 资源节点 -&gt; 进程节点 ： 表示为进程分配了几个资源（每一条边代表一个） 如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会被阻塞的，可以顺利的执行下去 如果这个进程执行结束后吧资源归还给系统，就可以是某个正在等待资源的进程被激活，并且顺利的执行下去 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样又可能会激活另外一些被阻塞的进程 如果按照上述过程分析，最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（想到与找到一个安全序列） 如果最终不能消除所有边，那么就发生了死锁 最终连着边的进程就是处于死锁状态的进程 （2）死锁的解除解除死锁的主要方法有： 资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是一个防止被挂起的进程长时间得不到资源而饥饿 撤销进程法：（终止进程法）强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但付出的代价可能会很大。因为有些进程可能已经运行了很长时间，或者已经接近结束了，一旦被终止可能功亏一篑 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，这就要系统记录进程的历史消息，设置还原点","link":"/posts/bb449d20/"},{"title":"二叉排序树","text":"摘要： 二叉排序树的概念、创建、遍历、删除 1、二叉排序树介绍 2、二叉排序树的创建与遍历代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.cyfwlp.binarysorttree;/** * @Author liaotao * @Date 2020/10/20 15:17 */public class BinarySortTreeDemo { public static void main(String[] args) { int[] arr = {7,3,10,12,5,1,9,}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点 for (int value : arr) { binarySortTree.add(new Node(value)); } binarySortTree.infixOrder(); }}//二叉排序树class BinarySortTree { private Node root; //添加结点 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } public void infixOrder() { if (root != null) { root.infinxOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } }}//Node节点class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //添加结点的方法 //递归的形式添加结点，需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } //判断传入节点的值和当前子树的根节点的值的关系 if (node.value &lt; this.value) { if (this.left == null) { //当前节点左子节点为空，直接挂上去 this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { if (this.right == null) { this.right = node; } else { this.right.add(node); } } } //中序遍历方法 public void infinxOrder() { if (this.left != null) { this.left.infinxOrder(); } System.out.println(this); if (this.right != null) { this.right.infinxOrder(); } }} 3、二叉排序树的删除 思路分析： 1）删除叶子节点 先去定位要删除的结点 targetNode 找到targetNode的父节点parent（考虑是否存在父节点） targetNode是父节点的左子节点还是右子节点 根据前面的情况对应删除 2）删除只有一颗子树的结点 先去定位要删除的结点 targetNode 找到targetNode的父节点 parent 判断target的子节点是左子节点还是右子节点 targetNode是parent的左子节点还是右子节点 如果targetNode是parent的左子节点 targetNode的子节点是左子节点 1parent.left = targetNode.left targetNode的子节点是右子节点 1parent.left = targetNode.right 如果targetNodes是parent的右子节点 targetNode的子节点是左子节点 1parent.right = targetNode.left targetNode的子节点是右子节点 1parent.right = targetNode.right 3）删除有两个子树的结点 先去定位要删除的结点 targetNode 找到targetNode的父节点 parent 从targetNode的右子树找到最小的结点 临时变量temp保存最小节点的值 删除最小结点 target.value = temp 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//查询节点public Node search(int value) { if (root == null) { return null; } else { return root.search(value); }}//查询父节点public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); }}//找到最小值并删除，返回最小结点的值public int delRightTreeMin(Node node) { Node target = node; //循环的查找左节点，就会找到最小值 while (target.left != null) { target = target.left; } //这是target就指向了最小的结点 //删除最小结点 delNode(target.value); return target.value;}//删除结点public void delNode(int value) { if (root == null) { return; } else { Node targetNode = search(value); if (targetNode == null) { //没有找到要删除的结点 System.out.println(\"没有找到要删除的结点\"); return; } //targetNode没有父节点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //找targetNode父节点 Node parent = searchParent(value); //要删除的结点是叶子节点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { //叶子节点 //判断targetNode是父节点的左子节点还是右子节点 if (parent.left != null &amp;&amp; parent.left.value == value) { //左子节点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) { //右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { //targetNode两颗子树 targetNode.value = delRightTreeMin(targetNode.right); } else { //只有一颗子树 if (targetNode.left != null) { //如果要删除的结点有左子节点 if (parent != null) { if (parent.left.value == value) { parent.left = targetNode.left; } else { parent.right = targetNode.left; } } else { root = targetNode.left; } } else { if (parent != null) { if (parent.left.value == value) { //如果要删除的结点有右子节点 parent.left = targetNode.right; } else { parent.right = targetNode.right; } } else { root = targetNode.right; } } } }} 课后作业： 在删除有两个子树的结点时，从targetNode的左子树找到最大节点进行替换 12345678910//课后作业代码实现// 从targetNode的左子树找到最大节点进行替换public int delLeftTreeMin(Node node) { Node target = node; while (target.right != null) { target = target.right; } delNode(target.value); return target.value;}","link":"/posts/e5052ecb/"},{"title":"二进制的原码，补码，反码","text":"摘要： 在学习数据结构与算法赫夫曼编码时，发现对二进制一些的知识有所欠缺，现进行简单的补充 字节与位bit (位) ：数据存储的最小单元，在计算机二进制系统中，位，简记为b，也称为比特(bit)，每个二进制的数字0或1就是一个位(bit)，其中1 byte (字节)= 8 bit(位) java中int类型占4个字节，即就是需要32个二进制位表示 无符号数与有符号数在计算机中参与运算的数有两大类 ： 无符号数和有符号数 （1）有符号数 ​ 对于有符号数而言，符号的正、负机器是无法识别的，但由于“正、负”恰好是两种截然不同的状态，如果用“0”表示“正”，用“1”表示“符”，这样符号也被数字化了， ​ 并且规定将它放在有效数字的前面，即组成了有符号数。所以，在二进制中使用最高位（第一位）来表示符号，最高位是0，表示正数；最高位是1，表示负数。 （2）有符号数 ​ 无符号数是针对二进制来讲的，无符号数的表数范围是非负数。全部二进制均代表数值（所有位都用于表示数的大小），没有符号位。即第一个”0”或”1”不表示 正负。 例子： int number = 1 在计算机中表示： 00000000 00000000 00000000 00000001 同理 -1 ：10000000 00000000 00000000 00000001 （最高位是符号位，正数为0，负数为1） 二进制中的原码，反码，补码对于有符号数而言： （1）二进制的最高位是符号位：0表示正数，1表示负数； （2）正数的原码，反码，补码都一样； （3）负数的补码 = 它的原码符号位不变，其他位取反； （4）负数的补码 = 它的反码 + 1； （5）0的反码，补码都是0； （6）在计算机底层进行预算的时候，都是以补码的方式来运算的； 例子： 123456789101112131415161718192021222324252627282930public class TestByteToBitString { public static void main(String[] args) { // 将一个byte转成一个二进制的字符串 byte b = 56; int a = 456; b = (byte) a; String str1 = Integer.toBinaryString(a); //得到的是二进制的补码 String str2= Integer.toBinaryString(b); System.out.println(str1); System.out.println(str2); /* b = -56 补码：1100 1000 反码：补码 -1 = 1100 0111 源码：0011 1000 b = 56 补码：0011 1000 源码：0011 1000 a = 456 a : 0000 0000 0000 0000 ...... 001 1100 1000 （32位） b = (byte) a; //强类型转换，直接截取后8位 b : 1100 1000 (补码) b = -56; */ }} 连续搞了半个月的小项目终于有时间继续更新博客了！冲冲冲","link":"/posts/9b6873a3/"},{"title":"六、springboot与数据访问","text":"摘要： springboot与数据访问 1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:///jdbc 效果： ​ 默认使用：com.zaxxer.hikari.HikariDataSource 数据源 ​ 数据源的相关配置都在DataSourceProprtties 1、可以使用spring.datasource.type改变默认数据源 2、springboot支持的数据源 123org.apache.commons.dbcp2.BasicDataSourcecom.zaxxer.hikari.HikariDataSourceorg.apache.tomcat.jdbc.pool.DataSource 3.自定义数据源 12345678910111213141516@Configuration( proxyBeanMethods = false)@ConditionalOnMissingBean({DataSource.class})@ConditionalOnProperty( name = {\"spring.datasource.type\"})static class Generic { Generic() { } @Bean DataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().build(); }} 2、整合druid数据源1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class DruidConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource druid() { return new DruidDataSource(); } //配置Druid的监控 //1.配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); bean.setInitParameters(initParams); return bean; } //2.配置一个监控的filter @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean filter = new FilterRegistrationBean(); filter.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); filter.setInitParameters(initParams); filter.setUrlPatterns(Arrays.asList(\"/*\")); return filter; }} 3、整合Mybatis配置文件版： 123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/","link":"/posts/be1ecb79/"},{"title":"哈希表","text":"摘要： 哈希表 9、哈希表哈希表（散列）- goole上机题 看一个实际需求，google公司的一个上机题; 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..)当输入该员工的id时,要求查找到该员工的所有信息. 要求:不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列) 1、哈希表的基本介绍 2、goole上机题使用哈希表管理雇员信息 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214package com.cyfwlp.HashTable;import java.util.Scanner;public class HashTableDemo { public static void main(String[] args) { //创建哈希表 HashTable hashTable = new HashTable(7); //写一个菜单 String key = \"\"; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add 添加雇员\"); System.out.println(\"list 显示雇员\"); System.out.println(\"find 查找\"); System.out.println(\"delete 删除\"); System.out.println(\"exit 退出\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); Emp emp = new Emp(id,name); hashTable.add(emp); break; case \"list\": hashTable.list(); break; case \"find\": System.out.println(\"请输入要查找的id\"); int searchId = scanner.nextInt(); System.out.println(hashTable.findEmpById(searchId)); break; case \"delete\": System.out.println(\"输入要删除的id\"); int deleteId = scanner.nextInt(); System.out.println(hashTable.deleteEmpById(deleteId)); break; case \"exit\": scanner.close(); break; } } }}//表示一个雇员class Emp { public int id; public String name; public Emp next; //next默认为空 public Emp(int id, String name) { this.id = id; this.name = name; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; }}//创建一个EmpLinkedList，表示链表class EmpLinkedList { //头指针，指向第一个Emp,无头结点 private Emp head = null; //默认为空 //添加雇员到链表 //说明： //1.假定添加雇员的时候就是添加在最后（id自增长的） public void add(Emp emp) { //第一个雇员 if (head == null) { head = emp; } //不是第一个 else { Emp temp = head; while (temp.next != null) { temp = temp.next; } temp.next = emp; } } //遍历链表的雇员信息 public void list(int no) { if (head == null) { System.out.println(\"第\"+no+\"为空\"); return; } Emp temp = head; System.out.print(\"第\"+no+\"为 \"); while (temp != null) { System.out.print( \"=&gt;\" +temp); temp = temp.next; } System.out.println(); } /** * * @param id * @return 没找到返回空 */ public Emp findEmpById(int id) { if (head == null) { System.out.println(\"链表空\"); return null; } Emp temp = head; while (temp != null) { if (temp.id == id) { return temp; } temp = temp.next; } return null; } /** * 根据id删除雇员 * @return 删除成功返回1 未找到返回-1 */ public int delete(int id) { //删除需要前一个节点 //删除的是第一个节点 if (head.id == id) { head = null; return 1; } //删除的不是第一个节点 Emp temp = head; boolean flag = false;//是否找到 while (temp.next != null) { if (temp.next.id == id) { flag = true; break; } } if (flag) { temp.next = temp.next.next; return 1; }else{ return 0; } }}//创建一个HashTable,表示哈希表，管理多条链表class HashTable { private EmpLinkedList[] empLinkedListArray; private int size; //表示有多少条链表 public HashTable(int size) { //初始化数组 empLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; empLinkedListArray.length; i++) { empLinkedListArray[i] = new EmpLinkedList(); } this.size = size; //?? 有坑！！！！ //不要忘了分别初始化每一条链表 } //添加雇员 public void add(Emp emp) { //根据员工的id，得到该员工应该添加到哪条链表 int empLinkedListNo = hashFun(emp.id); //将Emp加入到对应的链表中 empLinkedListArray[empLinkedListNo].add(emp); } //遍历所有的链表 public void list() { for (int i = 0; i &lt; empLinkedListArray.length; i++) { empLinkedListArray[i].list(i); } } //编写一个散列函数，使用简单的取模法 public int hashFun(int id) { return id % size; } //根据id 查找雇员 /** * * @param id * @return 没找到返回空 */ public Emp findEmpById(int id) { //使用散列函数确定到哪条链表查找 int empLinkedListNo = hashFun(id); return empLinkedListArray[empLinkedListNo].findEmpById(id); } public int deleteEmpById(int id) { int empLinkedListNo = hashFun(id); return empLinkedListArray[empLinkedListNo].delete(id); }}","link":"/posts/850f2080/"},{"title":"又晚睡，某个周六的夜晚","text":"坚持早睡早起是快乐的，早上没有课，熬夜也是快乐的，究竟什么是虚拟，虚无，找不到答案，刚看到一点光，就想回到舒适的洞穴，没有声音督促我一直走，往回拉的倒是有不少，凡事应当适可而止，如同滑雪技巧，能停下来，才不会受伤或丧命。 高中时喜欢诸葛亮的诫子书，不如复制来看看 夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 那时候感触最深的，就是 年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 转眼都快到了遂成枯落的时候了，如果让我再来一次呢，可能不再像高三毕业那样洒洒脱脱不后悔了，成长，和自己赛跑的人 后天面基水友了，67373到底是怎样的一个存在呢在我的世界里，是要认真想想 晚安💤晚安💤","link":"/posts/881dc311/"},{"title":"三.内存","text":"摘要： 内存基础知识 基本分页存储 基本分段存储 虚拟内存 - 页面置换算法 内存3.1_1 内存的基础知识（1）什么是内存？有何作用内存是用于存放数据的硬件。程序在执行前需要先放到内存中才能被CPU处理 思考：在多道处理环境下，系统中会有多个程序并发执行，也就是会有多个程序的数据需要存放到内存中，那么如何区分各个程序的数据是放在什么地方的呢？ 补充知识：几个常用的数量单位一台手机/电脑有4GB的内存，是什么意思？ 是指该内存中可以存放4 * 2^30 个字节，如果是按字节址的话，也就是有 2^32个“小房间” 2^10 = 1k 2^10 = 1M 2^30 = 1G 有些题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即需要多少个二进制位才能表示对应数目的存储单元） （2）逻辑地址 VS 物理地址编译时产生的指令只关心“相对地址”，实际放入内存中再想办法根据起始位置得到“绝对地址” （3）写程序到程序运行编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数一起，形成一个完整的装入模块（可执行文件） 装入（装载）：由装入程序将装入模块放入内存运行 （4）装入的三种方式（三种完成逻辑地址到物理地址的转换）1.绝对定位 绝对装入，在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模板中的地址，将程序装入内存。 绝对装入只使用与单道批处理系统，程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编的时候转换为绝对地址 2.静态重定位 静态重定位:又称可重定位装入。编译、链接后的装入模块的地址都是从o开始的，指令中使用的地 址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入 到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入 时一次完成的） 静态重定位的特点时作业在装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能移动，也不能申请内存空间 3.动态重定位 动态重定位:又称动态运行时装入。编译、链接后的装入模块的地址都是从o开始的。装入程序把装 入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。 采用动态重定位时允许程序在内存中发生移动 并且可将程序分配到不连续的存储区中;在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态中请分配内存;便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。 （5）链接的三种方式1.静态链接 在程序运行之前，先将各目标模块及它们所需要的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开 2.装入时动态链接 将各目标模块装入内存时，边装入边链接的链接方式 3.运行时动态链接 在程序执行中需要改目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享 3.1_2 内存管理的概念 操作系统负责内存空间的分配与回收 操作系统需要提供某种技术从逻辑上对内存空间进程扩充 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换 地址转换的三种方式 1.绝对装入 编辑器负责地址转换(早期的单道批处理系统，那时还没有操作系统) 2.可重定位装入 装入程序负责地址转换（早期多道批处理系统） 3.动态运行时装入 运行时才进行地址转换（现代操作系统） 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰 内存保护的两种方法 方法1：在cpu中设置一对上，下限寄存器，存放进程的上，下限地址，进程的指令要访问某个地址时，cpu检查是否越界 方法2：采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定向寄存器存放的是进程的起始物理地址，界地址寄存器存放的是进程的最大逻辑地址 3.1_3 覆盖与交换（1）覆盖技术早期的计算机内存很少，比如IBM推出的第一台PC机最大只支持1mb大小的内存，常常出现内存不够的情况 覆盖技术的思想:将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存 缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖，对用户不透明，增加了编程的负担。覆盖技术只用一早期的操作系统中，现在已经成为历史 （2）交换技术交换（对换）技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度） 中级调度（内存调度），就是要决定将哪个处于挂机状态的进程准备调入内存 暂时换出外存等待的进程状态称为挂起状态（挂起态） 挂起态又可以进一步的分为就绪挂起和阻塞挂起两种状态 思考？ 1.应该在外存（磁盘）的什么位置保存被换出的进程？ 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件 区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采 用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放 在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理 主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节 后即可理解）。总之，对换区的I/o速度比文件区的更快。 2.什么时候应该进行交换 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在 发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程; 如果缺页率明显下降，就可以暂停换出。 3.应该换出哪些进程 可优先换出阻塞进程，优先级低的进程；为了防止低优先级的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间（注意：PCB会常驻内存，不会被换出内存） 3.1_4 连续分配管理方式连续分配：指为用户进程分配的必须是一个连续的内存空间 （1）单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统 相关数据;用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户独占整个用户区的空间 优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（早期的PC操作系统MS-DOS）。 缺点：只能用于单用户，单任务的操作系统；有内部碎片（分配给某内存区域，没有用上的部分就是内部碎片）；存储利用率低。 （2）固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。 分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如:钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序） 分区大小不等:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如:划分多个小分区、适量中等分区、少量大分区） 操作系统需要建立一个数据结构―一分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配） 优点：实现简单，无外部碎片。 缺点：a.当用户程序太大时，可能所有分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会减低性能 b.会产生内部碎片，内存利用率低 （3）动态分区分配动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB…) 1.系统要用什么样的数据结构记录内存的使用情况 ​ 1.空闲分区表 ​ 2.空闲分区链（双向链表） 2.当很多个空闲分区都满足需求时，应该分配哪个 把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分 区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算 法对系统性能有很大的影响，因此人们对它进行了广泛的研究。 3.如何进行分区的分配和回收操作 相邻的空闲区间需要合并 动态分区分配没有内部碎片，但是有外部碎片。 内部碎片：分配给某进程的内存区域中，有些部分没有用上 外部碎片：是指内存中的某些空间分区由于太小而难以利用 可以通过紧凑（拼凑，Compaction）技术来解决外部碎片 3.1_5 动态分区分配算法动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？ （1）首次适应算法算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区 如何实现：空闲分区以地址递增的次序排列。每次分配内存时按顺序查找空闲分区表（空闲分区链），找到大小满足要求的第一个空闲分区 （2）最佳适应算法算法思想：由于动态分区是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多的留下大片的空闲区，有限选择更小的空闲区 如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。 缺点：每次都选用最小的分区进行分配，会留下越来越多，很小的难以利用的内存块，会产生很多的外部碎片 （3）最坏适应算法（最大适应算法）算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 缺点：没次都选用最大的分区进行分配，虽然可以让分配所留下的空闲区更大，更可用，但是这种分配方式会导致连续较大的空间被迅速用完。如果之后有“大进程”到达，就没有可以分配的内存空间了 （4）邻近适应算法算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。 如何实现:空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的天分区保留下来（最佳适应算法的优点） 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点) 3.1_6 基本分页存储管理的基本概念思考：连续分配方式的缺点 1.固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低 2.动态分区分配：会产生很多外部碎片，虽然可以使用“紧凑”技术来处理，但是“紧凑”的时间代价很高 基于这一思想，产生了“非连续分配方式”，或称为“离散分配方式” 非连续分配：为用户进程分配的可以是一些分散的内存空间 （1）分页存储管理的基本概念将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”气、“页帧号”、“物理块号”）页框号从o开始。 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”页号也是从o开始。 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一—对应的关系。 思考：如何实现地址的转换 1.计算逻辑地址对应的页号 ​ 页号 = 逻辑地址/页面长度（取整数部分） 2.要知道页号对应的页面在内存中的起始地址 ​ 操作系统需要使用某种数据结构记录进程各个界面的起始位置 3.要算出逻辑地址在页面内的“偏移量” ​ 页内偏移量 = 逻辑地址 % 页面长度（取余数） 4.物理地址= 页面地址 + 页内偏移量 （2）逻辑地址结构假设用32个二进制位表示逻辑地址，页面大小为2^12 = 4096b = 4 kb 地址结构包换两个部分：前一部分为页号，后一部分为页内偏移量。如地址长度为32位，其中0-11为“页内偏移量”；12-31位为“页号” 结论:如果每个页面大小为2^kB，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号 页表为了知道进程的每个页面在内存中存放的位置，操作系统要为每一个进程建立一张页表 1.一个进程对应一张页表 2.进程的每一页对应一个页表项 3.每个页表项由“页号”和“块号”组成 4.页表记录进程页面和实际存放的内存块之间的对应关系 5.每个页表项的长度是相同的，页号是“隐含”的 3.1_7 基本地址变换机构（1）基本地址变换机构基本地址变换机构可以借助进程的页表将逻辑地址转为物理地址 通常会在系统内设置一个页表寄存器（PTR）,存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的初始地址和页表长度放在进程控制块（PCB）中，当进程被调度后，操作系统内核把它们放到页表寄存器中 根据逻辑地址计算出页号和页内偏移量 判断页号是否越界 查询页表，找到页号对应的页表项，确定页面存放的内存块号 用内存块号和页内偏移量得到物理地址 访问目标内存单元 注意：页面的大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下 计算页号P和页内偏移量W 比较页号P和页表长度M，如果P&gt;=M，则发送越界中断 页表中页号P对应的页表项地址 = 页表项的初始地址 + 页号P * 页表项长度，取出该页表项内容b,就是内存块号 计算 E = b * L + W,得到物理地址E访问（计算机内存块号，页面偏移量用二进制表示拼接） 例：若页面大小L为1k字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E 等价描述：系统按字节寻址，逻辑地址结构中，偏移量占10位 页号P = 2500/1024 = 2 页内偏移量 = 2500 % 1024 = 452 页号2对应的内存块号b=8 E = 8 * 1024 + 425 = 8644 在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了，因此，页式管理中地址是一维的，即：只要给出了一个逻辑地址，系统就可以自动的算出页号，页内偏移量两个部分，并不需要显式的告诉系统的逻辑地址中，页内偏移量占多少位 （2）对页表项大小进行进一步探讨 3.1_8 具有快表的地址变换机构（1）局部性原理时间局部性：如果只选了程序中的某条指令，那么不就后这条指令有可能再次执行；如果某个数据被访问过，不久之后数据很可能再次被访问。（因为程序中存在大量循环） 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中是连续存储的） 上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢? （2）什么是快表（TLB）快表，又称联想寄存器（TLB）,是一种访问速度比内存快很多的高速缓冲器，用来存放当前访问的若干表项，以加速地址变换的过程。于此对应，内存中的页表常称为慢表 （3）引入快表后，地址的变换过程 3.1_9 两级页表（1）单级页表存在的问题问题1：页表需要连续的存放，因此当页表很大时，需要占用很多个连续的页框 ​ 可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小为4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散的 放到各个内存块中） ​ 另外，要为离散分配的页表再建立一张页表，称为“页目录表”，或称外层页表，顶层页表 问题2：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的界面 ​ 可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项增加一个标志位，用于表示该界面是否已经调入内存 （2）如何实现地址变换两级页表结构的逻辑地址结构分为三部分 一级页号 + 二级页号 + 页内偏移量 （3）需要注意的几个细节1.采用多级页表机制，则各级页表的大小不能超过一个页面 例：某系统按照字节寻址，采用40为逻辑地址，页面大小为4KB,页表项大小为4B，假设采用纯页式存储，则需要采用多少级页表，页内偏移量为多少位 页面大小 4KB = 2 ^ 12 B -&gt; 页内偏移量为12位 -&gt; 页号 28位 页面大小 2 ^ 12 B , 页表项大小 4B - &gt; 每个页面可以存放 1024（2^10）个页表项 因此各级页表最多包含2^10个页表项，需要10位二进制才能表示2^10个页表项，每一级对应页号为10位 需要三级页表 2.两级页表的访问次数分析（假设没有快表） 第一次：页目录表 第二次：二级页表 第三次：目标内存单元 3.1_10 基本分段存储管理方式（1）分段进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址 内存分配规则：以段位单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻 分段系统的逻辑地址由段号（段名）和段内地址（段内偏移量）所组成 段号的位数决定了每个进程可以分为几个段 段内地址位数决定了每个段的最大长度是多少 （2）段表为了保证程序的正常运行，必须能从物理内存中找到各个逻辑的存放位置。为此，需要为每个进程建立一张段映射表，简称“段表” 1.每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度 2.各个段表项的长度是相同的，因此段号可以是隐含的，不占存储空间（类似页表中的页号） （3）地址变换 （4）分段，分页管理的对比页是信息的物理单位。分页的目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 段是信息的逻辑单位。分段的目的是为了更好的满足用户的需求。一个段通常包含着一组逻辑模块的信息。分段对用户是可见的，用户编程时需要显式的给出段名 页的大小固定且由系统决定，段的长度不固定，决定于用户编写的程序 分页用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址 分段用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址 分段比分页更容易实现信息的共享和保护（页面不是按逻辑模块划分的，很难实现共享） 不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发的访问可能造成数据不一致） 访问一个逻辑地址需要几次访存 也可以使用快表机制，减少内存的访问次数 3.1_11 段页式管理方式（1）分页，分段的优缺点分析分页管理： 优点：内存利用率高，不会产生外部碎片，只会有少量的内部碎片 缺点：不方便按照逻辑模块实现信息的共享和保护 分段管理： 优点：很方便的按照逻辑模块实现信息的共享和保护 缺点:如果段长太大，为其分配连续空间会很不方便，此外，段式管理会产生外部碎片（可以使用“紧凑”来解决） （2）分页 + 分段 = 段页式管理 （3）段页式管理的逻辑地址结构段页式系统的逻辑地址由段号，页号，（页内）页内偏移量组成 段号的位数决定了每个进程最多可以分为几个段 页号决定了每个段最多有几个页 页内偏移量决定了页面大小/内存块大小 （4）段表，页表 (5) 地址转换 3.2_1 虚拟内存的基本概念（1）传统存储管理方式的特征，缺点特征 一次性：作业必须一次性全部装入内存后才能开始运行，这会造成两个问题：1.作业很大时，不能全部装入内存，导致大作业无法运行；2.当大量的作业要求运行时，由于内存无法容纳所有的作业，因此只有少量作业可以运行，导致多道程序并发度下降 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分资源既可以正常运行，这就导致内存中会驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源 （2）局部性原理时间局部性：如果只选了程序中的某条指令，那么不就后这条指令有可能再次执行；如果某个数据被访问过，不久之后数据很可能再次被访问。（因为程序中存在大量循环） 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中是连续存储的，并且程序中的指令在内存中也是连续存放的） 高速缓冲技术的思想：把近期会频繁访问的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中 计算机中存储器的层级结构 寄存器–高速缓冲–内存–外存（磁盘，磁带） （3）虚拟内存的定义和特征基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。 在程序执行的过程中，当访问的信息不在内存时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出外存。 在操作系统的管理下，在用户看起来似乎有一个比实际内存大的多的内存，这就是虚拟内存 易混知识点： 虚拟内存的最大容量 = 计算机的地址结构（cpu的寻址范围）确定的 虚拟内存的实际容量 = min (内存和外存的容量之和，cpu的寻址范围) 虚拟内存有三个主要特征： 1.多次性：无需再作业运行时一次性装入内存，而是允许被分多次调入内存 2.对换性：在作业运行时无需一直常驻内存，而是允许在作业运行的过程中，将作业换入，换出 3.虚拟性从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量 （4）如何实现虚拟内存技术虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会很不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上 3.2_2 请求分页管理方式（1）页表机制 （2）缺页中断机构缺页中断是因为当前执行的指令想要访问的目标界面未调入内存而产生的，属于内中断 一条指令在执行期间，可能产生多次缺页中断。（如:copa A to B ,即将逻辑地址A中的数据复制到逻辑地址B，而A，B属于不同的页面，则有可能产生两次中断） （3）地址变换机构新增步骤1：请求调页（查到页表项时进行判断） 新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行） 新增步骤3：需要修改请求页表中新增的表项 3.2_3 页面置换算法（1）最佳置换算法（OPT）最佳置换算法（OPT,Optimal）：每次选择淘汰的界面将是以后不再使用，或者在最长时间内不再被访问的界面，这样可以保证最低的缺页率。 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到哪个界面。操作系统无法提前预判到页面的访问序列，因此，最佳置换算法是无法实现的 （2）先进先出置换算法（FIFO）先进先出置换算法（FIFO）:每次淘汰的页面是最早进入内存的界面 实现方法：那调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择对头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块 Belady 异常 – 当为进程分配的物理块数增大时，缺页次数不增反减的异常现象 只有FIFO算法会产生Belady(贝拉迪)异常，此外，FIFO算法虽然实现简单，但是与算法实际运行时的规律不适应，因为先进入的页面也有可能被经常的访问。因此，算法性能很差 （3）最近最久未使用算法（LRU）最近最久未使用算法（LRU,least recently used）:每次淘汰的页面是最近最久未使用的页面 实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面上次被访问以来经历的时间t。当需要淘汰一个页面时选择现有页面中t值最大的，即最近最久未使用的页面 该算法的实现需要专门的硬件支持，虽然算法性能好（最接近最佳置换算法），但是实现困难，开销大 （4）时钟置换算法（CLOCK）时钟置换算法（CLOCK）是一种性能和开销较均衡的算法，又称最近未用算法 简单的CLOCK算法实现方法：为每一个页面设置一个访问位，再将内存中的页面通过链接指针成一个循环队列。当某页被访问时，其访问位置为1.当需要淘汰一个页面时，只需要检查页的访问位。如果是0就将该页换出；如果是1，则将它置位0，暂不换出，继续检查下一个页面，若第一轮扫描周中所有的页面都是1，则将这些页面的访问依次置位0后，再进行第二轮扫描（第二轮扫描一定会有访问位为0的页面，因此简单的clock算法选择淘汰一个页面最多会进过两轮扫描） （5）改进型的时钟置换算法简单的时钟算法仅考虑到一个页面有没有被访问过，事实上，如果淘汰的页面没有被修改过，就不需要执行I/0操作写回外存。只有被淘汰的页面被修稿改过时，才需要写回外存。 因此，除了考虑一个页面最近有没有被访问之外，操作系统还应该考虑页面有没有修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型时钟置换算法的思想。 修改位 = 1 页面被修改过 修改位 = 0 页面没有被修改过 算法规则：将所有可能被置换的页面排成一个循环队列 第一轮:从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位 第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0,0）的帧用于替换。本轮扫描不修改任何标志位 第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。 由于第二轮已将所有帧的访问位设为o，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。 3.2_4 页面分配策略（1）页面分配，置换策略驻留集：指请求分页存储管理中给进程分配的物理块的集合。 在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小 驻留集太小：导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少 驻留集太大：会导致多道程序的并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小 固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，即，驻留集大小不变 可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即，驻留集大小可变 局部置换：发送缺页时只能选择进程自己的物理块进行置换 全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程 （2）何时调入页面1.预调页策略：根据局部性原理，一次调入若干相邻的界面可能比一次调入一个页面更高效。但如果提前调入中的页面大多数都没被访问，则又是低效的。因此可以预测不久之后就可能访问到的页面，将它们预先调入内存，但目前成功率只有50%左右。所以这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分 2.请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但是由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销很大 （3）从何处调入页面1.系统拥有足够的对换区空间；页面的调入，调出都是在内存与对换区之间进行的。这样可以保证页面的调入，调出速度很快。在进程运行前，需要将进程相关的数据从文件区复制到对换区 2.系统确实足够的对换空间时：凡是不会被修改的数据都直接从文件区调入，由于这些界面不会被修改，因此换出时不用写入磁盘，下次需要时直接再从文件区调出即可。对于可能被修改的部分，换出时需要写回磁盘对换区，下次需要时从对换区调入 3.unix方式：运行之前进程有关的数据全部放在文件区，因此未使用过的界面，都可以从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时再从对换区调入 （4）抖动（颠簸）现象刚刚换入的界面马上又要换出内存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原始是进程频繁访问的页面属数目高于可用的物理块数（分配给进程的物理块数不够） 物理块太少会发生抖动现象，物理块太多又会降低系统整体的并发度，降低吗，某些资源的利用率 为了研究应该为每个进程分配多少物理块，Denning提出了工作集的概念 （5）工作集工作集：指在某段时间间隔内，进程实际访问页面的集合 驻留集：指请求分页存储管理中给进程分配的物理块的集合。 操作系统会根据“窗口尺寸”来算出工作集 工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小 给进程分配若干内存块。如:窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么 说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。 一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。","link":"/posts/1535395b/"},{"title":"四、springboot web开发","text":"摘要： springboot web开发 1、简介使用springboot； 创建springboot应用，选中需要的模块 springboot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 自己编写业务代码 自动配置原理？ 这个场景springboot帮我们配置了什么？能不能修改？能修改哪些配置？拓展…. 12xxxAutoConfiguration 帮我们给容器中自动配置组件xxxProporties 配置类来封装配置文件的内容 2、springboot对静态资源的映射规则123456@ConfigurationProperties( prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties { //可以设置和资源有关的参数，缓存时间等 WebMvcAutoConfiguration 部分代码： 1234567891011121314151617181920212223242526public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } }}//配置欢迎页映射@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations()); return welcomePageHandlerMapping;} )1、所有/webjars/**，都去classpath:/META-INF/resources/webjars/找资源； webjars：以jar包的方式引入静态资源 https://www.webjars.org/ 访问jQuery ：localhost/webjars/jquery3.5.1/jquery.js 123456&lt;!--jquery webjar--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; )2、”/**“ 访问当前项目的任何资源（静态资源的文件夹） 1234&quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; localhost/abc 去静态资源文件下找abc )3、欢迎页；静态资源文件夹下的index.html页面，被“/**”映射 localhost 找index.html 3、模板引擎JSP,Velocity,Freemarker,… springboot 推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf12345&lt;!--模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 新版本springboot无需修改thymeleaf版本 2、Thymeleaf使用&amp;语法123456789public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; 1、导入thymeleaf名称空间 1&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2、thymeleaf语法 1234&lt;!--th:text将div里的文本内容设置为指定的值--&gt;&lt;div th:text=&quot;${hello}&quot;&gt; 这是显示欢迎界面&lt;/div&gt; 3、语法规则1、th:text;改变当前元素里面的文本内容 ​ th：任意html属性；来替换原生属性的值 2、表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Simple expressions: Variable Expressions: ${...} 获取变量值；OGNL; 1、获取对象的属性、调用方法 2、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3.内置的工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...} 选择表达式 和${} 在功能上是一样的 补充：配合 th:object 使用 Message Expressions: #{...} 获取国际化内容 Link URL Expressions: @{...} 帮我们定义url链接 Fragment Expressions: ~{...} 片段引用表达式Literals Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations: String concatenation: + Literal substitutions: The name is ${name} Arithmetic operations: Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations: Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality: Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators: If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、springMVC自动配置1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:WebMvcAutoConfiguration Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件} ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； \\==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、拓展SpringMvc1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一和配置类（@Configuration）,是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc 既保留了所有的自动配置，也可以使用我们拓展的配置 123456789@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //浏览器发送cyfwlp请求也到success registry.addViewController(\"/cyfwlp\").setViewName(\"success\"); }} 原理 ​ 1、WebMvcAutoConfiguration 是 springboot的自动配置类 ​ 源码变了，暂时不看 3、全面接管springMVCspringboot对springboot的自动配置都不需要了，所有都是我们自己配置 只需要在配置类中添加@EnableWebMvc 5、如何修改springboot的默认配置模式： springboot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@bean @Componentttttttttttttttttt）如果有就使用用户配置的，如果没有就自动配置；如果这些组件可以有多个，将用户配置的和自己的组合起来（ViewResolver） 在springboot中会有非常多的xxxConfigurer帮助我们进行拓展配置 xxxCustomizer帮助我们进行定制配置 6、RestulCRUD1）、默认访问首页2）、国际化3）、登录4）、拦截器进行登录检查5）、CRUD—员工列表实验要求： 1）、RestululCRUD：CRUD满足Resu风格 URI:/资源名称/资源标识 HTTP请求方式区分对资源crud操作 普通crud(uri来区分操作) RestululCRUD 查询 getEmp emp — GET 添加 addEmp?xxxxxxx emp — POST 修改 updateEmp?xxxxxx emp/{id} — PUT 删除 deleteEmp?xxxxx emp/{id} — DELETE 2）、实验的请求架构 请求URI 请求方式 查询所有员工 emps GET 查询某个员工 emp/{id} GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面 emp/{id} GET 修改员工 emp PUT 删除员工 emp/{id} DELETE 3）、员工列表 thymeleaf公共页面元素抽取 123456789101、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~{footer :: copy}&quot;&gt;&lt;/div&gt;~{templatename::selector} ：模板名::选择器~{templatename::fragmentname}：模板名::片段名3、默认效果insert的功能片段在div标签中 三种引入公共片段的th属性 th:insert：将公共片段整个插入到指定元素中 th:replace：将声明引入的元素替换为公共部分 th:include：将被引入片段的内容包含进这个标签 123456789101112131415161718192021222324252627&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;body&gt;...&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;/body&gt;…will result in:&lt;body&gt;...&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;&lt;/body&gt; 提交的数据格式不对；生日；日期； 默认日期是按照/的方式； 7、错误处理机制1、springboot默认的错误处理机制默认效果： ​ 1.返回一个错误界面 2.如果其他客户端访问，默认响应json数据 原理： ​ 可以参照：ErrorMvcAutoConfiguration ；错误处理的自动配置； ​ 给容器中添加了以下组件： ​ 1、DefaultErrorAttributes ： ​ 2、BasicErrorController ： 处理/error请求 123456789101112131415161718192021222324252627@Controller@RequestMapping({\"${server.error.path:${error.path:/error}}\"})public class BasicErrorController extends AbstractErrorController { @RequestMapping( //产生html，浏览器发送的请求到这个方法处理 produces = {\"text/html\"} ) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = this.getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个界面作为错误界面方法 ModelAndView modelAndView = this.resolveErrorView(request, response, status, model); return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model); } @RequestMapping //产生json 其他客户端出现的错误到这个方法处理 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { HttpStatus status = this.getStatus(request); if (status == HttpStatus.NO_CONTENT) { return new ResponseEntity(status); } else { Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL)); return new ResponseEntity(body, status); } }} 3、ErrorPageCustomizer ： 12@Value(\"${error.path:/error}\")private String path = \"/error\";//系统出现错误以后来到error请求进行处理；（web.xml注册的错误界面） 4、DefaultErrorViewResolver ： 123456789101112131415161718public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model); } return modelAndView;}private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认springboot可以找到一个页面？error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个视图就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); //模板引擎可用就返回到errorViewName指定的视图地址 //模板引擎不可用，就在静态文件夹下找到errorViewName对应的页面 error/404 return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);} 步骤： ​ 一旦系统出现4xx或5xx之类的错误，ErrorPageCustomizer就会生效（定制错误的响应规则） ​ 就会被BasicErrorController处理 ​ 1.响应页面：去哪个界面是由DefaultErrorViewResolver解析得到的 1234567891011121314protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) { Iterator var5 = this.errorViewResolvers.iterator(); ModelAndView modelAndView; do { if (!var5.hasNext()) { return null; } ErrorViewResolver resolver = (ErrorViewResolver)var5.next(); modelAndView = resolver.resolveErrorView(request, status, model); } while(modelAndView == null); return modelAndView; } 2、如何定制错误响应： 1、如何定制错误的界面 ​ 1、有模板引擎的情况下；error/状态码 将错误界面命名为 错误状态码.html 放在模板引擎文件夹下面的error文件夹下，发送次状态错误就会来到对应的错误界面；可以使用4xx 和 5XX 作为错误界面的文件名来匹配所有错误，优先寻找精确的界面 ​ 2、没有模板引擎（模板引擎找不到这个错误），默认在静态资源文件夹下找 ； ​ 3、模板引擎和静态资源文件夹下都没有，来到springboot默认的错误提示界面 ​ 2、如何定制错误的json数据 ​ 跳了，用的时候再回来看 8、配置嵌入式Servlet容器1、如何定制和修改Servlet容器相关配置springboot默认使用的是嵌入式的Servlet容器（Tomcat） 问题？ 1、如何定制和修改servlet容器的相关配置 ​ 修改和server有关的配置(ServerProperties)； 12345678server.port=80server.servlet.context-path=/crudserver.tomcat.uri-encoding=utf-8//通用的Servlet容器配置server.xxx//Tomcat配置server.tomcat.xxx 2、springboot能不能支持其他的Servlet容器 2、注册Servlet三大组件【Servlet,Filter,Listener】由于springboot默认是jar包的方式启动嵌入式的tomcat，没有web.xml配置文件，所以注册组件使用 以下方式 ServletRegistrationBean FilterRegistrationBean ListenerRegistrationBean 1234567891011@Configurationpublic class MyServerConfig { @Bean //注册三大组件 public ServletRegistrationBean myServlet() { ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new MyServlet(), \"/myServlet\"); return servletRegistrationBean; }} springboot 配置 springMVC的时候，自动注册了前端控制器（DispacherServlet）","link":"/posts/54b47222/"},{"title":"五.I/O设备","text":"摘要： I/O设备 五.设备管理5.1_1 I/O设备的基本概念和分类（1）什么是I/O设备“I/o”就是“输入/输出”(Input/Output） I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的 硬件部件。 Unix系统将外部设备抽象为一种特殊的文件。用户可以使用与文件操作相同的方式对外部设备进行操作 （2）I/O设备的分类——按使用特性分类 （3）I/O设备的分类——按传输速率分类 （3）I/O设备的分类——按信息交换的单位分类 5.1_2 I/O控制器I/O设备的机械部件主要是用来执行具体的I/O操作，如我们看得见摸得着的鼠标/键盘的按钮…. I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板 （1）I/O设备的电子部件（I/O控制器）CPU无法直接控制I/o设备的机械部件，因此I/o设备还要有一个电子部件作为CPU和I/o设备机械部 件之间的“中介”，用于实现CPU对设备的控制。 这个电子部件就是I/o控制器，又称设备控制器。CPU可控制I/o控制器，又由I/o控制器来控制设备 的机械部件。 （2）I/O控制器的组成 （3）内存映像I/O 寄存器独立编址内存映射I/O，控制器中的寄存器与内存地址统一编址 寄存器独立编址，控制器中的的寄存器使用单独的地址 5.1_3 I/O控制方式需要注意的问题： 完成一次读写操作的流程 cpu干预的频率 数据传送的单位 数据的流向 主要缺点和优点 （1）程序直接控制方式keyword : 轮询 ① 完成一次读/写的流程 ② cpu干预的频率： cpu需要不断的轮询检查，干预频率很频繁 ③ 数据的传送单位：每次读/写一个字 ④ 数据流向： 读：I/O设备 - cpu - 内存 写：内存 - cpu - I/O设备 ⑤ 主要的缺点和优点 优点：实现简单 缺点：CPU和I/O设备只能串行工作。cpu需要一直轮询检查，长期处于忙等状态，cpu利用率低 （2）中断驱动方式 ① 完成一次读/写的流程 除了引入中断和程序控制方式大同小异 ② cpu干预的频率： 每次I/O操作开始前，完成后需要cpu介入 等待I/O时cpu可以切换到别的进程执行 ③ 数据的传送单位： 每次读/写一个字 ④ 数据流向： 读：I/O设备 - cpu - 内存 写：内存 - cpu - I/O设备 ⑤ 主要的缺点和优点 优点：引入了中断技术可以让cpu和I/O设备并行的工作，提高了cpu利用率 缺点：频繁的中断处理会消耗较多的cpu时间 （3）DMA（直接存储器存取）方式DMA也是一种I/O控制器 ① 完成一次读/写的流程 ② cpu干预的频率： 仅在传送了一个或多个数据块的开始或结束时，才需要CPU干预 ③ 数据的传送单位：每次读/写一个块或多个块（注意：多个块只能是连续的多个块，且这些块读入内存也必须是连续的） ④ 数据流向： 读：内存 - I/O设备 写：I/O设备 - 内存 ⑤ 主要的缺点和优点 优点：数据传输以“块”为单位，cpu介入频率进一步降低。传输的数据不再需要先经过cpu再写入内存，数据的传输效率提升，cpu和I/O设备的并行性提升 缺点：cpu每发出一条I/O指令，只能读/写一个或多个数据块 （4）通道控制方式通道：一种硬件，可以理解为“弱鸡版的cpu”。通道可以识别并执行一系列的通道指令 通道程序：任务清单 ① 完成一次读/写的流程 ② cpu干预的频率： 极低，通道会根据cpu的指示执行相应的通道查询 ③ 数据的传送单位：每次读/写一组数据块 ④ 数据流向： 读：内存 - I/O设备 写：I/O设备 - 内存 ⑤ 主要的缺点和优点 缺点：实现复杂，需要专门的通道硬件支持 优点：资源利用率极高 5.1_4 I/O软件层次结构（1）用户层软件用户层软件实现了与用户交互的接口，用户可以直接提供该层提供的，与I/O设备相关的库函数对设备进场操作 用户层软件将用户请求翻译成格式化的I/O请求，并通过系统调用请求操作系统内核服务 （2）设备独立性软件，（又称设备无关性软件）向上层实现统一的调用接口 对设备的保护（Unix操作系统设备看作文件，考虑权限问题） 差错处理 对设备的错误进行处理 设备的分配与回收 数据缓冲区管理 建立逻辑设备名到物理设备名的映射关系；根据设备类型调用相应的驱动程序 “逻辑设备表” （3）设备驱动程序 主要负责对硬件设备的具体控制，将上层发出的一系列指令命令转换成特定设备“听的懂”的一系列操作。包括设置设备寄存器；检查设备状态等 （4）中断处理程序 5.1_5 I/O核心子系统i/o核心子系统： 设备独立性软件 设备驱动程序 中断处理程序 (1) I/O调度用某种算法确定一个好的顺序来处理各个I/O请求 (2) 设备保护操作系统需要实现文件保护功能 Unix操作系统把设备看做文件，每个设备也会有对应的FCB 5.1_6 假脱机技术（SPOOLing技术）（1）什么是脱机技术批处理阶段引入了脱机输入/输出技术（用磁带完成） 脱机：脱离主机的控制 （2）假脱机技术“假脱机技术”又称SPOOLing技术是用软件的方式模拟脱机技术 输入进程模拟脱机输入时的外围控制机 输出进程模拟脱机输出时的外围控制机 缓冲区：数据的中转站 （3）共享打印机原理分析独占式设备：各进程串行的使用 共享设备：各进程同时的使用 打印机 通过 SPOOLing技术 改造为 共享设备 5.1_7 设备的分配与回收（1）设备分配时应该考虑的因素设备的固有属性：独占设备，共享设备，虚拟设备 独占设备：一个时段只能分配给一个进程 共享设备：可以分配给多个进程使用（如磁盘），共享往往是宏观上的 虚拟设备：通过SPOOLing技术将独占设备改为虚拟的共享设备 设备的分配算法： 先来先服务 短任务优先 … 进程运行的安全性 安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才能将进程唤醒 优点：破坏了“请求和保持”条件，不会死锁 缺点：对于一个进程来说，cpu和I/O设备只能串行的工作 不安全分配方式：进程发出I/O请求后，进程不会被阻塞。进程可以继续执行，之后还可以发出新的I/O请求 优点：效率高，进程的任务可以和I/O任务进行并行处理 缺点：不安全，可能导致死锁（死锁的检测与解除 银行家算法） （2）静态分配与动态分配静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源 动态分析：进程运行过程中动态的申请设备资源 （3）设备分配管理中的数据结构 设备控制表（DCT）用于记录设备的使用情况 控制器控制表（coct）每个设备控制器会对应一张COCT,对控制器进行管理 通道控制表（CHCT）操作系统对通道进行操作和管理 系统控制表（SDT）记录设备中全部设备的情况，每个设备对应一个表目 （4）设备分配的步骤 根据进程请求的物理设备名查找SDT（注:物理设备名是进程请求分配设备时提供的参数) 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。 根据DCT找到coCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程 只有设备，控制器，通道都分配成功时，才是I/O设备分配成功 缺点： 用户编程必须使用“物理设备名”，底层细节对用户不透明，不方便编程 若更换物理设备，程序无法运行 若进程请求的设备正在忙碌，则及时系统中还有同类型的设备，进程也必须阻塞等待 （5）设备分配步骤的改进 根据进程请求的逻辑设备名查找SDT 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。 同上面的步骤 …… 5.1_8 缓冲区管理（1）什么是缓冲区，有什么作用 （2）单缓冲假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。 注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。 （3）双缓冲操作系统在主内存分配两个缓冲区 (4) 使用单/双缓冲在通信时的区别 在任何一个时刻只能实现数据的单向传输 若使用双缓冲区可以实现同一时刻的双向数据传输 （5）循环缓冲区将多个大小相等的缓冲区链接成一个循环队列 （6）缓冲池缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。","link":"/posts/f9c0efcf/"},{"title":"排序算法","text":"摘要： 常见的排序算法 冒泡排序，选择排序，插入排序，希尔排序，快速排序，归并排序，基数排序 排序算法一.排序算法的介绍排序算法的分类 内部排序：指将需要处理的数据都加载到内部存储器中进行排序 外部排序:数据量过大，无法加载到内存中，需要借助外部存储器就行排序 常见的排序算法 插入排序 直接插入排序 希尔排序 选择排序 简单选择排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 基数排序 二.算法的时间复杂度度量一个算法执行的两种方法 事后统计法 这种方法可行，但是有两个问题，1.需要实际运行该程序；2.结果依赖于计算机的硬件，软件等环境因素这种方式只有在同一台计算机的相同状态下运行，才能比较那个算法的速度快 事前估算法 通过分析时间复杂度来判断哪个算法更加优秀 算法的时间复杂度时间频度时间频度:一个算法花费的时间与算法中语句的执行次数成正比例，一个算法中语句执行次数称为语句频度或时间频度，记为T(n) 忽略常数项，忽略低次项，忽略系数 时间复杂度一般情况下，算法中的基本操作语重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则成f(n)是T(n)的同数量级函数，记作T(n) = O(f(n)),称O(f(n))为算法的渐进时间复杂度，简称时间复杂度 时间复杂度的计算方法 用常数1代替运行时间中的所有加法常数 只保留最高阶项 去掉最高阶项前的系数 常见的时间复杂度 常数阶O(1) 对数阶O(log_2 n) 线性阶O(n) 线性对数阶O(nlog_2 N) 平方阶O(n^2) 立方阶O(n^3) k次方阶O(n^k) 指数阶O(2^n) (尽量避免使用指数阶) 举例： 1.常数阶O(1) 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1) 12345int i = 1;int j = 2;++i;j++;int m = i + j 上述代码在执行的时候，它的消耗并不随着某个变量的增长而增长，那么无论这类代码有多长，即时有几万几百万行，都可以用O(1)来表示它的时间复杂度 2.对数阶O(log_2 n) 1234int i = 1;while(i &lt; n){ i = i * 2} 初中数学：如果a的x次方等于N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数（logarithm），记作x=log_a N。其中，a叫做对数的底数，N叫做真数。 分析代码： 在while循环里，每次都将i乘以2，乘完之后，i距离n就越来越近了，假设循环x次后，i就大于等于2，此时跳出循环，也就是2^x=n ,x = log_2 n，循环log_2 n次后代码结束，代码的时间复杂度为log_2 n 3.线性阶O(n) 1234for(int i = 1;i&lt;=n;i++){ j = i; i++;} 这段代码，for循环里的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，这类代码可以用O(n)来表示时间复杂度 4.线性对数阶O(nlog_2 N) 123456for(int m = 1;m&lt;=n;m++){ i = 1; while(i &lt; n){ i = i * 2 }} 线性对数阶就是将时间复杂度为O(log_2 N)的代码循环执行n遍，那么它的时间复杂度就是n * log2_N,也就是O(nlog_2 N) 5.平方阶O(n^2) 12345for(int m = 1;m&lt;=n;m++){ for(int i= 1;i&lt;=n;i++){ ... }} 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间 最坏情况下的时间复杂度称为最坏时间复杂度，一般讨论的时间复杂度均是最坏时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长 平均时间复杂度和最坏时间复杂度与是否一致，和算法有关 二.算法的空间复杂度简介算法的空间复杂度简介 类似于时间复杂度的讨论，一个算法的空间复杂度定义为该算法所耗费的存储空间，它也是问题规模n的函数 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大,当n比较大时，将占用较多的存储单元，例如快速排序和归并排序就属于这种情况 在做算法分析，主要讨论的是时间复杂度，从用户体验上看，更看重的是程序的执行速度，一些缓存产品（redis和memcache）和算法（基数排序）本质就是利用空间换时间 三.冒泡排序基本介绍冒泡排序的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移到后部，像水底的气泡一样逐渐向上冒 冒泡排序的优化：因为在排序的过程中，各个元素不断接近自己的位置，如果一趟比较下来没有进行交换，就说明序列有序因此要在排序过程中设置一个标记flag判断元素是否进行过交换，减少不必要的比较 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 未优化的冒泡排序 * @param arr 排序的数组 */private static void bubbleSort(int[] arr){ int temp = 0;//交换变量 for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if(arr[j] &gt; arr[j+1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }}/** * 优化后的冒泡排序，不进行多余的比较 * @param arr 数组 */private static void bubbleSortPlus(int[] arr){ int temp = 0;//交换变量 boolean flag = false;//标识是否进行了交换 for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if(arr[j] &gt; arr[j+1]){ flag = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } if (!flag){ //已经完成了排序 break; }else{ flag = false; } }} 四.选择排序基本介绍选择排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依次交换位置后达到排序的目的 选择排序思想选择排序（select sorting）也是一种简单的排序方法，它的基本思想是：第一次从arr[0] - arr[n-1]中选择最小值，与arr[0]交换，第二次从arr[1] - arrp[n-1]选择最小值，与arr[1]交换，第三次从arr[2] - arr[n-1] 选择最小值，与arr[2]交换，第n-1次，arr[n-2]-arr[n-1]选择最小的值与arr[n-2]交换，得到一个有序的数列 代码实现12345678910111213141516private static void selectSort(int[] arr){ for (int i = 0; i &lt; arr.length - 1; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) { if (min &gt; arr[j]){ min = arr[j];//重置min minIndex = j;//重置minIndex } } if (minIndex != i){ arr[minIndex] = arr[i]; arr[i] = min; } }} 五.插入排序基本介绍插入排序属于内部排序法，是对于将要排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的 (打扑克？？) 算法思想插入排序(Inserting Sorting)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只含有一个元素，无序表中含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它与有序表中的元素依次比较，插入到合适的位置。使之成为新的有序表 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private static void insertSortStep(int[] arr){ //使用逐步推到的方式来讲解 //第一轮 //定义待插入的数 int insertVal = arr[1]; int insertIndex = 0; // //说明 // insertIndex &gt;= 0 保证插入位置不会越界 // insertVal &lt; arr[insertIndex] 没有找到插入位置，需要将arr[insertIndex]后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex --; } //当退出while循环时，此时已经找到插入位置 insertIndex + 1 arr[insertIndex + 1] = insertVal; System.out.println(\"第一轮插入后\" + Arrays.toString(arr)); //第二轮 //定义待插入的数 insertVal = arr[2]; insertIndex = 1; // //说明 // insertIndex &gt;= 0 保证插入位置不会越界 // insertVal &lt; arr[insertIndex] 没有找到插入位置，需要将arr[insertIndex]后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex --; } //当退出while循环时，此时已经找到插入位置 insertIndex + 1 arr[insertIndex + 1] = insertVal; System.out.println(\"第二轮插入后\" + Arrays.toString(arr)); //第三轮 //定义待插入的数 insertVal = arr[3]; insertIndex = 2; // //说明 // insertIndex &gt;= 0 保证插入位置不会越界 // insertVal &lt; arr[insertIndex] 没有找到插入位置，需要将arr[insertIndex]后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex --; } //当退出while循环时，此时已经找到插入位置 insertIndex + 1 arr[insertIndex + 1] = insertVal; System.out.println(\"第二轮插入后\" + Arrays.toString(arr));}private static void insertSort(int[] arr){ int insertVal = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) { //第一轮 //定义待插入的数 insertVal = arr[i]; insertIndex = i - 1; //说明 // insertIndex &gt;= 0 保证插入位置不会越界 // insertVal &lt; arr[insertIndex] 没有找到插入位置，需要将arr[insertIndex]后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex --; } //当退出while循环时，此时已经找到插入位置 insertIndex + 1 //判断是否需要复制 if (insertIndex + 1 != i){ arr[insertIndex + 1] = insertVal; } }} 六.希尔排序希尔排序法介绍希尔排序是希尔(Donakd Shell)于1959年提出的一种排序算法，希尔排序也是一种插入排序，它是简单插入排序改进之后的一个更高效版本，也称为缩小增量排序 算法思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的关键字越来越多，当增量减到1时整个数组恰好被分成一组 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static void selectSortStep(int arr[]){ //在推导的过程中发现规律，可以使用循环来解决 //逐步推导的方式 //算法 先简单 -&gt; 再复杂 把复杂的算法拆分为简单的问题 - &gt; 逐步解决 //第一轮 int minIndex = 0; int min = arr[0]; for (int j = 1; j &lt; arr.length; j++) { if (min &gt; arr[j]){ min = arr[j];//重置min minIndex = j;//重置minIndex } } //进行交换，将arr[0] 和 min 交换 if (minIndex != 0){ arr[minIndex] = arr[0]; arr[0] = min; } System.out.println(\"第一趟排序\" + Arrays.toString(arr)); //第二轮 minIndex = 1; min = arr[1]; for (int j = 2; j &lt; arr.length; j++) { if (min &gt; arr[j]){ min = arr[j];//重置min minIndex = j;//重置minIndex } } //进行交换，将arr[0] 和 min 交换 if (minIndex != 1){ arr[minIndex] = arr[1]; arr[1] = min; } System.out.println(\"第二趟排序\" + Arrays.toString(arr)); //第一轮 minIndex = 2; min = arr[2]; for (int j = 3; j &lt; arr.length; j++) { if (min &gt; arr[j]){ min = arr[j];//重置min minIndex = j;//重置minIndex } } //进行交换，将arr[0] 和 min 交换 if (minIndex != 2){ arr[minIndex] = arr[2]; arr[2] = min; } System.out.println(\"第三趟排序\" + Arrays.toString(arr));}private static void selectSort(int[] arr){ for (int i = 0; i &lt; arr.length - 1; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) { if (min &gt; arr[j]){ min = arr[j];//重置min minIndex = j;//重置minIndex } } if (minIndex != i){ arr[minIndex] = arr[i]; arr[i] = min; } }} 七.快速排序快速排序法简介快速排序(QuickSort)是对冒泡排序的一种改进，基本思想是：通过一趟排序将要排序的数据分隔成独立的两部分，其中一部分数据都比另外一部分的所有数据都小，然后再按此方法对这两部分数据进行快速排序，整个过程递归进行，直到整个数据变为有序数列 代码实现123456789101112131415161718192021222324252627public static void quickSort(int[] arr, int low, int high) { if (low &lt; high) { int pivot = Partition(arr,low,high); quickSort(arr,low,pivot - 1); quickSort(arr,pivot + 1,high); }}public static int Partition(int[] arr, int low, int high) { int pivot = arr[low]; int temp = 0; while (low &lt; high) { while(low &lt; high &amp;&amp; arr[low] &lt;= pivot) { low ++; } temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) { high --; } temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; } return low;} 八.归并排序归并排序简介归并排序(merge-sort) 是利用归并的思想实现的排序方法，该算法采用经典的分治（dive and conquer）策略（分治法将问题分为一些小的问题然后递归求解，而治的阶段将分的阶段得到的答案“修补”在一起） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static void mergeSort(int[] arr,int left, int right, int[] temp){ if (left &lt; right){ int mid = (left + right) / 2; //向左递归进行分解 mergeSort(arr,left,mid,temp); //向右递归分解 mergeSort(arr,mid + 1,right,temp); //合并 merge(arr,left,mid,right,temp); }}/** * * @param arr 原始数组 * @param left 左边索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 中转数组 *///合并方法public static void merge(int[] arr, int left, int mid, int right,int[] temp){ int i = left;//表示左边有序序列的初始索引 int j = mid + 1;//表示右边有序数列的初始索引 int t = 0;//指向temp数组的当前索引 //先把左右两边的数据按规则填充到temp,直到左右两边有一边全部处理完毕 while (i &lt;= mid &amp;&amp; j &lt;= right){ if (arr[i] &lt;= arr[j]){ //左边有序数列的当前元素小于等于右边有序数列的当前元素 temp[t] = arr[i]; t += 1; i += 1; } else { //反之将右边有序数列的当前元素拷贝到temp数组 temp[t] = arr[j]; t += 1; j += 1; } } //如果哪边有剩余，就把哪边填充到temp数组里 while (i &lt;= mid) { //左边有剩余，全部填充 temp[t] = arr[i]; t += 1; i += 1; } while (j &lt;= right) { temp[t] = arr[j]; t += 1; j += 1; } //将temp数组重新拷贝到arr //并不是每次都拷贝所有 t = 0; int tempLeft = left; //第一次合并 tempLeft = 0 ,right = 1 while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; } System.out.println(Arrays.toString(arr));} 基数排序基数排序（桶排序）的基本思想将所有待比较数值统一为同样的数位长度，数位较短的前面补零。然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成后，数列就变成一个有序数列 代码实现12345678910111213141516171819202122232425262728293031323334353637public static void radixSort(int[] arr) { //定义桶 int[][] bucket = new int[10][arr.length]; //定义一个数组表示每个桶中数字的个数 int[] bucketElementCounts = new int[10]; //计算最大数有几位 int max = arr[0]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } int maxlength = (max + \"\").length(); for (int i = 0, n = 1; i &lt; maxlength; i++, n *= 10) { //把数据放到桶里 for (int j = 0; j &lt; arr.length; j++) { //依次取的个位，十位...的数 int number = arr[j] / n % 10; //放到桶中 bucket[number][bucketElementCounts[number]] = arr[j]; bucketElementCounts[number] += 1; } //桶里取出数据填充到原数组 int index = 0; for (int k = 0; k &lt; bucket.length; k++) { if (bucketElementCounts[k] != 0) { for (int l = 0; l &lt; bucketElementCounts[k]; l++) { arr[index] = bucket[k][l]; index += 1; } } bucketElementCounts[k] = 0; } }} 基数排序总结1.基数排序是对传统桶排序的拓展，速度很快 2.基数排序是经典的空间换时间的方式，占用内存很大，当对海量的数据排序时，容易造成OutMemoeryError 3.基础排序是稳定排序 4.有负数的数组，我们不用基数排序来进行排序 排序算法总结","link":"/posts/735e5788/"},{"title":"四.文件与磁盘","text":"摘要： 文件与磁盘 四.文件与磁盘4.1_1 初识文件管理（1）文件属性文件：一组有意义的信息的集合 一个文件有哪些属性？ 文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件 标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只能是操作系统用于区分各个文件还能的一种内部名称 类型：指明文件的类型 位置：文件的存放路径（让用户使用），在外存中的地址（操作系统使用，对用户不可见） 大小：指明文件的大小 创建时间，上次修改时间，文件所有者信息 保护信息：对文件进行保护的访问控制信息 （2）文件内部的数据应该怎样组织起来 （3）文件之间应该怎样组织起来 （4）操作系统应该向上提供哪些功能？操作系统向上提供的几个最基本的功能 创建文件（create系统调用） 删除文件（delete系统调用） 读文件（read系统调用） 写文件（write系统调用） 打开文件（open系统调用） 关闭文件（close系统调用） （5）从上往下看，文件应该如何存放在外存 （6）其他需要由操作系统实现的文件管理功能文件共享：使多个用户可以共享的使用一个文件 文件保护：如何保证不同用户对文件有不同的访问权限 4.1_2 文件的逻辑结构（1）有结构文件按文件是否有结构分类，可以分为无结构文件，有结构文件两种。 无结构文件：文件内部的数据就是一系列二进制流或字符流组成，又称为“流式文件”。如windows操作系统中的.txt文件 有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录由若干个数据项组成;如数据库表文件。一般来说，每条记录有一个数据项可以作为关键字。根据各条记录的长度（占用的内存空间）是否相等，又可以分为定长记录和可变长记录两种。 （2）顺序文件顺序文件：文件中的记录一个接一个的顺序排列（逻辑上），记录可以是定长的或可变长得，各个记录在物理上可以顺序存储或者链式存储 顺序文件按照顺序与关键字是否有关又可以分为 串结构 记录之间的顺序与关键字无关 顺序结构 记录之间的顺序与关键字有关 一般来说，考试题目中所说的“顺序文件”指的都是顺序存储的顺序文件，缺点是增加/删除一个记录比较困难 随机存取的实现：可变长记录不能实现而定长记录可以实现 快速检索的实现：顺序结构可以实现（二分查找），串结构不能实现 （3）索引文件对于可变长记录的文件，要找到第i个记录，必须先顺序查找第i-1个记录，但是对于很多场景又必须使用可变长记录，如何解决这个问题？ （4）索引顺序文件每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件本身的内容大8倍，这样对存储空间的利用率很低 若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始开始顺序查找，需平均查找5000个记录 若采用索引顺序文件结构，可以把10000个记录分为100组，每组100个数据，先查找分组，需要平均查找50次，找到分组再查找目标文件，平均查找50次，平均次数减少为 50 + 50 = 100次 文件数目再多时可以采用多级索引顺序文件 4.1_3 文件目录（1）文件控制块(FCB) FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。最重要，最基本的还是文件名、文件存放的物理地址。 （2）目录结构–单级目录结构早期的操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项 （2）目录结构–两级目录结构早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD,Master File Dictory）和用户文件目录(UFD，User File Dictory) （3）目录结构–多级目录结构（树形目录结构） 当用户想访问某个文件，可以使用当前目录出发的“相对路径” 引入当前目录和相对路径后，减少了磁盘i/o此次数，提高系统的效率 树形目录结构可以方便的对文件进程分类，层次结构清晰，也能够有效的对文件进行管理和保护，但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构” （4）目录结构–无环图目录结构 （5）索引结点（FCB的改进） 存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改，此时有几个进程正在访问该文件等 4.1_4 文件的物理结构（文件分配方式 上）文件数据应该怎样存放在外存中？ （1）文件块，磁盘块类似于内存分页，磁盘中的存储单元也会被分成一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块，页面的大小相同 文件的逻辑地址空间也被分为一个一个的文件“块” 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式 （2）文件分配方式——连续分配连续分配方式要求每个文件在磁盘上占有一组连续的块 文件目录中记录存放的起始块号和长度（总共占用了几个块） 读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需的时间就越长 结论：连续分配的文件在顺序读/写时速度最快 缺点： 物理上采用连续分配的文件不方便拓展 存储空间利用率低，会产生难以利用的磁盘碎片 。可以利用紧凑来处理碎片，但是要耗费很大的时间代价 （3）文件分配方式——链接分配链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为显式链接和隐式链接两种 隐式链接 目录中记录了文件存放的起始块号和结束块号 采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。 优点：很方便拓展文件，不会有碎片，外存利用率高 缺点：只能顺序访问，不支持随机访问，查找效率低，指向下一个磁盘块的指针也要耗费少量的存储空间 显式链接 把用于链接各物理块的指针显示的存放在一张表中，即文件分配表 注意：一个磁盘仅设置一张FAT。开机时，将FAT存入内存，并且常驻内存。（物理块号字段隐含） 逻辑地址到物理地址的转换 优点：很方便拓展，不会有碎片问题，外存利用率高，支持随机访问。相比隐式链接来说，地址转换不需要访问磁盘，文件的访问效率更高 缺点：FAT表需要占用一定的内存空间 注意：考试题目中未声明显式/隐式的“链接分配”默认是隐式链接 4.1_5 文件的物理结构（文件分配方式 下）（1）文件分配管理——索引分配索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表—―建立逻辑页面到物理页之间 的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块. 索引分配可以支持随机访问，文件拓展也很容易实现（只需给文件分配一个空闲块，增加一个索引表项即可） 但是索引表需要占用一定的存储空间 （2）索引表太大的解决方案链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。 缺点：如果文件很大，会导致索引表很长，由于不能随机存取，导致查找效率低下 多层索引：建立多层索引（类似于多级页表）。使第一层的索引块指向第二层的索引块，还可以根据文件的大小建立第三层，第四层…. 缺点：对小文件的访问任然需要多次的I/O操作 混合索引：多种索引分配方式相结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表），还包含两级间接索引（指向两层索引表） 超级超级超级重要的考点： 要会根据多层索引，混合索引的结构计算出文件的最大长度（key:各级索引表最大不能超过一个块） 要能分析访问某个数据块所需要读磁盘的次数（key:FCB中会存有指向顶级索引块的指针，因此根据FCB可以读入顶级索引块，每次读入下一级的索引块都要进行一次磁盘操作，另外要注意题目条件——顶级索引块是否已经调入内存） 4.1_6 文件存储空间管理（1）存储空间的划分和初始化按照windows操作系统的时候，一个必经的步骤是——为磁盘分区（C：盘,D:盘,E:盘） 存储空间的划分：将物理磁盘划分成一个一个的文件卷（逻辑卷，逻辑盘） 目录区：主要存放文件目录信息（PCB）和磁盘存储空间管理的信息 文件区：存放文件数据 （2）存储空间管理——空闲表法适用于“连续分配方式” （3）存储空间管理——空闲链表法空闲盘块链适用于离散分配结构 空闲盘区链适用于离散/连续分配结构 （4）存储空间管理——位示图法连续/离散分配都适用 （5）成组链接法空闲表，空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能很大,uinx操作系统中采用了成组链接法对磁盘空闲块进行管理 文件卷的目录区专门有一个磁盘块作为“超级块”，当系统启动时将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致 4.1_7 文件的基本操作（1） 创建文件 （2）删除文件 （3）打开文件 （4）关闭文件 （5）读文件 （6）写文件 4.1_8 文件共享注意：多个用户共享同一个文件，意味着系统中只有一份文件（注意与复制的区别） （1）基于索引结点的共享方式（硬链接） （2）基于符号链的共享方式（软链接） 4.1_9 文件保护（1）口令保护为文件设置一个口令，用户请求访问该文件时必须提供”口令“（口令存储在FCB或索引节点中） 优点：保存口令的开销空间不多，验证口令的时间开销也很少 群点：正确口令存放在系统内部，不顾安全 （2）加密保护使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密 eg:异或加密 优单：保密性强，不需要在系统中存储密码 缺点：编码/译码或者说加密/解密要花费一定的时间 （3）访问控制在每个文件的FCB(或索引节点)增加一个访问控制表，该表记录了各个用户可以对文件执行哪些操作 精简的访问列表：一个系统的用户很多时，对用户进行分组 如：系统管理员，文件主，文件主的伙伴…… 优点：实现灵活，可以实现复杂的文件保护功能 4.1_10 文件系统的层级结构 例子辅助记忆：假设某用户请求删除“D/学生信息.xlsx”的最后100条记录 4.2_1 磁盘的结构（1）磁盘，磁道，扇区 （2）如何在磁盘中读/写数据需要把“磁头”移动到想要读/写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作 （3）盘面，柱面 磁盘的物理地址 （柱面号，盘面号，扇区号） （4）磁盘的分类按磁头是否可以移动：移动头磁盘，固定头磁盘 盘片是否可以更换：固定盘磁盘，可换盘磁盘 4.2_2 磁盘调度算法（1）一次磁盘读/写操作需要的时间寻找时间（寻道时间）T(s)：(s为下标，并非括号)在读/写数据前，将磁头移动到指定磁道所花的时间 ① 启动磁头臂需要的时间 假设耗时为 s ② 移动磁头也是需要时间的，假设磁头均匀移动，每跨过一个磁道耗时为m，总共需要跨越n条磁道 寻道时间 T(s) = s + m * n 延迟时间T(R)：通过旋转磁盘，使磁头定位到目标扇区所需的时间。设磁盘转速为r(单位：转/秒)则平均所需要的延迟时间 T(R) = (1/2) * (1/r) = 1/2r 传输时间T(t)：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此时读/写的字节数为b,每个磁道上的字节为N。则传输时间 T(t) = (1/r)*(b/n) = b/(rN) （2）先来先服务算法（FCFS）根据进程请求访问磁盘的先后顺序进行调度 （3）最短寻找时间优先（SSTF）SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但不能保证总的寻道时间最短（贪心算法思想，只选择眼前最优，但是总体未必最优） （4）扫描算法（SCAN）SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题， 可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移 动。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。 （5）LOOK 调度算法扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁 道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，如果在磁 头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK) （6）循环扫描算法（C-SCAN）SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有 磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请 求。 （7）C-LOOK 算法C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定 需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有 磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。 4.2_3 减少延迟时间的方法 （1）减少延迟时间的方法：交替编号让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更少 （2）磁盘地址结构设计读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间 （3）减少延迟时间的方法：错位命名 4.2_4 磁盘的管理（1）磁盘初始化 （2）引导块 （3）坏块的管理简单磁盘：逻辑格式化时将坏块标记出来 复杂的磁盘：磁盘控制块维护一个坏块链，并管理备用扇区","link":"/posts/e6df91e/"},{"title":"平衡二叉树","text":"摘要： 平衡二叉树（AVL树） 1、平衡二叉树简介 2、单旋转（左旋转） 代码实现 12345678910111213141516//左旋转方法private void leftRotate() { //创建新的结点，以当前根节点的值 Node newNode = new Node(this.value); //新结点的左子树设置为当前节点的左子树 newNode.left = left; //把新的结点的右子树设置为当前节点的右子树的左子树 newNode.right = right.left; //当前节点的值替换换成右子节点的值 value = right.value; //把当前节点的右子树设置为右子树的右子树 right = right.right; //把当前节点的左子树设置为新的结点 left = newNode;} 3、单旋转（右旋转） 代码实现 123456789//右旋转方法private void rightRotate() { Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode;} 4、双旋转 问题分析：符合右旋转条件时，如果它的左子树的右子树的高度大于它的左子树的高度，先对当前节点的左节点进行左旋转，再对当前节点进行右旋转 1234567891011121314151617181920212223242526272829303132333435363738394041public void add(Node node) { if (node == null) { return; } //判断传入节点的值和当前子树的根节点的值的关系 if (node.value &lt; this.value) { if (this.left == null) { //当前节点左子节点为空，直接挂上去 this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { if (this.right == null) { this.right = node; } else { this.right.add(node); } } //添加完后判断是否需要旋转 //1.右子树的高度比左子树的高度大1 =&gt; 左旋转 if (rightHeight() - leftHeight() &gt; 1) { // if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) { right.rightRotate(); } leftRotate(); } //2.左子树的高度比右子树大1 =&gt; 右旋转 if (leftHeight() - rightHeight() &gt; 1) { // if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) { //先对当前节点的左子树进行左旋转 left.leftRotate(); } //再对当前节点进行右旋转 rightRotate(); }} 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package com.cyfwlp.avl;/** * @Author liaotao * @Date 2020/10/21 13:56 */public class AvlTreeDemo { public static void main(String[] args) { /*int[] arr = {4,3,6,5,7,8};*/ /*int[] arr = {10,12,8,9,7,6};*/ int[] arr = {10,11,7,6,8,9}; AvlTree avlTree = new AvlTree(); for (int i : arr) { avlTree.add(new Node(i)); } System.out.println(\"高度 ：\" + avlTree.getRoot().height()); System.out.println(\"左子树高度 ：\" + avlTree.getRoot().leftHeight()); System.out.println(\"右子树高度 ：\" + avlTree.getRoot().rightHeight()); System.out.println(\"当前根节点\" + avlTree.getRoot()); }}class AvlTree { private Node root; public Node getRoot() { return root; } //添加结点 public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root != null) { root.infinxOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } }}class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //左旋转方法 private void leftRotate() { //创建新的结点，以当前根节点的值 Node newNode = new Node(this.value); //新结点的左子树设置为当前节点的左子树 newNode.left = left; //把新的结点的右子树设置为当前节点的右子树的左子树 newNode.right = right.left; //当前节点的值替换换成右子节点的值 value = right.value; //把当前节点的右子树设置为右子树的右子树 right = right.right; //把当前节点的左子树设置为新的结点 left = newNode; } //右旋转方法 private void rightRotate() { Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode; } //返回以当前节点为根节点树的高度 public int height() { return Math.max(left == null ? 0 : left.height(),right == null ? 0 : right.height()) + 1; } //获取左子树高度 public int leftHeight() { if (left == null) { return 0; } else { return left.height(); } } //获取右子树的高度 public int rightHeight() { if (right == null) { return 0; } else { return right.height(); } } //添加结点的方法 //递归的形式添加结点，需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } //判断传入节点的值和当前子树的根节点的值的关系 if (node.value &lt; this.value) { if (this.left == null) { //当前节点左子节点为空，直接挂上去 this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { if (this.right == null) { this.right = node; } else { this.right.add(node); } } //添加完后判断是否需要旋转 //1.右子树的高度比左子树的高度大1 =&gt; 左旋转 if (rightHeight() - leftHeight() &gt; 1) { // if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) { right.rightRotate(); } leftRotate(); // ??? /* return;*/ } //2.左子树的高度比右子树大1 =&gt; 右旋转 if (leftHeight() - rightHeight() &gt; 1) { // if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) { //先对当前节点的左子树进行左旋转 left.leftRotate(); } //再对当前节点进行右旋转 rightRotate(); } } //中序遍历方法 public void infinxOrder() { if (this.left != null) { this.left.infinxOrder(); } System.out.println(this); if (this.right != null) { this.right.infinxOrder(); } }}","link":"/posts/4263f441/"},{"title":"多路查找树","text":"摘要： 二叉树与B树，2-3树，B树 1、二叉树与B树 2、2-3树 构建2-3树 3、B树","link":"/posts/5e27b8bd/"},{"title":"栈","text":"摘要： 栈 一.栈的一个实际需求输入一个表达式 计算结果 -&gt; 计算器底层原理 二.栈的介绍 栈的英文 stack 先入后出的有序列表 允许插入和删除的一端称为栈顶，不动的一端称为栈底 栈的应用场景 子程序的调用 递归调用 表达式的转化（中缀表达式转后缀表达式）与求值（实际应用） 二叉树的遍历 图的深度优先遍历算法 三.栈的快速入门1.数组模拟栈，进行入栈，出栈，遍历等操作思路分析 使用数组模拟栈 定义top表示栈顶，初始化为-1 入栈 top++ stack[top] = data; 出栈 int value = stack[top] ; top– 课后作业：实现链式栈 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.cyfwlp.stack;public class ArrayStackDemo { public static void main(String[] args) { ArrayStack arrayStack = new ArrayStack(4); arrayStack.push(1); arrayStack.push(2); arrayStack.push(3); arrayStack.print(); System.out.println(\"出栈\" + arrayStack.pop()); System.out.println(\"出栈\" + arrayStack.pop()); arrayStack.print(); }}//表示栈结构class ArrayStack{ private int maxSize;//最大大小 private int[] stack;//数组模拟栈，数据放在数组中 private int top = -1;//栈顶 public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } //判断栈满 public boolean isFull(){ return top == maxSize - 1; } //判断栈空 public boolean isEmpty(){ return top == -1; } //入栈 public void push(int value){ if (isFull()){ System.out.println(\"栈满\"); return; } top++; stack[top] = value; } //出栈 public int pop(){ if (isEmpty()){ throw new RuntimeException(\"栈空,没有数据\"); } int value = stack[top]; top--; return value; } //遍历栈 public void print(){ if (isEmpty()){ System.out.println(\"栈空\"); return; } //把原来的栈销毁了/* while (top != -1){ System.out.println(pop()); }*/ for (int i = top; i &gt;-1; i--) { System.out.println(stack[i]); } }} 课后作业代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.cyfwlp.stack;public class LinkedStackDemo { public static void main(String[] args) { LinkedStack stack = new LinkedStack(); stack.push(1); stack.push(2); stack.push(3); stack.pop(); stack.print(); }}class LinkedStack{ Node top; public boolean isEmpty(){ return top == null; } public void push(int value){ Node newNode = new Node(value); if(top == null){ top = newNode; }else{ newNode.next = top; top = newNode; } } public void print(){ if (isEmpty()){ System.out.println(\"栈空\"); return; } while (top != null){ System.out.println(top); top = top.next; } } public int pop(){ if (isEmpty()){ throw new RuntimeException(\"栈空\"); } int value = top.value; top = top.next; return value; }}class Node{ int value; Node next; public Node(int value) { this.value = value; next = null; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; }} 四.栈实现综合计算器思路 两个栈 数栈（numStack）：存放数字 符号栈(operStack)：存放运算符 通过一个index值（索引）遍历表达式 发现index得到数字就入数字栈 发现index是操作符 1.如果发现当前的符号栈为空就直接入栈 2.如果发现栈中有操作符，进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出来个数，再从符号栈pop出一个运算符，进行运算，得到结果，入数栈，然后将这个操作符入符号栈 3.当前的操作符优先级大于栈顶的操作符，直接入符号栈 4.当扫描完毕之后，顺序的从数栈和符号栈中pop出相应的数和符号并运算 5.最后数栈只有一个数字就是表达式的结果 3.课后练习，给表达式加上小括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package com.cyfwlp.stack;import org.omg.CosNaming.NamingContextExtPackage.StringNameHelper;/** * 计算器 * 输入表达式，计算出值 */public class CalculatorMy { public static void main(String[] args) { //定义字符串 String str = \"70+20*6-4\";// //定义数字栈和符号栈 ArrStack numStack = new ArrStack(10); ArrStack operStack = new ArrStack(10); //定义相关变量 char ch = ' '; int num1 = 0; int num2 = 0; char oper = ' '; //遍历字符串进行相关的操作 for (int i = 0; i &lt; str.length(); i++) { ch = str.charAt(i); if (operStack.isOper(ch)){ //是运算符，判断栈空？ if (operStack.isEmpty()){ operStack.push(ch); }else{ //比较这个运算符与栈顶元素的优先级 //判断括号 if (operStack.priority(ch) &lt;= operStack.priority((char) operStack.peek())){ num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); numStack.push(operStack.cal(num1,num2,oper)); if (operStack.priority(ch) == 0){ operStack.pop(); }else{ operStack.push(ch); } }else{ operStack.push(ch); } } }else{ //解决多位数问题是数字，判断下一位是不是数字 //分析： //1.多位数时不能发现是一个数时就立即入数栈 //2.在处理数时，应该再看一位，如果是符号直接入栈，数字则进行拼接 //3,定义字符串变量 StringBuilder num = new StringBuilder(); num.append(ch); //ch是字符串的最后一位，直接入栈 if (i == str.length() -1){ numStack.push(Integer.parseInt(num.toString())); }else{ if (operStack.isOper(str.charAt(i + 1))){ //后面一位是操作符，入栈 numStack.push(Integer.parseInt(num.toString())); }else{ num.append(str.charAt(i + 1)); i++; numStack.push(Integer.parseInt(num.toString())); } } } } while (!operStack.isEmpty()){ num1 = numStack.pop(); num2 = numStack.pop(); oper = (char) operStack.pop(); numStack.push(operStack.cal(num1,num2,oper)); } System.out.println(str + \"=\" + numStack.pop()); }}/** * 数组模拟栈 */class ArrStack{ private int maxSizes; private int[] stack; private int top; public ArrStack(int maxSizes) { this.maxSizes = maxSizes; stack = new int[maxSizes]; top = -1; } //栈空 public boolean isEmpty(){ return top == -1; } //栈满 public boolean isFull(){ return top == maxSizes -1; } //入栈 public void push(int value){ if (isFull()){ System.out.println(\"栈满，无法入栈\"); } top ++; stack[top] = value; } //出栈 public int pop(){ if (isEmpty()){ throw new RuntimeException(\"栈空,无法出栈\"); } int value = stack[top]; top--; return value; } //拿到栈顶的数据 public int peek(){ if (isEmpty()){ throw new RuntimeException(\"栈空,无法出栈\"); } int value = stack[top]; return value; } //遍历栈 public void print(){ if (isEmpty()){ throw new RuntimeException(\"栈空,无法出栈\"); } for (int i = top; i &gt; -1; i--) { System.out.println(stack[i]); } } //判断是不是运算符 public boolean isOper(char ch){ return ch == '+' ch == '-' ch == '*' ch == '/' ch == ')' ch == '('; } //判断运算符的优先级 public int priority(char ch){ if (ch == '(' ch == ')'){ return 0; }else if (ch == '*' ch == '/'){ return 2; }else{ return 1; } } //计算方法 public int cal(int num1 ,int num2, char oper){ int result = 0; switch (oper){ case '+': result = num2 + num1; break; case '-': result = num2 - num1; break; case '*': result = num2 * num1; break; case '/': result = num2 / num1; } return result; }} 五.前缀，中缀，后缀表达式（逆波兰表达式）1.前缀表达式（波兰表达式）前缀表达式： 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前 举例（3+4)*5-6 对应的前缀表达式就是 - * + 3 4 5 6 前缀表达式的计算机求值： 从右到左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们进行相应的运算（栈顶元素和次顶元素），并将结果入栈；重复上述过程直到表达式的最左端，最后运算出的值即为表达式的结果 2.中缀表达式中缀表达式： 中缀表达式就是常见的运算表达式 中缀表达式是我们所熟悉的，但对于计算机来说不好操作，因此在计算结果时，往往会将中缀表达式转化为其他表达式来操作（一般转为后缀表达式） 3.后缀表达式(逆波兰表达式)后缀表达式： 与前缀表达式类似，只是运算符位于操作数之后 举例：（3+4)*5-6对应的后缀表达式 3 4 + 5 * 6 - 后缀表达式的计算机求值： 从左到右扫描表达式，遇到数字时将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们进行相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述结果直到表达式的最有端，最后的结果即为表达式的结果 逆波兰计算器 完成一个逆波兰计算器，需求 输入一个逆波兰表达式，使用栈(Stack),计算显示结果 支持小括号和多位整数，（由于主要是数据结构，只支持整数的计算） 代码实现 123456789101112131415161718192021222324252627282930313233343536373839public static List&lt;String&gt; getListString(String suffixExpression){ String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s : split) { list.add(s); } return list;}//完成对逆波兰表达式的计算public static int calculate(List&lt;String&gt; list){ //创建栈，只需要一个栈 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历list for (String item : list) { //使用正则表达式来判断数 if (item.matches(\"\\\\d+\")){ stack.push(item); }else{ //pop出两个数，并运算,再入栈 int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")){ res = num1 + num2; }else if (item.equals(\"-\")){ res = num2 - num1; }else if (item.equals(\"*\")){ res = num1 * num2; }else if (item.equals(\"/\")){ res = num2/num1; }else { throw new RuntimeException(\"运算符有问题\"); } stack.push(String.valueOf(res)); } } return Integer.parseInt(stack.pop());} 5.中缀表达式转后缀表达式具体步骤： 打比方：学习降龙十八掌 两种选择：1.想洪七公学习武功，使用 2.自创武功然后使用 算法：1.理解算法，灵活的应用算法解决问题 2.自己设计一个算法，应用 初始化两个栈，运算符s1和存储中间结果的栈s2 从左到右扫描中缀表达式 遇到数字时，直接压入s2 遇到操作符时，比较其与s1栈顶元素的优先级 1.若s1为空，或栈顶的运算符为”(“，直接压入s1 2.否则，若优先级比栈顶元素的高,直接入栈 3.否则，将s1栈顶的符号弹出并压入到s2栈，再次回到4.1与s1中新的栈顶元素比较 遇到括号时： 1.如果是左括号”(“，直接压入s1 2.如果是右括号”)”，则依次弹出s1栈顶的运算符到s2中，直到遇到左括号为止，此时将这一对括号去掉 重复步骤2-5，直到表达式的最右边 将s1中剩余的元素依次压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.cyfwlp.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation { public static void main(String[] args) { //中缀表达式转为后缀表达式 //说明 //1.1+((2+3)*4)-5 -&gt; 1 2 3 + 4 * + 5 - //2.因为对字符串进行扫描不方便，因此先将字符串转成一个中缀的list（ArrayList） String expression = \"1+((2+3)*4)-5\"; List&lt;String&gt; list = toInfixExpressionList(expression); //3.将得到的中缀表达式对应的list 转成后缀表达式对应的list List&lt;String&gt; list1 = parseSuffixExpressionList(list); System.out.println(list1); //定义逆波兰表达式/* String suffixExpression = \"1 2 3 + 4 * + 5 -\"; List&lt;String&gt; listString = getListString(suffixExpression); System.out.println( suffixExpression + \" = \" + calculate(listString));*/ } //将逆波兰数据和运算符放到一个ArrayList //比遍历字符串简单，需判断空格啊等等 public static List&lt;String&gt; getListString(String suffixExpression){ String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s : split) { list.add(s); } return list; } //完成对逆波兰表达式的计算 public static int calculate(List&lt;String&gt; list){ //创建栈，只需要一个栈 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); //遍历list for (String item : list) { //使用正则表达式来判断数 if (item.matches(\"\\\\d+\")){ stack.push(item); }else{ //pop出两个数，并运算,再入栈 int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")){ res = num1 + num2; }else if (item.equals(\"-\")){ res = num2 - num1; }else if (item.equals(\"*\")){ res = num1 * num2; }else if (item.equals(\"/\")){ res = num2/num1; }else { throw new RuntimeException(\"运算符有问题\"); } stack.push(String.valueOf(res)); } } return Integer.parseInt(stack.pop()); } //将中缀表达式转成对应的list private static List&lt;String&gt; toInfixExpressionList(String s){ List&lt;String&gt; list = new ArrayList&lt;&gt;(); char ch; int i = 0;//遍历的索引 String num = new String();//进行拼接 do { ch = s.charAt(i); //如果是非数字，我们就需要加入到list if (ch &lt; 48 ch &gt; 57){ list.add(String.valueOf(ch)); i++; }else{ //是数字，进行拼接是 num = \"\"; while (i&lt;s.length() &amp;&amp; s.charAt(i) &gt;= 48 &amp;&amp; s.charAt(i) &lt;= 57){ num += s.charAt(i); i++; } list.add(num); } }while (i&lt;s.length()); return list; } //中缀表达式对应的list 转成后缀表达式对应的list private static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls){ //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();//符号栈 //s2的栈在整个操作过程没有pop操作，而且还需要逆序输出，使用list代替之 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//存放中间结果的栈 //遍历ls for (String item : ls) { //如果是数，就加入s2 if (item.matches(\"\\\\d+\")){ s2.add(item); }else if (item.equals(\"(\")){ s1.push(item); }else if (item.equals(\")\")){ //s1 弹出 s2 加入直到 遇到\"(\" while (!s1.peek().equals(\"(\")){ s2.add(s1.pop()); } //将\"(\"弹出 s1.pop(); }else { //item &lt;= s1.peek() 优先级 //确少一个比较优先级高低的方法 while (s1.size() != 0 &amp;&amp; Operation.getValue(item) &lt;= Operation.getValue(s1.peek())){ s2.add(s1.pop()); } //将item入栈 s1.push(item); } } //将s1中剩余的依次加入s2 while (s1.size() != 0){ s2.add(s1.pop()); } return s2; }}//编写一个类Operation,可以返回一个运算符对应的优先级class Operation{ private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //使用一个方法返回优先级的数字 public static int getValue(String operation){ int result = 0; switch (operation){ case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在该运算符\"); } return result; }}","link":"/posts/1f4ac2fb/"},{"title":"查找算法","text":"摘要： 常见查找算法，顺序查找、二分查找、插值查找、斐波那契查找 查找算法1、查找算法介绍在java中，常用的查找有四种 顺序查找（线性查找） 二分查找（折半查找） 插值查找 斐波那契查找 2、顺序查找1234567891011121314151617181920212223242526package com.cyfwlp.search;public class SeqSearch { public static void main(String[] args) { int[] arr = {1,9,11,-1,34,89};//没有顺序的数组 int index = seqSearch(arr,11); System.out.println(index); } /** * 实现的线性查找是找到一个满足条件的值就返回 * @param arr * @param value * @return */ public static int seqSearch(int[] arr,int value) { //线性查找是逐一比对，发现有相同的值时就返回下标 for (int i = 0; i &lt; arr.length; i++) { if (arr[i] == value) { return i; } } return -1; }} 3、二分查找二分查找的思路分析 首先确定该数组的中间的下标 mid = (left + right)/2 然后比较findVal与arr[mid]比较 findVal &gt; arr[mid] 递归向右查找 findVal &lt; arr[mid] 递归向左查找 findVal = arr[mid] 返回 什么时候结束递归？ 1、找到就结束递归 2、找不到(递归完整个数组都没有找到) -&gt; left &gt; right 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.cyfwlp.search;import java.util.ArrayList;//注意：使用二分查找的前提是该数组是有序的public class BinarySearch { public static void main(String[] args) { int[] arr = {1,8,10,89,1000,1000,1000,1000,1234};/* int resultIndex = binarySearch(arr,0,arr.length - 1,1000); System.out.println(resultIndex);*/ ArrayList&lt;Integer&gt; integers = binarySearch2(arr, 0, arr.length - 1, -1); for (Integer integer : integers) { System.out.println(integer); } } /** * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 要查找的值 * @return 找到返回下标，没有找到返回 -1 */ public static int binarySearch(int arr[], int left, int right, int findVal) { //当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) { return -1; } int mid = (left + right) / 2; int midValue = arr[mid]; if (findVal &gt; midValue) { return binarySearch(arr,mid + 1,right,findVal); }else if (findVal &lt; midValue) { return binarySearch(arr,left,mid - 1,findVal); }else { return mid; } } //课后思考题，当一个有序数组有多个值时，查询到所有得到值 //思路： //在找到mid值时不要马上返回 //向mid索引值的左边扫描，将所有满足1000的下标加入到集合ArrayList //向mid索引值的右边扫描，将所有满足1000的下标加入到集合ArrayList //返回ArrayList /** * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 要查找的值 * @return 没找到返回空列表 找到返回列表 */ public static ArrayList&lt;Integer&gt; binarySearch2(int arr[], int left, int right, int findVal) { //当left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) { return new ArrayList&lt;Integer&gt;(); } int mid = (left + right) / 2; int midValue = arr[mid]; if (findVal &gt; midValue) { return binarySearch2(arr,mid + 1,right,findVal); }else if (findVal &lt; midValue) { return binarySearch2(arr,left,mid - 1,findVal); }else { ArrayList&lt;Integer&gt; resultIndexList = new ArrayList&lt;&gt;(); int temp = mid - 1; while (true) { if (temp &lt; 0 arr[temp] != findVal) { break; } //否则就把temp放入集合 resultIndexList.add(temp); temp -= 1; } resultIndexList.add(mid); temp = mid + 1; while (true) { if (temp &gt; arr.length - 1 arr[temp] != findVal) { break; } //否则就把temp放入集合 resultIndexList.add(temp); temp += 1; } return resultIndexList; } }} 4、插值查找若使用二分查找算法，数组{1,2…,20}，查找1需要四次 插值查找原理介绍： 插值查找类似于二分查找，不同的是每次要从自适应的mid处开始查找 将折半查找的mid索引公式改为 mid =（high-low）*（key-arr[low]）/（arr[high]-arr[low]） 若使用插值查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cyfwlp.search;import java.util.Arrays;public class InsertValueSearch { public static void main(String[] args) { int arr[] = new int[100]; for (int i = 0; i &lt; 100; i++) { arr[i] = i + 1; } int index = insertValueSearch(arr, 0, arr.length - 1, 1); System.out.println(index); } //编写插值查找算法 //原理基于二分查找，也要求数据有序 /** * * @param arr 传入的数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 查找的值 * @return 找到返回下标，没找到返回 -1 */ public static int insertValueSearch(int[] arr,int left, int right, int findVal) { System.out.println(\"插值查找被调用\"); //注意： if (left &gt; right findVal &lt; arr[0] findVal &gt; arr[arr.length - 1]) { return -1; } int mid = (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midValue = arr[mid]; if (findVal &gt; midValue) { return insertValueSearch(arr,mid + 1,right,findVal); }else if (findVal &lt; midValue) { return insertValueSearch(arr,left,mid - 1,findVal); }else { return mid; } }} 注意： 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快。 关键字分布不均匀的情况下，该方法不一定比折半查找要好 4、斐波那契（黄金分割法）查找算法 黄金分割点 ：0.168 ​ 斐波那契数列：1,1,2,3,5,8,13,21…. 发现斐波那契数列的两个相邻数的比利，无限接近黄金分割值0.168 ​ 斐波那契原理分析： 斐波那契查找的原理与前两种相似，仅仅改变mid的位置，mid不再是中间或者插值得到的，而是位于黄金分割点附近，即 mid = low + F(k-1) - 1 对F(k - 1) -1 的理解： 由斐波那契数列F(k) = F(k-1) + F(k - 2)的性质，可以得到 F([k] - 1) = F([k - 1] - 1) + F([k -2] - 1)。该式说明：只要顺序表长度为F(k) - 1，则可以将该表分成长度为F(k - 1) - 1和 F(k - 2) - 1 的两段 ，中间位置 mid = low + F(k - 1) - 1; 类似的，每一个字段也可以用相同的方式分割 但是顺序表的长度不一定刚好等于F([k] - 1)，所以需要将原来的顺序表的长度n增加为F([k] - 1)。这里的k值只要能能使得F([k] - 1) 恰好大于或等于n即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F[k -1] 位置），都赋值为n位置的值即可 123while(n &gt; fib(k-1)) {k ++;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.cyfwlp.search;import java.util.Arrays;public class FibonacciSearch { private static int maxSize = 20; public static void main(String[] args) { int[] arr = {1,8,10,89,1000,1234}; int index = fibSearch(arr,8); System.out.println(index); } //使用非递归的方式得到一个得波那契数列 public static int[] fib() { int[] fib = new int[maxSize]; fib[0] = fib[1] = 1; for (int i = 2; i &lt; maxSize; i++) { fib[i] = fib[i-1] + fib[i-2]; } return fib; } //编写斐波那契查找算法 /** * 使用非递归的方式 * @param a 数组 * @param key 需要查找的关键字 * @return 找到返回下标，没找到返回-1 */ public static int fibSearch(int[] a,int key) { int low = 0; int high = a.length - 1; int k = 0; //斐波那契分割数值的下标 int mid = 0;//存放mid int f[] = fib();//获取斐波那契数列 //获取k (分割数组的下标) while (a.length &gt; f[k]) { k ++; } //因为f[k]的值可能大于数组a的长度,因此需要一个构造一个新数组，并指向a //不足会用0填充 int[] temp = Arrays.copyOf(a,f[k]); //实际上需要使用a数组最后的数填充数组temp for (int i = high + 1; i &lt; temp.length; i++) { temp[i] = a[high]; } //使用while循环循环处理（代替递归） while (low &lt;= high) { mid = low + f[k-1] - 1; if (key &lt; temp[mid]) { //向左查找 high = mid - 1; /** * 为什么是k-- * 1.全部元素 = 前面的元素 + 后面的元素 * 2.f[k] = f[k-1] + f[k-2] * 因为前面有f[k-1]个元素，所以可以继续拆分 f[k-1] = f[k-2] + f[k -3]; * 即在f[k-1]的前面继续查找 k-- * 即下次循环 mid = f[k-1-1] - 1 */ k --; //???????????? }else if (key &gt; temp[mid]) { low = mid + 1; /** * 1.全部元素 = 前面的元素 + 后面的元素 * 2.f[k] = f[k-1] + f[k-2] * 因为后面有f[k-2]个元素 所以可以继续拆分f[k-1] = f[k-3] + f[k-4] * 即在f[k-2]的前面进行查找k-=2 * 即下次循环mid = f[k-1-2] -2 */ k -= 2; }else { //需要确定，返回的是哪个下标 if (mid &lt; high) { return mid; }else { return high; } } } return -1; }}","link":"/posts/aad2137f/"},{"title":"树结构","text":"摘要： 树 二叉树 1、为什么需要树这种数据结构1、数组存储方式的分析 优点：通过下标访问，速度快；对于有序数组，使用二分查找提高检索速度 ​ 缺点：检索某个值或者插入值，将整体移动数组，效率较低 2、链式存储方式的分析 优点：插入，删除节点的效率较高 ​ 缺点：在进行检索时，效率依然较低 3、树存储方式 能提高数据的存储，读取的效率，使用二叉排序树，既可以保证数据的检索速度，同时可以保证数据的插入，删除，修改的速度 2、树的常用术语 3、二叉树1、二叉树的概念1）、每个节点最多只能有两个子节点的一种树称为二叉树 2）、二叉树的子节点分为左节点和右节点 3）、如果该二叉树的所有叶子节点都在最后一层，并且节点总数 = 2 ^ n - 1（n为层数），则我们称为满二叉树 4）、如果二叉树的所有叶子节点都在最后一层或者倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 2、二叉树的遍历 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.cyfwlp.tree;public class BinaryTreeDemo { public static void main(String[] args) { //创建二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的节点 HeroNode node1 = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); //先手动创建，后面以递归的方式创建二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(node1); binaryTree.preOrder(); // 1 2 3 5 4 System.out.println(); binaryTree.infixOrder(); // 2 1 5 3 4 System.out.println(); binaryTree.postOrder(); // 2 5 4 3 1 }}//定义二叉树class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } //前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } public void infixOrder() { if (this.root != null) { this.root.infixOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } public void postOrder() { if (this.root != null) { this.root.postOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } }}//创建HeroNode节点class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } //前序遍历方法 public void preOrder() { //输出当前节点（父节点） System.out.println(this); //向左子数前序遍历 if (this.left != null) { this.left.preOrder(); } //向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } //中序遍历方法 public void infixOrder() { //向左子数中序遍历 if (this.left != null) { this.left.infixOrder(); } //输出当前节点（父节点） System.out.println(this); //向右子树前序遍历 if (this.right != null) { this.right.infixOrder(); } } //后续遍历方法 public void postOrder() { if (this.left != null) { this.left.postOrder(); } if (this.right != null) { this.right.postOrder(); } //输出当前节点（父节点） System.out.println(this); }} 3、二叉树的查找 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.cyfwlp.tree;public class BinaryTreeDemo { public static void main(String[] args) { //创建二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的节点 HeroNode node1 = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); //先手动创建，后面以递归的方式创建二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(node1); System.out.println(\"遍历查找\"); HeroNode heroNode = binaryTree.postOrderSearch(5); System.out.println(heroNode); System.out.println(); }}//定义二叉树class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } //前序遍历查找 public HeroNode preOrderSearch(int no) { if (root != null) { return root.preOrderSearch(no); }else { return null; } } public HeroNode infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); }else { return null; } } public HeroNode postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); }else { return null; } }}//创建HeroNode节点class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } //前序遍历查找 /** * * @param no * @return 没找到返回null */ public HeroNode preOrderSearch(int no) { System.out.println(\"进入前序遍历\"); if (this.no == no) { return this; } HeroNode resNode = null; if (this.left != null) { resNode = this.left.preOrderSearch(no); } if (resNode != null) { //说明左子树找到了 return resNode; } if (this.right != null) { resNode = this.right.preOrderSearch(no); } //找到或者没找到都直接返回 return resNode; } //中序遍历查找 public HeroNode infixOrderSearch(int no) { HeroNode resNode = null; if (this.left != null) { resNode = this.left.infixOrderSearch(no); } if (resNode != null) { //说明左子树找到了 return resNode; } System.out.println(\"进行中续遍历查找\"); if (this.no == no) { return this; } if (this.right != null) { resNode = this.right.infixOrderSearch(no); } //找到或者没找到都直接返回 return resNode; } //后续遍历查找 public HeroNode postOrderSearch(int no) { HeroNode resNode = null; if (this.left != null) { resNode = this.left.postOrderSearch(no); } if (resNode != null) { //说明左子树找到了 return resNode; } if (this.right != null) { resNode = this.right.postOrderSearch(no); } if (resNode != null) { //说明右子树找到了 return resNode; } System.out.println(\"进行后续遍历查找\"); if (this.no == no) { return this; } return resNode; }} 4、二叉树-删除节点要求： 1）、删除叶子节点直接删除 2）、删除子节点删除子树 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.cyfwlp.tree;public class BinaryTreeDemo { public static void main(String[] args) { //创建二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的节点 HeroNode node1 = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); //先手动创建，后面以递归的方式创建二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(node1); //测试删除结点 System.out.println(\"删除前\"); binaryTree.preOrder(); binaryTree.deleteNode(5); System.out.println(\"删除后\"); binaryTree.preOrder(); }}//定义二叉树class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } //前序遍历 public void preOrder() { if (this.root != null) { this.root.preOrder(); }else { System.out.println(\"二叉树为空，无法遍历\"); } } //删除结点 public void deleteNode(int no) { if (root != null) { if (root.getNo() == no){ root = null; }else { root.deleteNode(no); } }else { System.out.println(\"空树不能删除\"); } }}//创建HeroNode节点class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) { this.no = no; this.name = name; } //get，set方法省略 @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } //前序遍历方法 public void preOrder() { //输出当前节点（父节点） System.out.println(this); //向左子数前序遍历 if (this.left != null) { this.left.preOrder(); } //向右子树前序遍历 if (this.right != null) { this.right.preOrder(); } } /** * 删除结点 * @param no */ public void deleteNode(int no) { if (this.left != null &amp;&amp; this.left.no == no) { this.left = null; return; } if (this.right != null &amp;&amp; this.right.no == no) { this.right = null; return; } if (this.left != null) { this.left.deleteNode(no); } if (this.right != null) { this.right.deleteNode(no); } }} 课后作业： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.cyfwlp.tree;import javax.xml.ws.handler.HandlerResolver;/** * 实现树结点的删除 * 1）删除结点如果是非叶子节点，不希望将该节点为根节点的子树删除，规定 * 2）如果非叶子节点A下只有一个子节点B，则子节点B替代子节点A * 3）如果该叶子节点A有左节点B和右节点C，则让左子节点B代替节点A */public class BinaryTreeHomeWork1 { public static void main(String[] args) { BinaryTree1 tree = new BinaryTree1(); Node node1 = new Node(1, \"宋江\"); Node node2 = new Node(2, \"吴用\"); Node node3 = new Node(3, \"卢俊义\"); Node node4 = new Node(4, \"林冲\"); Node node5 = new Node(5, \"关胜\"); //先手动创建，后面以递归的方式创建二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); tree.setRoot(node1); System.out.println(\"删除前\"); tree.preOrder(); tree.deleteNode(3); System.out.println(\"删除后\"); tree.preOrder(); }}class BinaryTree1 { private Node root; public void setRoot(Node root) { this.root = root; } public void preOrder() { if (this.root == null) { System.out.println(\"树为空，不能遍历\"); }else { this.root.preOrder(); } } public void deleteNode(int no) { if (this.root.getNo() == no) { root = null; }else { root.deleteNode(no); } }}//定义节点class Node { private int no; private String name; private Node left; private Node right; public Node(int no, String name) { this.no = no; this.name = name; } //set,get方法省略 @Override public String toString() { return \"Node{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } //前序遍历 public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } /** * 如果非叶子节点A下只有一个子节点B，则子节点B替代子节点A * 如果该叶子节点A有左节点B和右节点C，则让左子节点B代替节点A * @param no */ public void deleteNode(int no) { if (this.getLeft() != null &amp;&amp; this.getLeft().getNo() == no) { //找到左节点是需要删除 //判断需要删除的结点有几个子节点 if (this.getLeft().getLeft() != null &amp;&amp; this.getLeft().getRight() != null) { //有两个结点 Node temp = this.getLeft().getRight(); this.setLeft(this.getLeft().getLeft()); this.getLeft().setRight(temp); }else if (this.getLeft().getLeft() == null &amp;&amp; this.getLeft().getRight() == null) { //没有结点 this.setLeft(null); }else { //有一个结点 if (this.getLeft().getLeft() != null) { this.setLeft(this.getLeft().getLeft()); }else { this.setLeft(this.getLeft().getRight()); } } } if (this.getRight() != null &amp;&amp; this.getRight().getNo() == no) { //右节点需要删除 if (this.getRight().getLeft() != null &amp;&amp; this.getRight().getRight() != null) { //有两个结点 Node temp = this.getRight().getRight(); this.setRight(this.getRight().getLeft()); this.getRight().setRight(temp); }else if (this.getRight().getLeft() == null &amp;&amp; this.getRight().getRight() == null) { //没有结点 this.setRight(null); }else { //有一个结点 if (this.getRight().getLeft() != null) { this.setRight(this.getRight().getLeft()); }else { this.setRight(this.getRight().getRight()); } } } //未找到。继续遍历 if (this.getLeft() != null) { this.getLeft().deleteNode(no); } if (this.getRight() != null) { this.getRight().deleteNode(no); } }} 5、顺序存储二叉树 顺序二叉树的特点： ​ 1）顺序二叉树通常只考虑完全二叉树 ​ 2） 第n个元素的左子节点为 2*n+1 ​ 3） 第n个元素的右子节点为 2*n+2 ​ 4） 第n个元素的父节点为 (n-1)/2 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.cyfwlp.tree;public class ArrayBinaryTreeDemo { public static void main(String[] args) { int[] arr = {1,2,3,4,5,6,7}; ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr); arrayBinaryTree.preOrder(); }}class ArrayBinaryTree { //存储数据节点的数组 private int[] arr; public ArrayBinaryTree(int[] arr) { this.arr = arr; } //编写一个方法，完成顺序存储二叉树的一个前序遍历 public void preOrder() { preOrder(0); } /** * * @param index 数组的下标 */ public void preOrder(int index) { //如果数组为空或者arr.length == 0 if (arr == null arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //输出当前的数组元素 System.out.print(arr[index] + \" \"); //向左递归遍历 if ((index * 2 + 1) &lt; arr.length) { preOrder(index * 2 + 1); } if ((index * 2 + 2) &lt; arr.length) { preOrder(index * 2 + 2); } }} 课后作业代码实现： 1234567891011121314151617181920212223242526272829public void infixOrder(int index) { //如果数组为空或者arr.length == 0 if (arr == null arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } if ((index * 2 + 1) &lt; arr.length) { infixOrder(index * 2 + 1); } //输出当前的数组元素 System.out.print(arr[index] + \" \"); if ((index * 2 + 2) &lt; arr.length) { infixOrder(index * 2 + 2); }}public void postOrder(int index) { //如果数组为空或者arr.length == 0 if (arr == null arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } if ((index * 2 + 1) &lt; arr.length) { postOrder(index * 2 + 1); } if ((index * 2 + 2) &lt; arr.length) { postOrder(index * 2 + 2); } //输出当前的数组元素 System.out.print(arr[index] + \" \");} 6、线索二叉树 案例：将如图所示的二叉树依次进行中序线索二叉树，并遍历线索二叉树 课后作业：进行前序，后续线索二叉树，并遍历线索二叉树 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.cyfwlp.tree.threadedbinarytree;public class ThreadedBinaryTreeDemo { public static void main(String[] args) { //测试中序线索二叉树 HeroNode node1 = new HeroNode(1, \"\"); HeroNode node2 = new HeroNode(3, \"\"); HeroNode node3 = new HeroNode(6, \"\"); HeroNode node4 = new HeroNode(8, \"\"); HeroNode node5 = new HeroNode(10, \"\"); HeroNode node6 = new HeroNode(14, \"\"); //建立关系（后面递归创建，现在手动创建） node1.setLeft(node2); node1.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); BinaryTree binaryTree = new BinaryTree(); binaryTree.setRoot(node1); binaryTree.threadNode(); binaryTree.threadList(); }}class BinaryTree { private HeroNode root; //实现线索化，创建指向当前节点前驱节点的引用 private HeroNode pre = null; /** * 编写对二叉树进行中序线索化的方法 * @param node 当前需要线索化的结点 */ public void threadNode(HeroNode node) { if (node == null) { return; } //1.线索化左子树 threadNode(node.getLeft()); //2.线索化当前节点 //2.1 处理左节点 if (node.getLeft() == null) { node.setLeft(pre); node.setLeftType(1); } //2.2处理右节点 if (pre != null &amp;&amp; pre.getRight() == null) { pre.setRight(node); pre.setRightType(1); } pre = node; //3.线索化右子树 threadNode(node.getRight()); } //遍历线索化二叉树的方法 public void threadList() { HeroNode node = root; while (node != null) { while (node.getLeftType() != 1) { node = node.getLeft(); } System.out.println(node); if (node.getRightType() == 1) { System.out.println(node.getRight()); node = node.getRight(); } node = node.getRight(); } }}//创建HeroNode节点class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; private int leftType; //leftType = 0 指向左子树 leftType = 1 指向的是前驱节点 private int rightType; // rightType = 0 指向左子树 rightType = 1 指向的是后驱节点 public HeroNode(int no, String name) { this.no = no; this.name = name; } //get,set方法省略 @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; }} 课后作业关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * * 前序线索二叉树 * @param node */public void preThreadedNode(HeroNode node) { //!!!退出条件 if (node == null) { return; } //线索化当前节点 //操作左节点 if (node.getLeft() == null) { node.setLeft(pre); node.setLeftType(1); } //操作右节点 if (pre != null &amp;&amp; pre.getRight() == null) { pre.setRight(node); pre.setRightType(1); } pre = node; //线索化左子树 if (node.getLeftType() == 0){ preThreadedNode(node.getLeft()); } //线索化右子树 if (node.getRightType() == 0) { preThreadedNode(node.getRight()); }}/**前序遍历线索二叉树 * */public void preThreadedList() { HeroNode node = root; System.out.println(node); while (node != null) { while (node.getLeftType() == 0) { node = node.getLeft(); System.out.println(node); } if (node.getRightType() == 1) { System.out.println(node.getRight()); node = node.getRight(); } }}/** * 后序线索二叉树 * @param node */public void postThreadedNode(HeroNode node) { //!!!退出条件 if (node == null) { return; } //线索化左子树 postThreadedNode(node.getLeft()); //线索化右子树 postThreadedNode(node.getRight()); //序列换当前节点 //操作左节点 if (node.getLeft() == null) { node.setLeft(pre); node.setLeftType(1); } //操作右节点 if (pre != null &amp;&amp; pre.getRight() == null) { pre.setRight(node); pre.setRightType(1); } pre = node;}/**后序遍历线索二叉树 * */public void postThreadedList() { //有点复杂，回头探讨}","link":"/posts/270c6601/"},{"title":"树结构的实际应用 ——赫夫曼树","text":"摘要： 赫夫曼树 1、赫夫曼树赫夫曼树 ： wpl(带权路径)最小的树就是赫夫曼树 1、赫夫曼树的构建 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.cyfwlp.huffmantree;import java.util.ArrayList;import java.util.Collections;/** * @Author liaotao * @Date 2020/9/29 16:54 */public class HuffmanTree { public static void main(String[] args) { int[] arr = {13,7,8,3,29,6,1}; Node root = createHuffmanTree(arr); //测试 preOrder(root); } /** * @Author liaotao * @Date 18:23 2020/9/29 * @Description 创建赫夫曼树的方法 * @Param [arr] * @return void **/ public static Node createHuffmanTree(int[] arr) { ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int value : arr) { nodes.add(new Node(value)); } while (nodes.size() != 1) { //从小到大排序 Collections.sort(nodes); //取出根节点最小的两个二叉树 Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); //构建一颗新的二叉树 Node parent = new Node(leftNode.getValue() + rightNode.getValue()); parent.setLeft(leftNode); parent.setRight(rightNode); //删除原先的最小两个节点 nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); } //返回赫夫曼树的root节点 return nodes.get(0); } public static void preOrder(Node root) { if (root != null) { root.preOrder(); }else { System.out.println(\"空树！！！\"); } }}/** * @Author liaotao * @Date 17:15 2020/9/29 * @Description 创建节点类 **/class Node implements Comparable&lt;Node&gt;{ private int value; //节点的权值 private Node left; private Node right; @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } @Override public int compareTo(Node o) { //对权值进行比较 return this.value - o.value; } public void preOrder() { System.out.println(this); if (this.getLeft() != null) { this.getLeft().preOrder(); } if (this.getRight() != null) { this.getRight().preOrder(); } }} 2、定长编码与变长编码1、定长编码 2、变长编码 3、赫夫曼编码压缩文本 ： i like like like java do you like a java 步骤： Node { data(存放数据)，weight(权重),left,right } 字符串对应的byte[] 数组 编写一个方法将准备构建赫夫曼树的结点放到一个list 代码实现： （确实略有难度） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281package com.cyfwlp.huffmantree;import java.util.*;/** * @Author liaotao * 实现赫夫曼编码压缩字符串，并解码 * @Date 2020/10/16 17:56 */public class HuffmanTreeMy { private static Map&lt;Byte,String&gt; huffmanCodes = new HashMap&lt;&gt;(); //赫夫曼编码表 public static void main(String[] args) { //要进行转换的字符串 String str = \"i like like like java do you like a java\"; //赫夫曼编码压缩 byte[] huffmanZip = huffmanZip(str.getBytes()); //解码 byte[] decode = decode(huffmanZip); System.out.println(new String(decode)); } private static byte[] decode(byte[] huffmanBytes) { //得到二进制字符串 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; huffmanBytes.length; i++) { //最后一个数不进行补全 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBinaryString(!flag,huffmanBytes[i])); } //构建赫夫曼解码表 Map&lt;String,Byte&gt; decode = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) { decode.put(entry.getValue(),entry.getKey()); } //用赫夫曼解码表进行解码 ArrayList&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length();) { boolean flag = true; int count = 1; Byte b = null; while (flag) { String str = stringBuilder.substring(i,i+count); b = decode.get(str); if (b == null) { count +=1; } else { flag = false; } } list.add(b); i += count; } byte[] result = new byte[list.size()]; for (int i = 0; i &lt; list.size(); i++) { result[i] = list.get(i); } return result; } /** * @Author liaotao * @Date 18:54 2020/10/19 * @Description 将一个byte转为一个二进制的字符串 * @Param [b] flag标识是否为最后一个数 * @return java.lang.String **/ private static String byteToBinaryString(boolean flag,byte b) { int temp = b; //如果是正数我们存在补高位的问题 if (flag) { temp = 256; } String str = Integer.toBinaryString(temp); if (flag) { return str.substring(str.length() - 8); } else { return str; } } // 压缩部分 ------------------------------------------------------------------------------------------------ private static byte[] huffmanZip(byte[] contentBytes) { //统计出现次数 List&lt;NodeMy&gt; nodes = getNodes(contentBytes); //构建赫夫曼树 NodeMy huffmanNode = builtHuffmanTree(nodes); //得到赫夫曼编码表 getHuffmanCodes(huffmanNode); //压缩 return zip(contentBytes); //解压 } /** * @Author liaotao * @Date 15:19 2020/10/19 * @Description 统计字符出现的次数，构建节点列表 * @Param [contentBytes] * @return java.util.List&lt;com.cyfwlp.huffmantree.NodeMy&gt; **/ private static List&lt;NodeMy&gt; getNodes(byte[] contentBytes) { List&lt;NodeMy&gt; list = new ArrayList&lt;&gt;(); Map&lt;Byte,Integer&gt; map = new HashMap&lt;&gt;(); //lambda表达式/* for (byte key : contentBytes) { map.merge(key, 1, Integer::sum); }*/ for (byte key : contentBytes) { if (map.get(key) == null) { map.put(key,1); } else { map.put(key,map.get(key) + 1); } } for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { list.add(new NodeMy(entry.getKey(),entry.getValue())); } return list; } /** * @Author liaotao * @Date 15:32 2020/10/19 * @Description 构建赫夫曼树 * @Param [nodes] 节点列表 * @return com.cyfwlp.huffmantree.NodeMy 赫夫曼树的根节点 **/ private static NodeMy builtHuffmanTree(List&lt;NodeMy&gt; nodes) { while (nodes.size() != 1) { //排序 Collections.sort(nodes); //拿出最小的两个结点 NodeMy left = nodes.get(0); NodeMy right = nodes.get(1); //组成新的二叉树 NodeMy temp = new NodeMy(null,left.getWeight() + right.getWeight()); temp.setLeft(left); temp.setRight(right); //新的二叉树加入数组，删除最小的两个 nodes.add(temp); nodes.remove(left); nodes.remove(right); } return nodes.get(0); } //前序遍历方便测试 private static void preOrder(NodeMy root) { System.out.println(root); if (root.getLeft() != null) { preOrder(root.getLeft()); } if (root.getLeft() != null) { preOrder(root.getRight()); } } /** * @Author liaotao * @Date 15:45 2020/10/19 * @Description 根据赫夫曼得地赫夫曼编码表 * @Param [huffmanNode] 赫夫曼树根节点 * @return void **/ private static void getHuffmanCodes(NodeMy huffmanNode) { getCodes(huffmanNode,\"\",new StringBuilder()); } private static void getCodes(NodeMy node,String code,StringBuilder stringBuilder) { StringBuilder stringBuilder1 = new StringBuilder(stringBuilder); stringBuilder1.append(code); if (node != null) { if (node.getValue() == null) { //非叶子节点 //递归遍历 getCodes(node.getLeft(),\"0\",stringBuilder1); getCodes(node.getRight(),\"1\",stringBuilder1); } else { huffmanCodes.put(node.getValue(),stringBuilder1.toString()); } } } /** * @Author liaotao * @Date 16:02 2020/10/19 * @Description 进行数据压缩 * @Param [contentByte] 压缩前的字节数组 * @return byte[] 压缩后的字节数组 **/ private static byte[] zip(byte[] contentByte) { StringBuilder stringBuilder = new StringBuilder(); //利用哈夫曼编码将byte转为二进制字符串 for (byte b : contentByte) { stringBuilder.append(huffmanCodes.get(b)); } /*System.out.println(stringBuilder.toString() + \"压缩时长度为\" + stringBuilder.length());*/ int strLength = stringBuilder.length(); //把这个二进制字符串转为字节数组 //1.字节数组的长度 int length = strLength % 8 == 0 ? strLength/8 : strLength/8 + 1; byte[] result = new byte[length]; //2.遍历进行转换 int index = 0; for (int i = 0; i &lt; strLength; i+=8) { String str; if (i + 8 &gt; strLength) { //循环到最后不足八位 str = stringBuilder.substring(i); } else { str = stringBuilder.substring(i,i+8); } result[index] = (byte) Integer.parseInt(str,2); index ++; } return result; }}//定义节点class NodeMy implements Comparable&lt;NodeMy&gt;{ private Byte value; private int weight; //权重 private NodeMy left; private NodeMy right; public NodeMy(Byte value, int weight) { this.value = value; this.weight = weight; } public Byte getValue() { return value; } public void setValue(Byte value) { this.value = value; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public NodeMy getLeft() { return left; } public void setLeft(NodeMy left) { this.left = left; } public NodeMy getRight() { return right; } public void setRight(NodeMy right) { this.right = right; } @Override public String toString() { return \"NodeMy{\" + \"value=\" + value + \", weight=\" + weight + '}'; } @Override public int compareTo(NodeMy o) { //从小到大排序 return this.weight - o.weight; }} 2、实践-文件压缩使用赫夫曼编码压缩图片文件 核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//调用了上个代码的部分方法private static void zipFile(String srcFile,String dstFile){ FileInputStream is = null; FileOutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); //创建一个和源文件大小一样的byte[]; byte[] b = new byte[is.available()]; is.read(b); //使用赫夫曼编码进行编码 byte[] huffmanBytes = huffmanZip(b); //创建文件输出流 os = new FileOutputStream(dstFile); //创建一个和文件输出流关键的ObjectOutStream oos = new ObjectOutputStream(os); //写入自己数组 oos.writeObject(huffmanBytes); //对象流的方式写入赫夫曼编码，是为了以后解压的时候使用 oos.writeObject(huffmanCodes); } catch (Exception e) { e.printStackTrace(); } finally { try { is.close(); os.close(); oos.close(); } catch (IOException e) { e.printStackTrace(); } }}private static void unZipFile(String zipFile,String dstFile) throws IOException { //定义文件的输入输出流 FileInputStream is = null; FileOutputStream os = null; ObjectInputStream ois = null; try{ is = new FileInputStream(zipFile); //创建和is关联的对象输入流 ois = new ObjectInputStream(is); // 读取byte数组 byte[] huffmanBytes = (byte[]) ois.readObject(); // 读取赫夫曼编码表 Map&lt;Byte,String&gt; codes = (Map&lt;Byte, String&gt;) ois.readObject(); //解码 byte[] bytes = decode(huffmanBytes,huffmanCodes); //写入目标文件 os = new FileOutputStream(dstFile); os.write(bytes); } catch (Exception e){ e.printStackTrace(); } finally { is.close(); os.close(); ois.close(); }}","link":"/posts/58b0824a/"},{"title":"线性结构和非线性结构","text":"摘要： 线性结构和非线性结构 线性结构和非线性结构线性结构 线性结构作为最常用的数据结构，特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构，顺序存储结构和链式存储结构，顺序表存储元素是连续的，链表存储元素不一定是连续的 常见的线性结构：数组，链表，队列，栈 非线性结构 常见的非线性结构：二维数组，多维数组，广义表，图，树","link":"/posts/4ca5b461/"},{"title":"网易云解锁变灰歌曲（解锁会员？）","text":"摘要： 最近发现一款很强的插件，先附上原项目地址，对原理不做过多探究 1、点击下载，下载完成是一个.exe程序，点击运行就会一直监听本地8080端口点我下载 若不进行开发一般应用不会使用8080端口 2、运行网易云，在设置-工具里找到自定义代理服务器 填入服务器地址与端口号 12服务器：127.0.0.1端口：8080 3、根据提示重启网易云运行前： 运行后： 发现没有之前没有版权的歌又可以听了！而且有些会员歌曲也可以听 注意：软件需一直处于运行状态 ​ 于此同时可以下载歌曲，下载后不再是辣鸡网易云的.cnm格式（只能在网易云上播放），这种格式也可以使用在线转换根据进行转换，我也没有使用过，不知道效果如何 4、服务器部署 当然我也在第一时间想到把这个部署在服务器上这样就可以不用每次都在电脑上后台运行，然而不知道是因为服务器性能太弱还是操作不当使用起来贼慢，附上作者部署教程，各位可进行尝试！","link":"/posts/882e53a2/"},{"title":"树结构的实际应用 - 堆排序","text":"摘要： 堆排序算法 1、堆排序 堆排序的基本思想： 将待排序的序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点 将其与末尾的元素进行交换。此时末尾就为最大值 然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值，如此反复的执行，就能得到一个有序的序列 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.cyfwlp.tree;import java.util.Arrays;public class HeapSort { public static void main(String[] args) { //将数组升序排列 int[] arr = {5,1,9,3,7,4,8,6,2}; /*int[] arr = {4,6,8,5,9};*/ heapSort(arr); System.out.println(Arrays.toString(arr)); } public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序\"); //分布完成/* adjustHeap(arr,1,arr.length); System.out.println(Arrays.toString(arr)); adjustHeap(arr,0,arr.length); System.out.println(Arrays.toString(arr));*/ //构建大顶堆 for (int i = arr.length /2 - 1; i &gt;= 0 ; i--) { adjustHeap(arr,i,arr.length); } System.out.println(Arrays.toString(arr)); for (int j = arr.length-1; j &gt; 0 ; j--) { //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr,0,j); } } /** * 将一个数组构造成一个大顶堆 * @param arr 待调整的数组 * @param i 表示非叶子节点的在数组中的索引 * @param length 表示对多少个元素进行跳转，length 是在逐渐的减少 */ public static void adjustHeap(int arr[],int i,int length) { int temp = arr[i]; //取出当前元素的值保存在临时变量temp //调整 // k = i * 2 + 1 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) { if (k+1 &lt; length &amp;&amp; arr[k] &lt; arr[k+1]) { k++;// } if (arr[k] &gt; temp) { arr[i] = arr[k]; //较大的值赋给当前节点 i = k; //i指向k,继续循环比较 } else { break;// ?? } } //for循环结束，已经将以i为根节点的数的最大值放在了最顶上 arr[i] = temp; //将temp放在调整后的位置 System.out.println(\"此次调整结果\" + Arrays.toString(arr)); }}","link":"/posts/42e4af02/"},{"title":"稀疏数组和队列","text":"摘要： 稀疏数组和队列 稀疏数组和队列稀疏数组当一个数组大部分元素为0，或者为同一个值时，可以使用稀疏数组来保存该数组 稀疏数组的处理方法是 第一行记录数组一共有几行几列，有多少个不同的值 把具有不同值得元素行列以及值记录在另一个小规模的数组中，从而缩小程序的规模 稀疏数组的应用实例 使用稀疏数组，来保留二维数组 稀疏数组转为二维数组 课后练习:将数据保存到磁盘上，再从磁盘读取 package com.cyfwlp.sparsearray; public class SparseArray { public static void main(String[] args) { //创建原始的二维数组 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; //输出原始的二维数组 System.out.println(“原始的二维数组”); for (int[] ints : chessArr1) { for (int anInt : ints) { System.out.printf(“%d\\t”,anInt); } System.out.println(); } //遍历二维数组，得到有效数组个数和坐标 int sum = 0; for (int[] ints : chessArr1) { for (int anInt : ints) { if(anInt != 0){ sum ++; } } } //创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; //遍历二维数组，将非零的值存放到稀疏数组中 int count = 0;//用于记录是第几个数据 for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (chessArr1[i][j] != 0){ count ++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; } } } //输出稀疏数组 System.out.println(“稀疏数组为”); for (int[] ints : sparseArr) { for (int anInt : ints) { System.out.printf(“%d\\t”,anInt); } System.out.println(); } //将稀疏数组恢复成原始二维数组 int chessArr2\\[\\]\\[\\] = new int\\[sparseArr\\[0\\]\\[0\\]\\]\\[sparseArr\\[0\\]\\[1\\]\\]; for (int i = 1; i &lt; sparseArr.length; i++) { chessArr2\\[sparseArr\\[i\\]\\[0\\]\\]\\[sparseArr\\[i\\]\\[1\\]\\] = sparseArr\\[i\\]\\[2\\]; } System.out.println(&quot;恢复后的二维数组&quot;); for (int\\[\\] ints : chessArr2) { for (int anInt : ints) { System.out.printf(&quot;%d\\\\t&quot;,anInt); } System.out.println(); } }} 队列队列介绍 队列是一个有序列表，可以用数组或链表实现 遵循先入先出的原则 数组模拟队列需要两个变量real和front记录队头队尾的坐标 代码实现 package com.cyfwlp.queue;import java.util.Scanner; /** * 数组模拟队列 */public class ArrayQueueDemo { public static void main(String[] args) { //创建队列 ArrayQueue arrayQueue = new ArrayQueue(3); char key = ‘ ‘;//接受用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop){ System.out.println(“s(show):显示队列”); System.out.println(“e(exit):退出程序”); System.out.println(“a(add):添加数据到队列”); System.out.println(“g(get):从队头取出数据”); System.out.println(“h(head):查看队头的数据”); key = scanner.next().charAt(0); switch (key){ case ‘s’: arrayQueue.showQueue(); break; case ‘a’: System.out.println(“输入数据”); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case ‘g’: try { int result = arrayQueue.getQueue(); System.out.println(“取出的数据是 “ + result); } catch (Exception e) { e.printStackTrace(); } break; case ‘h’: try { int head = arrayQueue.headQueue(); System.out.println(“队头的数据是” + head); break; } catch (Exception e) { e.printStackTrace(); } case ‘e’: scanner.close(); loop = false; break; } } System.out.println(“程序退出”); }} //编写一个叫ArrayQueueclass ArrayQueue{ private int maxSize;//表示数组的最大容量 private int front;//队列头 private int real;//队列尾 private int\\[\\] arr;//用于存放数据 //创建队列的构造器 public ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int\\[maxSize\\]; front = -1;//指向队列头的前一个位置 real = -1;//指向队列尾的位置 } //判断队列是否满 public boolean isFull(){ return real == maxSize -1; } //判断队列是否为空 public boolean isEmpty(){ return real == front; } //添加数据到队列 public void addQueue(int n){ //判断是否满 if(isFull()){ System.out.println(&quot;队列不能加入数据&quot;); return; } real ++; arr\\[real\\] = n; } //数据出队列 public int getQueue(){ if(isEmpty()){ //通过抛出异常来处理 throw new RuntimeException(&quot;队列空，不能取数据&quot;); } front ++; return arr\\[front\\]; } //显示队列的所有数据 public void showQueue(){ if(isEmpty()){ System.out.println(&quot;队列为空&quot;); return; } for (int i = 0;i &lt; arr.length;i++) { System.out.printf(&quot;arr\\[%d\\]=%d\\\\n&quot;,i,arr\\[i\\]); } } //显示队列的头数据（不是取出数据） public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;队列为空&quot;); } return arr\\[front + 1\\]; }} 问题分析： 数组使用一次不能用，没有达到复用的效果 将这个数组改进为环形数组（核心 %） 数组模拟环形队列思路分析 front变量的含义进行调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素 real变量的含义进行调整：real指向队列的最后一个元素的后一个位置，空出一个空间作为约定 front的初始值=0，real的初始值=0 当队列满时，条件是 (real + 1) % maxSize = front 【满】 当队列为空的条件，real = front 【空】 当我们这样分析后，队列中有效的数据个数 (real + maxSize - front) % maxSize 就可以在原来的队列上修改，得到一个环形队列 代码实现 package com.cyfwlp.queue;import java.util.Scanner; /** * 数组模拟环形队列 */public class CircleArrayQueueDemo { public static void main(String[] args) { //创建队列 CircleArrayQueue arrayQueue = new CircleArrayQueue(4); char key = ‘ ‘;//接受用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; while (loop){ System.out.println(“s(show):显示队列”); System.out.println(“e(exit):退出程序”); System.out.println(“a(add):添加数据到队列”); System.out.println(“g(get):从队头取出数据”); System.out.println(“h(head):查看队头的数据”); key = scanner.next().charAt(0); switch (key){ case ‘s’: arrayQueue.showQueue(); break; case ‘a’: System.out.println(“输入数据”); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case ‘g’: try { int result = arrayQueue.getQueue(); System.out.println(“取出的数据是 “ + result); } catch (Exception e) { e.printStackTrace(); } break; case ‘h’: try { int head = arrayQueue.headQueue(); System.out.println(“队头的数据是” + head); break; } catch (Exception e) { e.printStackTrace(); } case ‘e’: scanner.close(); loop = false; break; } } System.out.println(“程序退出”); }} //编写一个叫ArrayQueueclass CircleArrayQueue{ private int maxSize;//表示数组的最大容量 private int front;//队列头 private int real;//队列尾 private int\\[\\] arr;//用于存放数据 //创建队列的构造器 public CircleArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int\\[maxSize\\]; front = 0;//指向队列头位置 real = 0;//指向队列尾的的前一个位置 } //判断队列是否满 public boolean isFull(){ return (real + 1) % maxSize == front; } //判断队列是否为空 public boolean isEmpty(){ return real == front; } //添加数据到队列 public void addQueue(int n){ //判断是否满 if(isFull()){ System.out.println(&quot;队列不能加入数据&quot;); return; } //直接加入real arr\\[real\\] = n; //将real指针后移（考虑取模） real = (real + 1) % maxSize; } //数据出队列 public int getQueue(){ if(isEmpty()){ //通过抛出异常来处理 throw new RuntimeException(&quot;队列空，不能取数据&quot;); } int value = arr\\[front\\]; front = (front + 1) % maxSize; return value; } //显示队列的所有数据 public void showQueue(){ if(isEmpty()){ System.out.println(&quot;队列为空&quot;); return; } //从front开始遍历，遍历\\[\\]个元素 for (int i = front;i &lt; front + size();i ++) { System.out.printf(&quot;arr\\[%d\\]=%d\\\\n&quot;,i % maxSize,arr\\[i % maxSize\\]); } } //求出当前队列有效数组的个数 public int size(){ return (real + maxSize - front) % maxSize; } //显示队列的头数据（不是取出数据） public int headQueue(){ if(isEmpty()){ throw new RuntimeException(&quot;队列为空&quot;); } return arr\\[front\\]; }}","link":"/posts/6d016bf8/"},{"title":"谷粒学院开发day02","text":"摘要： swagger接口测试 统一返回结果与统一异常处理 1、前后端分离开发 2、数据库设计规约以下规约只针对本模块，更全面的文档参考《阿里巴巴Java开发手册》：五、MySQL数据库 1、库名与应用名称尽量一致 2、表名、字段名必须使用小写字母或数字，禁止出现数字开头， 3、表名不使用复数名词 4、表的命名最好是加上“业务名称_表的作用”。如，edu_teacher 5、表必备三字段：id, gmt_create, gmt_modified 说明： 其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。 （如果使用分库分表集群部署，则id类型为verchar，非自增，业务中使用分布式id生成器） gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。 6、单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 7、表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。 说明：任何字段如果为非负数，必须是 unsigned。 注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 8、小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 9、如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 10、varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。 11、唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：uk_ 即 unique key；idx_ 即 index 的简称 12、不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 3、创建项目结构——父工程 1、创建springboot项目 guli_parent 2、删除src目录 3、配置pom.xml 修改版本为 ：2.2.1.RELEASE 1&lt;version&gt;2.2.1.RELEASE&lt;/version&gt; 节点后面添加 pom类型 12&lt;artifactId&gt;guli_parent&lt;/artifactId&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 删除pom.xml中的****&lt;dependencies&gt;内容 123456789101112&lt;!-- 以下内容删除 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加 确定依赖的版本 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;guli.version&gt;0.0.1-SNAPSHOT&lt;/guli.version&gt; &lt;mybatis-plus.version&gt;3.0.5&lt;/mybatis-plus.version&gt; &lt;velocity.version&gt;2.0&lt;/velocity.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;aliyun.oss.version&gt;2.8.3&lt;/aliyun.oss.version&gt; &lt;jodatime.version&gt;2.10.1&lt;/jodatime.version&gt; &lt;poi.version&gt;3.17&lt;/poi.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;2.6&lt;/commons-io.version&gt; &lt;httpclient.version&gt;4.5.1&lt;/httpclient.version&gt; &lt;jwt.version&gt;0.7.0&lt;/jwt.version&gt; &lt;aliyun-java-sdk-core.version&gt;4.3.3&lt;/aliyun-java-sdk-core.version&gt; &lt;aliyun-sdk-oss.version&gt;3.1.0&lt;/aliyun-sdk-oss.version&gt; &lt;aliyun-java-sdk-vod.version&gt;2.15.2&lt;/aliyun-java-sdk-vod.version&gt; &lt;aliyun-java-vod-upload.version&gt;1.4.11&lt;/aliyun-java-vod-upload.version&gt; &lt;aliyun-sdk-vod-upload.version&gt;1.4.11&lt;/aliyun-sdk-vod-upload.version&gt; &lt;fastjson.version&gt;1.2.28&lt;/fastjson.version&gt; &lt;gson.version&gt;2.8.2&lt;/gson.version&gt; &lt;json.version&gt;20170516&lt;/json.version&gt; &lt;commons-dbutils.version&gt;1.7&lt;/commons-dbutils.version&gt; &lt;canal.client.version&gt;1.1.0&lt;/canal.client.version&gt; &lt;docker.image.prefix&gt;zx&lt;/docker.image.prefix&gt; &lt;cloud-alibaba.version&gt;0.2.2.RELEASE&lt;/cloud-alibaba.version&gt;&lt;/properties&gt; 配置 锁定依赖的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;${cloud-alibaba.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus 持久层--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis-plus.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;${velocity.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;${swagger.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger ui--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;${swagger.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyunOSS--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;${aliyun.oss.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期时间工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;${jodatime.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;${commons-fileupload.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;${commons-io.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;${httpclient.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;${gson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JWT --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;${jwt.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--aliyun--&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;${aliyun-java-sdk-core.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;${aliyun-sdk-oss.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt; &lt;version&gt;${aliyun-java-sdk-vod.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-vod-upload&lt;/artifactId&gt; &lt;version&gt;${aliyun-java-vod-upload.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt; &lt;version&gt;${aliyun-sdk-vod-upload.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;${fastjson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;${json.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;${commons-dbutils.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt; &lt;artifactId&gt;canal.client&lt;/artifactId&gt; &lt;version&gt;${canal.client.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 4、创建项目结构——service模块1、创建maven项目 service 2、 节点后面添加 pom类型 12&lt;artifactId&gt;service&lt;/artifactId&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 3、删除src 4、添加项目所需要的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务注册--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--xls--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--httpclient--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--commons-io--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--gson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5、在service下再创建maven子模块 完成创建后的项目目录结构 5、开发讲师管理模块1、创建application.properties配置文件 1234567891011121314151617# 服务端口server.port=8001# 服务名 (spring-cloud用到)spring.application.name=service-edu# 环境设置：dev、test、prodspring.profiles.active=dev# mysql数据库连接spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?spring.datasource.username=rootspring.datasource.password=123456#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 2、编写controller service mapper 代码内容 mp提供代码生成器，生成相关代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class CodeGenerator { @Test public void run() { // 1、创建代码生成器 AutoGenerator mpg = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); /*String projectPath = System.getProperty(\"user.dir\");*/ //推荐使用绝对路径 gc.setOutputDir(\"G:\\\\idea_project\\\\gulixueyuan\\\\guli_parent\\\\service\\\\service_edu\" + \"/src/main/java\"); gc.setAuthor(\"liaotao\"); gc.setOpen(false); //生成后是否打开资源管理器 gc.setFileOverride(false); //重新生成时文件是否覆盖 gc.setServiceName(\"%sService\"); //去掉Service接口的首字母I gc.setIdType(IdType.ID_WORKER); //主键策略 gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型 gc.setSwagger2(true);//开启Swagger2模式 mpg.setGlobalConfig(gc); // 3、数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/guli\"); dsc.setDriverName(\"com.mysql.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"eduservice\"); //模块名 pc.setParent(\"com.cyfwlp\"); //生成 com.cyfwlp.eduservice pc.setController(\"controller\"); pc.setEntity(\"entity\"); pc.setService(\"service\"); pc.setMapper(\"mapper\"); mpg.setPackageInfo(pc); // 5、策略配置 StrategyConfig strategy = new StrategyConfig(); //加表的名称 strategy.setInclude(\"edu_teacher\"); strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + \"_\"); //生成实体时去掉表前缀 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); // 6、执行 mpg.execute(); }} 3、编写controller 123456789101112131415@RestController@RequestMapping(\"/eduservice/teacher\")public class EduTeacherController { //注入service @Autowired private EduTeacherService teacherService; //1.查询讲师表中的所有数据 //rest风格 @GetMapping(\"/findAll\") public List&lt;EduTeacher&gt; findAllTeacher() { return teacherService.list(null); }} 4、编写springboot启动类 123456@SpringBootApplicationpublic class EduApplication { public static void main(String[] args) { SpringApplication.run(EduApplication.class, args); }} 5、编写配置类 12345@Configuration@MapperScan(\"com.cyfwlp.eduservice.mapper\")public class EduConfig {} 6、统一返回的json时间格式 123#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8 6、整合swagger进行接口测试前后端分离开发模式中，api文档是最好的沟通方式。 Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 及时性 (接口变更后，能够及时准确地通知相关前后端开发人员) 规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息) 一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧) 可测性 (直接在接口文档上进行测试，以方便理解业务) 1、guli_parent下建立子模块common，common再创建子模块service_base common引入相关依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;scope&gt;provided &lt;/scope&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring2.X集成redis所需common-pool2 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt; 2、在模块service-base中，创建swagger的配置类 1234567891011121314151617181920212223242526@Configuration@EnableSwagger2 //public class SwaggerConfig { @Bean public Docket webApiConfig(){ return new Docket(DocumentationType.SWAGGER_2) .groupName(\"webApi\") .apiInfo(webApiInfo()) .select() .paths(Predicates.not(PathSelectors.regex(\"/admin/.*\"))) .paths(Predicates.not(PathSelectors.regex(\"/error.*\"))) .build(); } private ApiInfo webApiInfo(){ return new ApiInfoBuilder() .title(\"网站-课程中心API文档\") .description(\"本文档描述了课程中心微服务接口定义\") .version(\"1.0\") .contact(new Contact(\"Helen\", \"http://atguigu.com\", \"55317332@qq.com\")) .build(); }} 3、service_edu引入service_base 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.cyfwlp&lt;/groupId&gt; &lt;artifactId&gt;service_base&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4、启动类添加 @ComponentScan注解，设置包扫描的规则 1234567@SpringBootApplication@ComponentScan(basePackages = {\"com.cyfwlp\"})public class EduApplication { public static void main(String[] args) { SpringApplication.run(EduApplication.class, args); }} 5、访问swagger http://localhost:8002/swagger-ui.html/ 参数说明 定义在类上：@Api 定义在方法上：@ApiOperation 定义在参数上：@ApiParam 12345678910111213141516171819202122@Api(description=\"讲师管理\")@RestController@RequestMapping(\"/admin/edu/teacher\")public class TeacherAdminController { @Autowired private TeacherService teacherService; @ApiOperation(value = \"所有讲师列表\") @GetMapping public List&lt;Teacher&gt; list(){ return teacherService.list(null); } @ApiOperation(value = \"根据ID删除讲师\") @DeleteMapping(\"{id}\") public boolean removeById( @ApiParam(name = \"id\", value = \"讲师ID\", required = true) @PathVariable String id){ return teacherService.removeById(id); }} 7、统一返回数据格式项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容 例如，我们的系统要求返回的基本数据格式如下： 列表： 1234567891011121314{ \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": { \"items\": [ { \"id\": \"1\", \"name\": \"刘德华\", \"intro\": \"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余\" } ] }} 分页： 123456789101112131415{ \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": { \"total\": 17, \"rows\": [ { \"id\": \"1\", \"name\": \"刘德华\", \"intro\": \"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余\" } ] }} 没有返回数据： 123456{ \"success\": true, \"code\": 20000, \"message\": \"成功\", \"data\": {}} 失败： 123456{ \"success\": false, \"code\": 20001, \"message\": \"失败\", \"data\": {}} 因此，我们定义统一结果 123456{ \"success\": 布尔, //响应是否成功 \"code\": 数字, //响应码 \"message\": 字符串, //返回消息 \"data\": HashMap //返回数据，放在键值对中} 1、在common模块创建子模块 common_utils 2、创建interface，定义数据返回状态码 （或者使用枚举类） 成功 20000 失败 20001 12345public interface ResultCode { public static Integer SUCCESS = 20000; //成功 public static Integer ERROR = 20001; //失败} 3、定义返回的数据格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Datapublic class R { @ApiModelProperty(value = \"是否成功\") private Boolean success; @ApiModelProperty(value = \"返回码\") private Integer code; @ApiModelProperty(value = \"返回消息\") private String message; @ApiModelProperty(value = \"返回数据\") private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); //构造方法私有化 private R(){} public static R ok() { R r = new R(); r.setSuccess(true); r.setCode(ResultCode.SUCCESS); r.setMessage(\"成功\"); return r; } public static R error() { R r = new R(); r.setSuccess(false); r.setCode(ResultCode.ERROR); r.setMessage(\"失败\"); return r; } public R success(Boolean success){ this.setSuccess(success); return this; } public R message(String message){ this.setMessage(message); return this; } public R code(Integer code){ this.setCode(code); return this; } public R data(String key, Object value){ this.data.put(key, value); return this; } public R data(Map&lt;String, Object&gt; map){ this.setData(map); return this; }} 4、使用方式 1234567@ApiOperation(value = \"所有讲师列表\")@GetMapping(\"/findAll\")public R findAllTeacher() { List&lt;EduTeacher&gt; list = teacherService.list(null); //链式编程 return R.ok().data(\"items\",list);} 8、全局异常处理在service-base中创建统一异常处理类GlobalExceptionHandler.java： 1234567891011@ControllerAdvicepublic class GlobalExceptionHandler { // 指定出现什么异常执行这个方法 @ResponseBody //为了返回数据 @ExceptionHandler(Exception.class) public R error(Exception e) { e.printStackTrace(); return R.error().message(\"执行了全局异常处理..\"); }}","link":"/posts/359b46c9/"},{"title":"谷粒学院开发day03","text":"摘要： es6 vue入门 一、特定异常处理捕获 ArithmeticException 并处理 在GlobalExceptionHandler 添加以下方法 123456//特定异常处理@ExceptionHandler(ArithmeticException.class)public R error(ArithmeticException e) { e.printStackTrace(); return R.error().message(\"执行了ArithmeticException异常处理..\");} 二、自定义异常处理1、创建自定义异常类，继承RuntimeException， 写异常属性 123456789@Data@AllArgsConstructor //生成有参数的构造方法@NoArgsConstructor //生成无参数的构造方法public class GuliException extends RuntimeException { private Integer code; //状态码 private String msg; //信息} 2、在GlobalExceptionHandler 添加以下方法 123456//自定义异常处理@ExceptionHandler(GuliException.class)public R error(GuliException e) { e.printStackTrace(); return R.error().code(e.getCode()).message(e.getMessage());} 3、执行自定义异常 12345try { int i = 10/0;} catch (Exception e) { throw new GuliException(20001,\"执行了自定义异常处理\");} 三、统一日志处理1、配置日志级别 日志记录器（Logger）的行为是分等级的。如下表所示： 分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别 12# 设置日志级别logging.level.root=INFO 这种方式只能将日志打印在控制台上 2、Logback日志配置 spring boot内部使用Logback作为日志实现的框架 （1）删除application.properties中的日志配置 12#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl （2）resources创建 logback-spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt; &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt; &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt; &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --&gt; &lt;property name=&quot;log.path&quot; value=&quot;D:/guli_log/edu&quot; /&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;!-- boldMagenta:粗红--&gt; &lt;!-- cyan:青色 --&gt; &lt;!-- white:白色 --&gt; &lt;!-- magenta:洋红 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight(%-5level) %blue(%thread) %blue(%file:%line) %green(%logger) %cyan(%msg%n)&quot;/&gt; &lt;!--输出到控制台--&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;Pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/Pattern&gt; &lt;!-- 设置字符集 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;${log.path}/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 每天日志归档路径以及格式 --&gt; &lt;fileNamePattern&gt;${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;${log.path}/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;${log.path}/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。 &lt;logger&gt;仅有一个name属性， 一个可选的level和一个可选的addtivity属性。 name:用来指定受此logger约束的某一个包或者具体的某一个类。 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF， 如果未设置此属性，那么当前logger将会继承上级的级别。 --&gt; &lt;!-- 使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作： 第一种把&lt;root level=&quot;INFO&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息 第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别： --&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt; &lt;logger name=&quot;com.guli&quot; level=&quot;INFO&quot; /&gt; &lt;!-- root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性 level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG 可以包含零个或多个appender元素。 --&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=&quot;pro&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 3、异常信息输出到文件 （1）全局异常处理类加注解 @Slf4j 12@Slf4jpublic class GlobalExceptionHandler { （2）异常输出语句 1log.error(e.getMsg()); 4、将日志堆栈信息输出到文件 定义工具类 guli-framework-common下创建util包，创建ExceptionUtil.java工具类 123456789101112131415161718192021222324252627package com.guli.common.util;public class ExceptionUtil { public static String getMessage(Exception e) { StringWriter sw = null; PrintWriter pw = null; try { sw = new StringWriter(); pw = new PrintWriter(sw); // 将出错的栈信息输出到printWriter中 e.printStackTrace(pw); pw.flush(); sw.flush(); } finally { if (sw != null) { try { sw.close(); } catch (IOException e1) { e1.printStackTrace(); } } if (pw != null) { pw.close(); } } return sw.toString(); }} 调用 1log.error(ExceptionUtil.getMessage(e)); GuliException中创建toString方法 1234567@Overridepublic String toString() { return \"GuliException{\" + \"message=\" + this.getMessage() + \", code=\" + code + '}';} 四、前端开发1、vscode创建工作区 （1）创建空文件夹 （2）使用vscode打开创建的空文件夹 （3）把文件夹保存为工作区 五、ES6 入门 六、vue入门vue入门1 vue入门2 1、抽取vue代码片段 1234567891011121314151617181920212223242526272829303132333435{ &quot;vue htm&quot;: { &quot;scope&quot;: &quot;html&quot;, &quot;prefix&quot;: &quot;vuehtml&quot;, &quot;body&quot;: [ &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html lang=\\&quot;en\\&quot;&gt;&quot;, &quot;&quot;, &quot;&lt;head&gt;&quot;, &quot; &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&quot;, &quot; &lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width, initial-scale=1.0\\&quot;&gt;&quot;, &quot; &lt;meta http-equiv=\\&quot;X-UA-Compatible\\&quot; content=\\&quot;ie=edge\\&quot;&gt;&quot;, &quot; &lt;title&gt;Document&lt;/title&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&quot;, &quot;&lt;body&gt;&quot;, &quot; &lt;div id=\\&quot;app\\&quot;&gt;&quot;, &quot;&quot;, &quot; &lt;/div&gt;&quot;, &quot; &lt;script src=\\&quot;vue.min.js\\&quot;&gt;&lt;/script&gt;&quot;, &quot; &lt;script&gt;&quot;, &quot; new Vue({&quot;, &quot; el: '#app',&quot;, &quot; data: {&quot;, &quot; $1&quot;, &quot; }&quot;, &quot; })&quot;, &quot; &lt;/script&gt;&quot;, &quot;&lt;/body&gt;&quot;, &quot;&quot;, &quot;&lt;/html&gt;&quot;, ], &quot;description&quot;: &quot;my vue template in html&quot; }} 七、vue组件组件（Component）是 Vue.js 最强大的功能之一。 组件可以扩展 HTML 元素，封装可重用的代码。 组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树： 1、局部组件 定义组件 1234567891011var app = new Vue({ el: '#app', // 定义局部组件，这里可以定义多个局部组件 components: { //组件的名字 'Navbar': { //组件的内容 template: '&lt;ul&gt;&lt;li&gt;首页&lt;/li&gt;&lt;li&gt;学员管理&lt;/li&gt;&lt;/ul&gt;' } }}) 使用组件 123&lt;div id=&quot;app&quot;&gt; &lt;Navbar&gt;&lt;/Navbar&gt;&lt;/div&gt; 2、全局组件 定义全局组件：components/Navbar.js 1234// 定义全局组件Vue.component('Navbar', { template: '&lt;ul&gt;&lt;li&gt;首页&lt;/li&gt;&lt;li&gt;学员管理&lt;/li&gt;&lt;li&gt;讲师管理&lt;/li&gt;&lt;/ul&gt;'}) 12345678910&lt;div id=&quot;app&quot;&gt; &lt;Navbar&gt;&lt;/Navbar&gt;&lt;/div&gt;&lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;components/Navbar.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue({ el: '#app' })&lt;/script&gt; 3、实例的生命周期 重点使用： before monted 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#app', data: { }, //页面渲染之前执行 created(){ //断点 debugger console.log(&quot;created&quot;); }, //页面渲染之后执行 mounted(){ debugger console.log(&quot;monted&quot;); } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 八、vue路由Vue.js 路由允许我们通过不同的 URL 访问不同的内容。 通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。 Vue.js 路由需要载入 vue-router 库 1、引入js 12&lt;script src=\"vue.min.js\"&gt;&lt;/script&gt;&lt;script src=\"vue-router.min.js\"&gt;&lt;/script&gt; 2、编写html 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/student&quot;&gt;会员管理&lt;/router-link&gt; &lt;router-link to=&quot;/teacher&quot;&gt;讲师管理&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 3、编写js 1234567891011121314151617181920212223242526272829&lt;script&gt; // 1. 定义（路由）组件。 // 可以从其他文件 import 进来 const Welcome = { template: '&lt;div&gt;欢迎&lt;/div&gt;' } const Student = { template: '&lt;div&gt;student list&lt;/div&gt;' } const Teacher = { template: '&lt;div&gt;teacher list&lt;/div&gt;' } // 2. 定义路由 // 每个路由应该映射一个组件。 const routes = [ { path: '/', redirect: '/welcome' }, //设置默认指向的路径 { path: '/welcome', component: Welcome }, { path: '/student', component: Student }, { path: '/teacher', component: Teacher } ] // 3. 创建 router 实例，然后传 `routes` 配置 const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) // 4. 创建和挂载根实例。 // 从而让整个应用都有路由功能 const app = new Vue({ el: '#app', router }) // 现在，应用已经启动了！&lt;/script&gt;","link":"/posts/429c765f/"},{"title":"谷粒学院开发day05","text":"摘要： 滑水的一天 一、零碎知识1、好像没什么需要记的，水一篇把 滑稽.jpg","link":"/posts/abffd36a/"},{"title":"谷粒学院开发day04","text":"摘要： node.js、elementui 一、axios1、跨域问题1、什么是跨域 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 。前后端分离开发中，需要考虑ajax跨域的问题。 这里我们可以从服务端解决这个问题 2、配置 在Controller类上添加注解 1@CrossOrigin //跨域 2、axiosaxios是独立于vue的一个项目，基于promise用于浏览器和node.js的http客户端 在浏览器中可以帮助我们完成 ajax请求的发送 在node.js中可以向远程接口发送请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(item,index) in userList&quot;&gt;{{item}}}&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#app', //固定结构 data: { //data定义变量和初始值 userList:[] }, created(){ //调用定义的方法 this.getuserList(); }, methods:{//编写具体的方法 //创建方法 查询所有用户数据 getuserList() { //使用axiox发送ajax请求 axios.get(&quot;http://localhost:8002/eduservice/teacher/findAll&quot;) //请求成功执行then方法 .then(response =&gt; { // console.log(response.data.data.items); // 数据复制给data定义的数组 this.userList = response.data.data.items console.log(this.userList); }) //请求失败实现catch方法 .catch(error =&gt; { console.log(error); }) } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、element-uielement-ui 是饿了么前端出品的基于 Vue.js的 后台组件库，方便程序员进行页面快速布局和构建 官网： http://element-cn.eleme.io/#/zh-CN 三、Node.js1、node.js是什么简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好 2、nodejs作用 JavaScript的运行环境，用于执行JavaScript环境，不需要浏览器，直接使用nodejs运行JavaScript代码 模拟服务器效果 3、vscode打开cmd窗口 4、服务器端应用开发（了解）创建 02-server-app.js 1234567891011const http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 \"Hello World\" response.end('Hello Server');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 运行服务器程序 1node 02-server-app.js 服务器启动成功后，在浏览器中输入：http://localhost:8888/ 查看webserver成功运行，并输出html页面 停止服务：ctrl + c 四、npm1、npm是什么NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 2、npm具体操作（1）项目初始化 使用命令 npm init （使用默认配置 nmp init -y） 项目初始化之后，生成文件package.json 相当于后端pom.xml （2）下载js依赖 设置镜像地址 1234#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载npm config set registry https://registry.npm.taobao.org #查看npm配置信息npm config list 命令 npm install xxx 1npm install jquery 指定版本 12#如果安装时想指定特定的版本npm install jquery@2.1.x （3）根据配置文件下载依赖 1npm install 五、bable1、bable是什么转码器 把es6的代码转换成es5的代码 实际开发 编写es6代码转换成es5运行 2、bable使用1、安装 123npm install --global babel-cli#查看是否安装成功babel --version 2、编写es6代码 123456// 转码前// 定义数据let input = [1, 2, 3]// 将数组的每个元素 +1input = input.map(item =&gt; item + 1)console.log(input) 3、根目录下配置.babelrc 1234{ \"presets\": [\"es2015\"], \"plugins\": []} 4、安装es2015的转码器 1npm install --save-dev babel-preset-es2015 5、使用命令进行转码 （1）根据文件转码 1babel es6/01.js -o dist/001.js （2）根据文件夹转码 1babel es6 -d dist 六、模块化1、模块化是什么在前端中，js与js之间调用称为模块化 2、es5模块化01.js 代码 1234567891011121314// 01.js创建js方法// 定义成员：const sum = function(a,b){ return parseInt(a) + parseInt(b)}const sub = function(a,b){ return parseInt(a) - parseInt(b)}//设置哪些方法可以被调用// 导出成员：module.exports = { sum: sum, sub: sub,} 02.js 代码 1234567// 02.js调用01.js方法// 引入01.js文件const m = equire('./01.js');//调用console.log(m.sum(1,2));console.log(m.sub(10,4)); 3.1、es6模块化（1）01.js 代码 1234567// 定义方法 设置哪些方法可以被其他的js调用export function getList() { console.log('getList');}export function save() { console.log('save');} 02.js 代码 12345// 调用01.js方法 引入01.js 调用import {getList,save} from './01.js'//调用方法getList();save(); 注意：这时的程序无法运行的，因为ES6的模块化无法在Node.js中执行，需要用Babel编辑成ES5后再执行。 转换es5即可运行 3.2、es6模块化（2）01.js 代码 123456789// 定义方法 设置哪些方法可以被其他的js调用export default{ getList() { console.log('getList'); }, update() { console.log('update'); }} 02.js 代码 123456// 调用01.js方法 引入01.js 调用import m from './01.js'//调用方法m.getList;m.update; 同样需要转化为es5在node.js运行 七、webpack1、webpack是什么Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 2、webpack安装1234# 全局安装npm install -g webpack webpack-cli#查看版本webpack -v 3、webpack打包js文件src/common.js 123exports.info = function (str) { document.write(str);} src/utils.js 123exports.add = function (a, b) { return a + b;} src/main.js 1234const common = require('./common,js');const utils = require('./utils');common.info('hello 123' + utils.add(1,2)); 创建webpack配置文件，配置打包信息 webpack.config.js 12345678const path = require(\"path\"); //Node.js内置模块module.exports = { entry: './src/main.js', //配置入口文件 output: { path: path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径 filename: 'bundle.js' //输出文件 }} 使用命令执行打包操作 123webpack #有黄色警告webpack --mode=development #没有警告#执行后查看bundle.js 里面包含了上面两个js文件的内容并惊醒了代码压缩 4、webpack打包css文件style.css 123body { background-color: red;} main.js引入 1require('./style.css'); 安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 Loader 可以理解为是模块和资源的转换器。 首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css 1npm install --save-dev style-loader css-loader 修改webpack.config.js 12345678910111213const path = require(\"path\"); //Node.js内置模块module.exports = { //..., output:{}, module: { rules: [ { test: /\\.css$/, //打包规则应用到以css结尾的文件上 use: ['style-loader', 'css-loader'] } ] }} 八、搭建项目前端环境1、vue-admin-templatevue-element-admin是基于element-ui 的一套后台管理系统集成方案。 功能：https://panjiachen.github.io/vue-element-admin-site/zh/guide/#功能 GitHub地址：https://github.com/PanJiaChen/vue-element-admin 项目在线预览：https://panjiachen.gitee.io/vue-element-admin 2、安装1234567# 解压压缩包# 进入目录cd vue-element-admin-master# 安装依赖npm install# 启动。执行后，浏览器自动弹出并访问http://localhost:9527/npm run dev 3、项目基本结构 1234567. ├── build // 构建脚本├── config // 全局配置 ├── node_modules // 项目依赖模块├── src //项目源代码├── static // 静态资源└── package.jspon // 项目信息和依赖配置 12345678910111213src ├── api // 各种接口 ├── assets // 图片等资源 ├── components // 各种公共组件，非公共组件在各自view下维护 ├── icons //svg icon ├── router // 路由表 ├── store // 存储 ├── styles // 各种样式 ├── utils // 公共工具，非公共工具，在各自view下维护 ├── views // 各种layout├── App.vue //***项目顶层组件*** ├── main.js //***项目入口文件***└── permission.js //认证入口","link":"/posts/dcf8e3fc/"},{"title":"谷粒学院开发day06","text":"摘要： 阿里云oss nginx easyExcel 一、阿里云oss存储服务前置准备： 获取操作阿里云oss许可证 Accesskey 官网创建就行 官方文档 参照官方文档使用难度不大 二、nginxnginx : 高性能的HTTP和反向代理web服务器 nginx主要使用： 请求转发 负载均衡 动静分离 项目中使用请求转发，根据请求路径转发到不同的服务 nginx 结束命令 (windows) 1nginx.exe -s stop 修改配置文件，在http{}里添加 12345678910111213server { listen 9001; server_name localhost; location ~ /eduservice/ { proxy_pass http://localhost:8001; } location ~ /eduoss/ { proxy_pass http://localhost:8002; }} 再启动 三、EasyExcelEasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称。 需要 poi依赖 和 EasyExcel依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--xls--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!--xlsx--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt;&lt;/dependency&gt; 1、Excel写操作 创建Excel对应实体类 12345678910@Datapublic class DemoData { // 设置excel表头名称 @ExcelProperty(\"学生编号\") private Integer sno; @ExcelProperty(\"学生姓名\") private String sname;} 写操作 12345678910111213141516171819202122public class TestEasyExcel { public static void main(String[] args) { //实现Excel写的操作 //1.设置写入文件地址和Excel文件名称 String fileName = \"F:\\\\write.xlsx\"; //2.实现写操作 EasyExcel.write(fileName,DemoData.class).sheet(\"学生列表\").doWrite(getData()); } private static List&lt;DemoData&gt; getData() { ArrayList&lt;DemoData&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { DemoData demoData = new DemoData(); demoData.setSno(i); demoData.setSname(\"jack\" + i); list.add(demoData); } return list; }} 2、Excel读操作 创建对应实体类 12345678910@Datapublic class DemoData { // 设置excel表头名称 @ExcelProperty(value = \"学生编号\",index = 0) private Integer sno; @ExcelProperty(value = \"学生姓名\",index = 1) private String sname;} 创建监听进行Excel文件的读取 123456789101112131415161718192021222324252627282930/** * @Author liaotao * @Date 2020/11/5 16:22 */public class ExcelListener extends AnalysisEventListener&lt;DemoData&gt; { /** * 一行一行的读取Excel内容 * @param demoData * @param analysisContext */ @Override public void invoke(DemoData demoData, AnalysisContext analysisContext) { System.out.println( \"****\" + demoData); } @Override public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) { System.out.println(\"表头\" + headMap); } /** * 读取完成后 * @param analysisContext */ @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { }}","link":"/posts/32f682d0/"},{"title":"正则表达式","text":"摘要： 正则表达式 正则表达式近期在复习jsp考试的时候，需要复习前端表单校验时使用到的正则表达式，之前都是网上找现成的用，不是很理解，现对常用的正则表达式进行学习整理一.概念正则表达式（Regular Expression）是用于描述一组字符串特征的模式，用来匹配特定的字符串。通过特殊字符+普通字符来进行模式描述，从而达到文本匹配目的工具。 二.语法1.普通字符[ABC] 匹配 […] 中的所有字符，例如 [aeiou] 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。 [^ABC] 匹配除了 […] 中字符的所有字符，例如 [^aeiou] 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r]。 [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，包括换行。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 2.特殊字符$ 匹配输入字符串的结尾位置 ^ 匹配输入字符串的开始位置 “*“ 匹配前面的子表达式零次或多次 “+” 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配n 次 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 \\* 和 *+* 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。 3.Jquery的使用123var grade = $(\"#grade\").val();var rep = /^[0-9]*{4}$/rep.test(grade) //匹配返回true，不匹配返回false","link":"/posts/2f57a694/"},{"title":"谷粒学院开发day08","text":"摘要： 富文本编辑器 项目开发 一、富文本编辑器Tinymce是一个传统javascript插件，默认不能用于Vue.js因此需要做一些特殊的整合步骤 1、复制脚本库将脚本库复制到项目的static目录下（在vue-element-admin-master的static路径下） 2、配置html变量在 guli-admin/build/webpack.dev.conf.js 中添加配置 使在html页面中可是使用这里定义的BASE_URL变量 123456new HtmlWebpackPlugin({ ......, templateParameters: { BASE_URL: config.dev.assetsPublicPath + config.dev.assetsSubDirectory }}) 3、引入js脚本在guli-admin/index.html 中引入js脚本 12&lt;script src=&lt;%= BASE_URL %&gt;/tinymce4.7.5/tinymce.min.js&gt;&lt;/script&gt;&lt;script src=&lt;%= BASE_URL %&gt;/tinymce4.7.5/langs/zh_CN.js&gt;&lt;/script&gt; 4、复制组件src/components/Tinymce 5、引入组件课程信息组件中引入 Tinymce 12345import Tinymce from '@/components/Tinymce'export default { components: { Tinymce }, ......} 6、组件模板1234&lt;!-- 课程简介--&gt;&lt;el-form-item label=&quot;课程简介&quot;&gt; &lt;tinymce :height=&quot;300&quot; v-model=&quot;courseInfo.description&quot;/&gt;&lt;/el-form-item&gt; 7、组件样式在info.vue文件的最后添加如下代码，调整上传图片按钮的高度 12345&lt;style scoped&gt;.tinymce-container { line-height: 29px;}&lt;/style&gt; 8、图片的base64编码Tinymce中的图片上传功能直接存储的是图片的base64编码，因此无需图片服务器 二、多表连接查询涉及多张表的查询，多使用手写sql语句实现 1、内连接只查询两张表有关联的数据 2、左外连接左边所有数据，右边有关联数据 3、右外连接右边所有数据，左边有关联数据 123456789SELECT ec.id,ec.price,ec.`lesson_num`, ecd.`description`, et.`name`, es1.`title` AS oneSubject,es2.`title` AS twoSubjectFROM edu_course ec LEFT OUTER JOIN edu_course_description ecd ON ec.`id` = ecd.`id` LEFT OUTER JOIN edu_teacher et ON ec.`teacher_id` = et.`id` LEFT OUTER JOIN edu_subject es1 ON ec.`subject_parent_id` = es1.`id` LEFT OUTER JOIN edu_subject es2 ON ec.`subject_id` = es2.`id` WHERE ec.id = 18; 三、maven加载问题maven在加载的时候，只会将.java文件进行编译 1org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.cyfwlp.eduservice.mapper.EduCourseMapper.getPublishCourse 解决方案： 手动复制目录 将.xml文件放到resources中 推荐使用 通过配置实现 pom.xml配置 123456789101112&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; application.propertie配置 1mybatis-plus.mapper-locations=classpath:com/cyfwlp/eduservice/mapper/xml/*.xml","link":"/posts/d54eafd7/"},{"title":"谷粒学院开发day09","text":"摘要： 阿里云视频点播 一、阿里云视频点播1、基本介绍视频点播（ApsaraVideo for VoD）是集音视频采集、编辑、上传、自动化转码处理、媒体资源管理、分发加速于一体的一站式音视频点播解决方案。 2、API与SDK 3、操作参照 官方文档 数据库中需要存储加密视频 4、手动安装依赖到本地仓库 使用maven命令进行安装 1mvn install:install-file -DgroupId=com.aliyun -DartifactId=aliyun-sdk-vod-upload -Dversion=1.4.11 -Dpackaging=jar -Dfile=aliyun-java-vod-upload-1.4.11.jar 1234567891011121314listen 9001;server_name localhost;location ~ /eduservice/ { proxy_pass http://localhost:8001;}location ~ /eduoss/ { proxy_pass http://localhost:8002;}location ~ /eduvod/ { proxy_pass http://localhost:8003;} 5、跨域问题报错 乍一看是跨域问题，但是后台接口加了注解防止跨域，网上找了各种方法尝试也不行 结果莫名其妙加了配置nginx上传文件大小，离谱的是没有加这个配置并没有老师视频里出现的 413 (Request Entity Too Large) 异常 1client_max_body_size 1024m; 解决问题 难道说不配置nginx上传文件大小会引起跨域，百度试试，但是没有结果好像","link":"/posts/a2499f41/"},{"title":"谷粒学院开发day07","text":"摘要： 返回树形结构数据 项目开发 一、返回树形结构的数据返回这种格式数据 第一步：针对返回数据创建对应的实体类 12345678910111213/** * @Author liaotao * @Date 2020/11/6 15:09 * 一级分类 */@Datapublic class OneSubject { private String id; private String title;} 123456789101112/** * @Author liaotao * @Date 2020/11/6 15:09 * 二级分类 */@Datapublic class TwoSubject { private String id; private String title;} 第二步：在两个实体类之间表示关系（一个一级分类有多个二级分类） 修改一级分类代码 123456789101112131415/** * @Author liaotao * @Date 2020/11/6 15:09 * 一级分类 */@Datapublic class OneSubject { private String id; private String title; private List&lt;TwoSubject&gt; children = new ArrayList&lt;&gt;();} 第三部：编写具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic List&lt;OneSubject&gt; getAllOneTwoSubject() { //1.查询所有一级分类 QueryWrapper&lt;EduSubject&gt; wrapperOne = new QueryWrapper&lt;EduSubject&gt;(); wrapperOne.eq(\"parent_id\",\"0\"); List&lt;EduSubject&gt; oneSubject = baseMapper.selectList(wrapperOne); // 或者自己调自己 //2.查询所有二级分类 QueryWrapper&lt;EduSubject&gt; wrapperTwo = new QueryWrapper&lt;EduSubject&gt;(); wrapperOne.ne(\"parent_id\",\"0\"); List&lt;EduSubject&gt; twoSubject = baseMapper.selectList(wrapperTwo); // 创建list存储最终封装的数据 ArrayList&lt;OneSubject&gt; finalSubjectList = new ArrayList&lt;&gt;(); //3.封装一级分类 // 遍历封装 for (EduSubject eduSubject : oneSubject) { OneSubject subject = new OneSubject(); subject.setId(eduSubject.getId()); subject.setTitle(eduSubject.getTitle()); //获取每个一级分类对应的二级分类、 List&lt;TwoSubject&gt; twoFinalSubjectList = new ArrayList&lt;&gt;(); for (EduSubject eduSubject1 : twoSubject) { //判断二级分类parent_id 和 id if (eduSubject1.getParentId().equals(eduSubject.getId())) { TwoSubject subject1 = new TwoSubject(); subject1.setId(eduSubject1.getId()); subject1.setTitle(eduSubject1.getTitle()); twoFinalSubjectList.add(subject1); } } subject.setChildren(twoFinalSubjectList); finalSubjectList.add(subject); } //4.封装二级分类 return finalSubjectList;} 二、课程添加模块课程相关表直接关系 1、课程添加 细节问题 创建vo类用于表单数据封装 表单提交过来的数据添加到数据库 两张表 edu_couese edu_description 讲师和分类使用下拉列表 课程分类 二级联动 vo类： 123456789101112131415161718192021222324252627282930313233343536373839package com.cyfwlp.eduservice.entity.vo;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.math.BigDecimal;/** * @Author liaotao * @Date 2020/11/8 10:28 */@Datapublic class CourseInfoVo { @ApiModelProperty(value = \"课程ID\") private String id; @ApiModelProperty(value = \"课程讲师ID\") private String teacherId; @ApiModelProperty(value = \"课程专业ID\") private String subjectId; @ApiModelProperty(value = \"课程标题\") private String title; @ApiModelProperty(value = \"课程销售价格，设置为0则可免费观看\") // 0.01 价格不能使用 double 精度问题 private BigDecimal price; @ApiModelProperty(value = \"总课时\") private Integer lessonNum; @ApiModelProperty(value = \"课程封面图片路径\") private String cover; @ApiModelProperty(value = \"课程简介\") private String description;} serviceImpl 12345678910111213141516171819202122//添加课程基本信息的方法@Overridepublic void saveCourseInfo(CourseInfoVo courseInfoVo) { //1.添加到课程信息表 EduCourse eduCourse = new EduCourse(); BeanUtils.copyProperties(courseInfoVo,eduCourse); int insert = baseMapper.insert(eduCourse); if (insert &lt;= 0) { //添加失败 throw new GuliException(20001,\"添加课程信息失败\"); } // 得到添加后的课程id String cid = eduCourse.getId(); //2.添加数据到课程简介表 //需要调用其他service @Autowired EduCourseDescription eduCourseDescription = new EduCourseDescription(); BeanUtils.copyProperties(courseInfoVo,eduCourseDescription); //手动设置表述id为课程id eduCourseDescription.setId(cid); descriptionService.save(eduCourseDescription);} 更多的难点在于element ui的使用，结合官网在项目中灵活运用即可","link":"/posts/45f1b246/"},{"title":"谷粒学院开发day11","text":"摘要： nuxt 项目开发 一、前台环境搭建 NUXT（读音 纳斯特）1、什么是服务端渲染服务端渲染又称SSR (Server Side Render)是在服务端完成页面的内容，而不是在客户端通过AJAX获取数据。 服务器端渲染(SSR)的优势主要在于：更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再进行页面内容的抓取。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 另外，使用服务器端渲染，我们可以获得更快的内容到达时间(time-to-content)，无需等待所有的 JavaScript 都完成下载并执行，产生更好的用户体验，对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。 2、NUXT 项目启动报错：关闭eslintrc 二、redis缓存1、redis简介Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化。 Redis的特点： 1，Redis读取的速度是110000次/s，写的速度是81000次/s； 2，原子 。Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 3，支持多种数据结构：string（字符串）；list（列表）；hash（哈希），set（集合）；zset(有序集合) 4，持久化，集群部署 5，支持过期时间，支持事务，消息订阅 2、项目集成缓存注解 （1）缓存@Cacheable 根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。一般用在查询方法上 查看源码，属性值如下： 属性/方法名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 可选属性，可以使用 SpEL 标签自定义缓存的key （2）缓存@CachePut 使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。 查看源码，属性值如下： 属性/方法名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 可选属性，可以使用 SpEL 标签自定义缓存的key （3）缓存@CacheEvict 使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上 查看源码，属性值如下： 属性/方法名 解释 value 缓存名，必填，它指定了你的缓存存放在哪块命名空间 cacheNames 与 value 差不多，二选一即可 key 可选属性，可以使用 SpEL 标签自定义缓存的key allEntries 是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存 beforeInvocation 是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存 1、添加依赖 123456789101112&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- spring2.X集成redis所需common-pool2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; 2、编写配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport { @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;(); RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setConnectionFactory(factory); //key序列化方式 template.setKeySerializer(redisSerializer); //value序列化 template.setValueSerializer(jackson2JsonRedisSerializer); //value hashmap序列化 template.setHashValueSerializer(jackson2JsonRedisSerializer); return template; } @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; }} 3、启动redis服务 windows: 1redis-server redis.windows.conf 点击redis-cli.exe 4、redis配置 application.properties 12345678910spring.redis.host=192.168.44.132spring.redis.port=6379spring.redis.database= 0spring.redis.timeout=1800000spring.redis.lettuce.pool.max-active=20spring.redis.lettuce.pool.max-wait=-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle=5spring.redis.lettuce.pool.min-idle=0","link":"/posts/b5892632/"},{"title":"谷粒学院开发day10","text":"摘要： springCloud nacos feign hysrix 一、springCloud1、什么是微服务 微服务是一种架构风格 把一个项目拆分成独立的多个服务 有多个服务 多服务独立运行 每个服务占用独立进程 2、为什么使用微服务 在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。 3、微服务与单体架构区别（1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。 ​ 微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。 （2）单体架构所有的模块都共用一个数据库，存储方式比较单一。 ​ 微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。 （3）单体架构所有的模块开发所使用的技术一样。 ​ 微服务每个模块都可以使用不同的开发技术，开发模式更灵活。 4、什么是springcloud springcloud 并不是一种技术，很多技术的集合，总称 springcloud中有很多框架（技术），我们使用springcloud里面这些框架技术实现微服务 使用springcloud依赖springboot 5、springcloud相关基础服务组件（后续都会学习）服务发现——Netflix Eureka （Nacos） 服务调用——Netflix Feign 熔断器——Netflix Hystrix 服务网关——Spring Cloud GateWay 分布式配置——Spring Cloud Config （Nacos） 消息总线 —— Spring Cloud Bus （Nacos） 二、服务发现 搭建Nacos服务 1、什么是Nacos阿里巴巴，开源项目，构建云原生应用的动态服务发现、配置管理和服务管理平台 项目中注册中心 使用nacos替代原生的 Eureka 2、Nacos流程 3、服务注册service父模块添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 添加服务配置关系 12#nacos服务地址spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 启动类添加注解 1@EnableDiscoveryClient 三、服务调用 Feign1、Feign Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。 Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。 Spring Cloud对Feign进行了增强，使Feign支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。 Spring Cloud Feign是基于Netflix feign实现，整合了Spring Cloud Ribbon和Spring Cloud Hystrix，除了提供这两者的强大功能外，还提供了一种声明式的Web服务客户端定义的方式。 Spring Cloud Feign帮助我们定义和实现依赖服务接口的定义。在Spring Cloud feign的实现下，只需要创建一个接口并用注解方式配置它，即可完成服务提供方的接口绑定，简化了在使用Spring Cloud Ribbon时自行封装服务调用客户端的开发量。 2、服务调用service父模块添加依赖 12345&lt;!--服务调用--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 调用端启动类添加注解 1@EnableFeignClients 创建包和接口 创建client包 @FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。 @Component注解防止，在其他位置注入CodClient时idea报错 @PathVariable注解一定要指定参数名称，否则出错 123456789@Component@FeignClient(\"service-vod\")//远程调用public interface VodClient { //定义要调用方法的路径 @DeleteMapping(\"/eduvod/video/deleteVideo/{videoId}\") public R deleteVideoById(@PathVariable(\"videoId\") String videoId);} 在使用的地方注入接口调用方法 12@Autowiredprivate VodClient vodClient; 四、熔断器1、Spring Cloud调用接口过程 2、Hystrix概念分布式：项目单独的服务部署在不同的服务器上 Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。 比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败 3、使用1、添加依赖 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--hystrix依赖，主要是用 @HystrixCommand --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--服务注册--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--服务调用--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2、修改配置文件 1234#开启熔断机制feign.hystrix.enabled=true# 设置hystrix超时时间，默认1000mshystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000 3、创建实体类继承VodClient实现里面的方法 1234567891011121314@Componentpublic class VodClientImpl implements VodClient { //定义的方法都是出错后执行 @Override public R deleteVideoById(String videoId) { return R.error().message(\"出错了\"); } @Override public R deleteBatch(List videoIdList) { return R.error().message(\"出错了\"); }} 4、修改client注解 123456@Component@FeignClient(value = \"service-vod\",fallback = VodClientImpl.class)//远程调用public interface VodClient { ...}","link":"/posts/c28e16a4/"},{"title":"谷粒学院开发day14","text":"摘要： 阿里云视频播放器整合 项目开发 一、名师 列表 详情正常的开发流程 后端接口 - 前端调用 - 数据展示 二、课程 列表 详情正常的开发流程 后端接口 - 前端调用 - 数据展示 三、阿里云视频播放器参考文档：https://help.aliyun.com/document\\_detail/51991.html 参考 【播放器简单使用说明】一节 引入脚本文件和css文件 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/skins/default/aliplayer-min.css&quot; /&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.8.1/aliplayer-min.js&quot;&gt;&lt;/script&gt; 初始化视频播放器 1234567891011121314&lt;body&gt; &lt;div class=&quot;prism-player&quot; id=&quot;J_prismPlayer&quot;&gt;&lt;/div&gt; &lt;script&gt; var player = new Aliplayer({ id: 'J_prismPlayer', width: '100%', autoplay: false, cover: 'http://liveroom-img.oss-cn-qingdao.aliyuncs.com/logo.png', //播放配置 },function(player){ console.log('播放器创建好了。') }); &lt;/script&gt;&lt;/body&gt; 播放地址播放： 在Aliplayer的配置参数中添加如下属性 12//播放方式一：支持播放地址播放,此播放优先级最高，此种方式不能播放加密视频source : '你的视频播放地址', 启动浏览器运行，测试视频的播放 播放凭证播放： 阿里云播放器支持通过播放凭证自动换取播放地址进行播放，接入方式更为简单，且安全性更高。播放凭证默认时效为100秒（最大为3000秒），只能用于获取指定视频的播放地址，不能混用或重复使用。如果凭证过期则无法获取播放地址，需要重新获取凭证。 123encryptType:'1',//如果播放加密视频，则需设置encryptType=1，非加密视频无需设置此项vid : '视频id',playauth : '视频授权码', 注意：播放凭证有过期时间，默认值：100秒 。取值范围：100~3000。 设置播放凭证的有效期 在获取播放凭证的测试用例中添加如下代码 1request.setAuthInfoTimeout(200L); 在线配置参考：https://player.alicdn.com/aliplayer/setting/setting.html 发现播放凭证播放会报错 查询官方文档得知可能是转码加密的问题 解决： 上传时不使用加密模板，只是在HTML里没有显示的写上播放地址，而是使用id和auth获取，防止盗链 created里赋给data的值在mounted里取不到 watch函数 解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script&gt;import vod from '@/api/vod'export default { layout: 'video',//应用video布局 data(){ return{ videoId:'', auth:'', flag:false } }, created() { this.videoId = this.$route.params.vid this.getAuth() }, watch:{ auth(newName, oldName) { console.log('auth= ' + this.auth); var player = new Aliplayer({ \"id\": \"player-con\", \"vid\": this.videoId, \"playauth\": this.auth, \"qualitySort\": \"asc\", \"format\": \"mp4\", \"mediaType\": \"video\", \"width\": \"100%\", \"height\": \"500px\", \"autoplay\": true, \"isLive\": false, \"rePlay\": false, \"playsinline\": true, \"preload\": true, \"controlBarVisibility\": \"hover\", \"useH5Prism\": true }, function (player) { console.log(\"The player is created\"); } ); } }, methods:{ getAuth() { vod.getPlayAuth(this.videoId) .then(response =&gt; { this.auth = response.data.data.auth this.flag = true }) } }}&lt;/script&gt;","link":"/posts/c5e3d2bd/"},{"title":"递归","text":"摘要： 递归，迷宫问题，八皇后问题 一.递归的应用场景迷宫问题 二.递归的概念简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁 三.递归的调用机制1234567//打印问题public static void test(int n){ if (n &gt; 2){ test(n - 1); } System.out.println(\"n = \" + n);} main方法中调用test(4)的输出结果： n = 2 n = 3 n = 4 1234567//阶乘问题public static void test(int n){ if (n &gt; 2){ test(n - 1); } System.out.println(\"n = \" + n);} 递归的调用规则 当程序执行到一个方法时，就会开辟一个独立的空间（栈） 每个空间的数据（局部变量），是独立的 四.递归可以解决什么样的问题递归可以解决的问题 各种数学问题：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子问题（Google编程大赛） 各种算法中使用:快速排序，归并排序，二分查找，分治算法 使用栈解决的问题-&gt;使用递归代码比较简洁 递归需要遵循的重要原则 执行一个方法时，就会创建一个受保护的独立空间（栈空间） 方法中的局部变量是相互独立的，不会相互影响 如果方法中使用的是引用类型的变量，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverFlowError 当一个方法执行完毕，或者遇到return，就会返回，遵守谁先调用，就将结果返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕 五.递归-迷宫问题代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.cyfwlp.recursion;public class MiGongMy { public static void main(String[] args) { //数组模拟迷宫 int[][] map = new int[6][6]; //填充墙周围 for (int i = 0; i &lt; 6; i++) { map[0][i] = 1; map[5][i] = 1; map[i][0] = 1; map[i][5] = 1; } //中间墙 map[2][1] = 1; map[2][2] = 1; //打印地图 System.out.println(\"初始迷宫\"); for (int[] ints : map) { for (int anInt : ints) { System.out.print(anInt + \" \"); } System.out.println(); } //开始找路 setWay(map,1,1); //打印找路后的迷宫 System.out.println(\"找路后的迷宫\"); for (int[] ints : map) { for (int anInt : ints) { System.out.print(anInt + \" \"); } System.out.println(); } } /** * 设置路径 * 约定： * 1. 0表示未探测 1表示墙 2表示可以走 3表示四路 * 2. 探测顺序为 ↓ → ← ↑ * @param map 需要设置路径的地图 * @param i 横坐标 * @param j 纵坐标 */ public static boolean setWay(int[][] map ,int i, int j){ //递归退出条件 if (map[i][j] == 2){ return true; }else { if (map[i][j] == 0){ //假设这个点可以走 map[i][j] = 2; //按照探测顺序进行探测 if (setWay(map,i,j+1)){ return true; }else if (setWay(map,i+1,j)){ return true; }else if (setWay(map,i,j-1)){ return true; }else if (setWay(map,i-1,j)){ return true; }else{ //这个点为死路 map[i][j] = 3; return false; } }else{ //map[i][j] 的值可能为1 2 3 分别对应 1：为墙不能走 2：已经走过不能回去 3：已经判断过是死路 return false; } } }} 六.八皇后问题八皇后问题算法思路分析: 第一个皇后先放在第一行第一列 第二个皇后放在第二行第一列，然后判断是否ok，如果不ok，继续放在第二列，第三列，依次把所有的列放完，找到一个合适的位置 继续第三个皇后，还是第一列，第二列…直到第8个皇后也能放在一个不冲突的位置，算是得到了一个正确的解 在得到一个正确的解时，栈回退到上一个栈，就会开始回溯，将第一个皇后放到第一行第一列的全部解得到 然后将第一个皇后放到 第一行第二列，再循环执行1 2 3 4 说明：理论上应该创建一个二维数组来表示棋盘，但实际上可以通过算法，用一个一维数组解决问题 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.cyfwlp.recursion;public class Queue8 { //定义最多有多少个皇后 int max = 8; //定义皇后摆放位置的结果 int[] array = new int[max]; //统计解法的次数 static int count = 0; //统计judge方法调用次数 static int judge = 0; public static void main(String[] args) { Queue8 queue8 = new Queue8(); queue8.check(0); System.out.println(\"一共有\" + count + \"解法\"); System.out.println(\"判断冲突的次数\" + judge); } //写一个方法，将皇后摆放的位置输出 private void print(){ count ++; for (int i : array) { System.out.print(i + \" \"); } System.out.println(); } //放置第n个皇后 //特别注意:check 是每一次递归时，进入到check方法中都有一次for循环，因此会有回溯 private void check(int n){ // n == 8 相对于在放第九个皇后 if (n == max){ print(); return; } //依次放入皇后并判断是否冲突 for (int i = 0; i &lt; max; i++) { //先把当前的皇后n 放到该行的第一列 array[n] = i; //放置第n个皇后到第i列时是否冲突 if (judge(n)){ //不冲突，接着放n+1个 check(n + 1); } //如果冲突 继续循环 } } //判断是否冲突 //当我们放置第n个皇后时，需要检测该皇后是否和前面已经摆放的皇后位置冲突 private boolean judge(int n){ judge ++; for (int i = 0; i &lt; n; i++) { //说明 //array[i] == array[n] 第n个皇后是否和前面n-1个皇后是否在同一列 //Math.abs(n-i) == Math.abs(array[n] - array[i]) 第n个皇后是否和前面n-1个皇后是否在同一斜线 if (array[i] == array[n] Math.abs(n-i) == Math.abs(array[n] - array[i])){ return false; } } return true; }}","link":"/posts/c6654282/"},{"title":"链表","text":"摘要： 链表 一.链表介绍 链表是以节点的方式来存储，链式存储 每个节点包含data域（存数据），next域（指向下一个节点） 链表的各个节点不一定是连续存放的 链表分为带头节点的链表和没有头节点的链表，根据实际的需求来确定 二.单链表head 头节点 不存放具体的数据 表示单链表头 创建（添加） 创建一个头节点，表示单链表的头 后面每添加一个节点，就直接加入到链表的最后 通过一个辅助变量，完成遍历整个单链表 添加（按照编号顺序） 找到新添加节点的位置，通过一个辅助变量 找到待添加节点的前一个节点 新的节点的.next = temp.next temp.next = 新的节点 修改 辅助节点 找到待修改节点（并非前一个） 修改 删除 找到需要删除节点到的前一个节点 让temp.next = temp.next.next 被删除的节点将不会有其他引用指向，会被垃圾回收机制回收(不需要手动回收) 代码实现 水浒英雄的管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.cyfwlp.linkedlistmy;public class SingleListDemo { public static void main(String[] args) { SingleList singleList = new SingleList(); HeroNode hero1 = new HeroNode(1,\"宋江\",\"及时雨\"); HeroNode hero2 = new HeroNode(2,\"林冲\",\"豹子头\"); HeroNode hero3 = new HeroNode(3,\"鲁智深\",\"花和尚\"); HeroNode hero4 = new HeroNode(4,\"吴用\",\"智多星\"); HeroNode hero4_1 = new HeroNode(4,\"吴用用——\",\"QQ星\"); singleList.addHead(hero1); singleList.addHead(hero2); singleList.addHead(hero3); singleList.addHead(hero4); singleList.printHero(); }}class SingleList { private HeroNode head = new HeroNode(0,null,null); //尾插 public void addHero(HeroNode heroNode) { HeroNode temp = head; //找到最后一个节点 while (temp.getNext()!= null) { temp = temp.getNext(); } //插入 temp.setNext(heroNode); } //按顺序添加 public void addHeroByorder(HeroNode heroNode) { HeroNode temp = head; while (temp.getNext() != null &amp;&amp; heroNode.getNo() &lt; temp.getNo() ) { temp = temp.getNext(); } //插入 heroNode.setNext(temp.getNext()); temp.setNext(heroNode); } //头插 public void addHead(HeroNode heroNode) { //直接插 heroNode.setNext(head.getNext()); head.setNext(heroNode); } //删除,根据序号删除 public void delete(int no) { HeroNode temp = head; boolean flag = false;//是否找到 //找到删除前一个位置 while (temp.getNext() != null) { if (temp.getNext().getNo() == no) { flag = true; break; } temp = temp.getNext(); } if (flag) { temp.setNext(temp.getNext().getNext()); }else { System.out.println(\"未找到需要删除的英雄节点\"); } } //修改 public void update(HeroNode heroNode) { HeroNode temp = head; boolean flag = false;//是否找到 //找到修改的位置 while (temp.getNext() != null) { if (temp.getNo() == heroNode.getNo()) { flag = true; break; } temp = temp.getNext(); } if (flag) { //进行修改 temp.setName(heroNode.getName()); temp.setNickName(heroNode.getNickName()); }else { System.out.println(\"未找到需要删除的英雄节点\"); } } //遍历方法 public void printHero() { HeroNode temp = head.getNext(); while (temp != null) { System.out.println(temp); temp = temp.getNext(); } }}class HeroNode { private int no; private String name; private String nickName; private HeroNode next; public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getNickName() { return nickName; } public void setNickName(String nickName) { this.nickName = nickName; } public HeroNode getNext() { return next; } public void setNext(HeroNode next) { this.next = next; } public HeroNode(int no, String name, String nickName) { this.no = no; this.name = name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; }} 三.单链表面试题（新浪，百度，腾讯） 求单链表中有效节点的个数 查找单链表的倒数第k个节点【新浪面试题】 单链表的反转【腾讯面试题】 从尾到头打印单链表【百度面试题。要求方式1：反向遍历 方式2 stack栈】 合并两个有序的链表，合并后链表依然有序【课后练习】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 求单链表中有效节点的个数 * @param singleList * @return */ public static int count(SingleList1 singleList) { int count = 0;//计数 Node temp = singleList.getHead().getNext(); while (temp != null) { count += 1; temp = temp.getNext(); } return count; } /** *查找单链表的倒数第k个节点 * 思路：倒数第n个，就是正数 k - n + 1 个 * @param singleList * @param index * @return */ public static int findNode(SingleList1 singleList,int index) { int length = count(singleList); if (index &lt; 0 &amp;&amp; index &gt; length) { throw new RuntimeException(\"\"); } int count = 1; Node temp = singleList.getHead().getNext(); while (temp.getNext() != null &amp;&amp; count != length - index + 1) { temp = temp.getNext(); count += 1; } return temp.getValue(); } /** * 单链表的反转 * 思路： * 1.遍历每个节点，头插法插入 * @param singleList */ public static void reverse(SingleList1 singleList) { SingleList1 singleList1 = new SingleList1(); Node temp = singleList.getHead().getNext(); while (temp!= null) { Node insert = new Node(temp.getValue()); singleList1.addHead(insert); temp = temp.getNext(); } singleList.setHead(singleList1.getHead()); } /** * 从尾到头打印单链表(使用栈) * @param singleList */ public static void reversePrint(SingleList1 singleList) { Node temp = singleList.getHead().getNext(); Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); while (temp != null) { stack.push(temp.getValue()); temp = temp.getNext(); } while (!stack.empty()) { System.out.println(stack.pop()); } } /** * 合并两个有序的链表，合并后链表依然有序 * @param singleList1 * @param singleList2 * @return */ public static SingleList1 merge(SingleList1 singleList1,SingleList1 singleList2) { SingleList1 singleList = new SingleList1(); Node temp1 = singleList1.getHead().getNext(); Node temp2 = singleList2.getHead().getNext(); while (temp1.getNext() != null &amp;&amp; temp2.getNext() != null) { if (temp1.getValue() &lt; temp2.getValue()) { Node insert = new Node(temp1.getValue()); insert(singleList,insert); temp1 = temp1.getNext(); } if (temp1.getValue() &gt; temp2.getValue()) { Node insert = new Node(temp2.getValue()); insert(singleList,insert); temp2 = temp2.getNext(); } } if (temp1 != null) { insert(singleList,temp1); } if (temp2 != null) { insert(singleList,temp2); } return singleList; } //尾插 public static void insert(SingleList1 singleList,Node insert) { Node temp = singleList.getHead(); while (temp.getNext() != null) { temp = temp.getNext(); } //找到最后位置 temp.setNext(insert); } 四.双链表单链表的缺点 查找方向只能是一个方向，而双向链表可以向前或向后查找 单链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除（单链表删除时需找到待删除节点的前一个节点） 双向链表的遍历，添加，删除，修改的操作思路 遍历 遍历的方式和单链表一样，只是可以向前查找也可以向后查找 添加 (尾插) 1.先找到双向链表的最后这个节点 temp 2.temp.next = newNode 3.newNode.pre = temp 添加 （按照顺序比如从小到大） 1.两种结果，要么在最后，要么在中间 2.在中间的情况 newNode.no &lt; temp.next.no 添加在temp后面 3.在最后的情况 temp移动到最后，newNode.no 一直大于 temp.no 修改 思路和单链表一样 删除 1.直接找到待删除的节点 temp 2.temp.pre.next = temp.next 3.temp.next.pre = temp.pre 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.cyfwlp.linkedlist;public class DoubleLinkedListDemo { public static void main(String[] args) { DoubleLinkedList linkedList = new DoubleLinkedList(); HeroNode2 hero1 = new HeroNode2(1,\"宋江\",\"及时雨\"); HeroNode2 hero2 = new HeroNode2(2,\"卢俊义\",\"玉麒麟\"); HeroNode2 hero3 = new HeroNode2(3,\"吴用\",\"智多星\"); HeroNode2 hero4 = new HeroNode2(4,\"林冲\",\"豹子头\"); linkedList.addByOrder(hero1); linkedList.addByOrder(hero4); linkedList.addByOrder(hero3); linkedList.addByOrder(hero2); linkedList.list(); System.out.println(\"删除...个后\"); linkedList.delete(4); linkedList.list(); System.out.println(\"修改节点1\"); linkedList.update(new HeroNode2(1,\"小宋\",\"及时雨及时雨————\")); linkedList.list(); }}//创一个双向链表的类class DoubleLinkedList { //头节点 private HeroNode2 head = new HeroNode2(0, null, null); public HeroNode2 getHead() { return head; } public void setHead(HeroNode2 head) { this.head = head; } //遍历双向链表的方法 public void list() { //判断是否为空 if (head.next == null) { return; } //辅助变量 HeroNode2 temp = head.next; while (temp != null) { System.out.println(temp); temp = temp.next; } } //添加（尾插法） public void add(HeroNode2 heroNode) { //找到最后一个变量 HeroNode2 temp = head; while (temp.next != null) { temp = temp.next; } temp.next = heroNode; heroNode.pre = temp; } //添加 （按照大小） public void addByOrder(HeroNode2 heroNode){ //辅助节点 HeroNode2 temp = head; boolean flag = true;//标记no是否已经存在 while (true){ if(temp.next == null){ //没找到或添加第一个元素 break; } if(heroNode.no &lt; temp.next.no){ //需要中间插入 break; }else if(heroNode.no == temp.no){ System.out.println(\"待插入的英雄已经已存在\"); flag = false; break; } temp = temp.next; } if(flag){ //是否是最后 if(temp.next != null){ heroNode.next = temp.next; temp.next.pre = heroNode; } temp.next = heroNode; heroNode.pre = temp; } } //删除 public void delete(int no){ if (head.next == null){ System.out.println(\"链表为空\"); return; } //直接找到需要删除的节点 //找到后自我删除 HeroNode2 temp = head.next; boolean flag = true;//标记是否找到变量 while (true){ if(temp == null){ //未找到 flag = false; System.out.println(\"未找到需要删除的节点\"); break; } if(temp.no == no){ break; } temp = temp.next; } if(flag){ //删除操作 temp.pre.next = temp.next; //判断是不是最后一个节点 if(temp.next != null){ temp.next.pre = temp.pre; } } } //修改 public void update(HeroNode2 heroNode){ //直接找到修改 HeroNode2 temp = head.next; boolean flag = true;//标记是否找到变量 while (true){ if(temp == null){ //未找到 System.out.println(\"未找到需要修改的节点\"); flag = false; break; } if(temp.no == heroNode.no){ break; } temp = temp.next; } if(flag){ //修改 temp.no = heroNode.no; temp.name = heroNode.name; temp.nickName = heroNode.nickName; } }}//节点class HeroNode2 { public int no; public String name; public String nickName; public HeroNode2 next; //指向前一个节点 public HeroNode2 pre; public HeroNode2(int no, String name, String nickName) { this.no = no; this.name = name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode2{\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; }} 五.单向环形链表应用场景约瑟夫环问题 设编号为1,2…n的n个人围成一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的人出列,他的下一位又开始从1报数，数到m的人那个人又出列，依次类推，直到所有的人都出列为止，产生一个出队编号的序列 分析： 使用一个不带头节点的单向环形链表 构建的思路： 先创建第一个节点，让first指向该节点。并形成环状 后面当我们创建一个新的节点，就把该节点加入到新的环形链表中 遍历的思路： 先让辅助变量指向first while(temp.next != first) 根据用户的输入，生成小孩出圈的顺序 需要创建一个辅助指针，先指向环形链表的最后一个节点 报数前 将first移动到k位置 当报数时，让first和helper指针同时移动（m-1）次 出圈 将first指向的小孩节点出圈 先前移first helper.next = first 原来节点没有任何引用，被回收 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.cyfwlp.linkedlist;public class Josephu { public static void main(String[] args) { CircleSingleLinkedList linkedList = new CircleSingleLinkedList(); linkedList.addBoy(41); linkedList.countBoy(1,3,41,1); }}//创建环形链表class CircleSingleLinkedList{ //创建一个first节点，当前还没有值 private Boy first = null; //添加小孩节点，构建成环形链表 public void addBoy(int nums){ //数据校验 if(nums&lt;0){ System.out.println(\"nums不正确\"); return; } Boy curBoy = null; for (int i = 1; i &lt;= nums; i++) { Boy boy = new Boy(i); if (i == 1){ first = boy; first.setNext(first); //curBoy指向第一个小孩 curBoy = first; }else{ //添加 curBoy.setNext(boy); boy.setNext(first); curBoy = curBoy.getNext(); } } } //遍历 public void list(){ if (first == null){ System.out.println(\"链表为空\"); } Boy temp = first; while (true){ System.out.println(temp); if(temp.getNext() == first){ break; } temp = temp.getNext(); } } //根据用户的输入，计算小孩出圈的顺序 /** * * @param starNo 从第几个小孩开始数 * @param countNum 数几下 * @param nums 表示最开始有几个小孩 * @param k 第几个小孩开始报数 */ public void countBoy(int starNo, int countNum, int nums,int k){ //数据进行校验 if(first == null starNo &lt; 1 starNo &gt; nums){ System.out.println(\"参数输入有误，请重新输入\"); return; } //helper复制指针 Boy help = first; //让复制指针指向最后 while (help.getNext() != first){ help = help.getNext(); } //移动 for (int i = 0; i &lt; k - 1; i++) { first = first.getNext(); help = help.getNext(); } //报数，出圈 while (true){ if (first == help){ //圈中只有一个人 System.out.println(\"最后留在圈中的小孩\" + first); break; } //让first和helper同时移动，出圈 for (int i = 0; i &lt; countNum - 1; i++) { first = first.getNext(); help = help.getNext(); //first指向的小孩就是需要出圈的节点 System.out.println(\"出圈\" + first); //将first指向的小孩出圈 first = first.getNext(); help.setNext(first); } } }}//定义节点class Boy{ private int no; private Boy next; public Boy(int no) { this.no = no; next = null; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public Boy getNext() { return next; } public void setNext(Boy next) { this.next = next; } @Override public String toString() { return \"Boy{\" + \"no=\" + no + '}'; }}","link":"/posts/2362a8ea/"},{"title":"谷粒学院开发day01","text":"摘要： 项目简介、mybatisPlus 1、项目功能模块 2、项目使用的技术 3、MybatisPlusMyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生 （1）mybatisPlus快速入门spingboot版本：2.1.1 1、引入依赖 12345678910111213141516171819&lt;!--mybatis-plus--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok用来简化实体类--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置application.properties 注意mysql版本不同对应的驱动类名不同 12345#mysql数据库连接spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plusspring.datasource.username=rootspring.datasource.password=123456 3、编写代码 @Data注解，不需要手动写get，set方法 1234567891011package com.tao.entity;import lombok.Data;@Datapublic class User { private Long id; private String name; private Integer age; private String email;} mapper继承 BaseMapper接口，不需要编写xxxMapper.xml 1234567891011121314151617181920212223242526272829303132333435public interface BaseMapper&lt;T&gt; { int insert(T var1); int deleteById(Serializable var1); int deleteByMap(@Param(\"cm\") Map&lt;String, Object&gt; var1); int delete(@Param(\"ew\") Wrapper&lt;T&gt; var1); int deleteBatchIds(@Param(\"coll\") Collection&lt;? extends Serializable&gt; var1); int updateById(@Param(\"et\") T var1); int update(@Param(\"et\") T var1, @Param(\"ew\") Wrapper&lt;T&gt; var2); T selectById(Serializable var1); List&lt;T&gt; selectBatchIds(@Param(\"coll\") Collection&lt;? extends Serializable&gt; var1); List&lt;T&gt; selectByMap(@Param(\"cm\") Map&lt;String, Object&gt; var1); T selectOne(@Param(\"ew\") Wrapper&lt;T&gt; var1); Integer selectCount(@Param(\"ew\") Wrapper&lt;T&gt; var1); List&lt;T&gt; selectList(@Param(\"ew\") Wrapper&lt;T&gt; var1); List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(\"ew\") Wrapper&lt;T&gt; var1); List&lt;Object&gt; selectObjs(@Param(\"ew\") Wrapper&lt;T&gt; var1); IPage&lt;T&gt; selectPage(IPage&lt;T&gt; var1, @Param(\"ew\") Wrapper&lt;T&gt; var2); IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; var1, @Param(\"ew\") Wrapper&lt;T&gt; var2);} 启动类指定扫描mappers位置 @MapperScan注解 123456@MapperScan(\"com.tao.mapper\")public class Mpdemo1010Application { public static void main(String[] args) { SpringApplication.run(Mpdemo1010Application.class, args); }} 查看sql日志 12#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl （2）主键策略1、自动增长 anto increment 分表：用户表数据过于庞大，分到几张表中进行存储 缺点：在新的表添加数据时需要查询到上一张表最后一条数据id 2、UUID 每次操作生成随机的唯一的值 缺点：排序不方便 3、Redis实现 ​ 当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。 4、Twitter的snowflake（雪花）算法（mp使用） ​ snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。 配置主键策略 123456789101112@TableId(type = IdType.AUTO)//IdTypepublic enum IdType { AUTO(0),//自动增长 NONE(1),//输入 INPUT(2),//设置id值 UUID(4),//使用uuid //mp自带策略 ID_WORKER(3), //mp自带策略，默认策略，会生成19位值，数字类型使用这种策略 ID_WORKER_STR(5);//mp自带策略，会生成19位值，字符串类型使用这种策略 ...} （3）自动填充 项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作。 原始方式：手动设置 12user.setCreateTime(new Date());user.setUpdateTime(new Date()); mp方式： 1、在实体类里面进行需要自动填充的属性上面加注解 @TableField 1234@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 2、创建类，实现接口MetaObjectHandler，实现接口里的方法 12345678910111213141516@Component public class MyMetaObjectHandler implements MetaObjectHandler { //使用mp进行插入操作时，这个方法执行 @Override public void insertFill(MetaObject metaObject) { this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); } ////使用mp进行修改操作时，这个方法执行 @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(\"updateTime\",new Date(),metaObject); }} 在实际开发中选择使用，实现功能即可 （4）乐观锁悲观锁：串行 乐观锁： 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 使用场景：12306抢火车票 mp使用乐观锁： 1、实体类对应version属性添加@Version注解 12@Versionprivate Integer version;//版本号 2、配置乐观锁插件 123456789101112@MapperScan(\"com.tao.mapper\")@Configurationpublic class MpConfig { /** * 乐观锁插件 */ @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); }} 3、修改时需先查询再修改 12345678@Testpublic void testOptimisticLocker(){ //需先查询再修改 User user = userMapper.selectById(1319239623661387777L); user.setAge(200); int row = userMapper.updateById(user); System.out.println(row);} （5）分页查询mp实现分页查询 1、配置分页插件 1234567/** * 分页插件 */@Beanpublic PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor();} 2、编写分页代码 1234567891011121314@Testpublic void testSelectPage() { Page&lt;User&gt; page = new Page&lt;User&gt;(1,3); //参数 当前页，每页记录数 userMapper.selectPage(page, null);// 第二个参数条件 System.out.println(\"当前页\" + page.getCurrent()); System.out.println(\"页数\" + page.getPages()); System.out.println(\"当前数据\" + page.getRecords()); System.out.println(\"每页大小\" + page.getSize()); System.out.println(\"总条数\" + page.getTotal()); System.out.println(\"是否下一页 \"+page.hasNext()); System.out.println(\"是否前一页\" + page.hasPrevious());} （6）逻辑删除1、数据表添加字段 1ALTER TABLE `user` ADD COLUMN `deleted` boolean 2、属性上添加注解 12@TableLogicprivate Integer deleted; //逻辑删除 3、配置逻辑删除插件 1234@Beanpublic ISqlInjector sqlInjector() { return new LogicSqlInjector();} 执行结果： 删除时执行update 12345userMapper.deleteById(1319249424579670018L);==&gt; Preparing: UPDATE user SET deleted=1 WHERE id=? AND deleted=0 ==&gt; Parameters: 1319249424579670018(Long)&lt;== Updates: 1 查询时加上条件where deleted = 0 12345List&lt;User&gt; users = userMapper.selectList(null);Preparing: SELECT id,name,age,email,create_time,update_time,version,deleted FROM user WHERE deleted=0 ==&gt; Parameters: &lt;== Total: 0 （7）性能分析1、配置性能分析插件 1234567891011121314151617/** * SQL 执行性能分析插件 * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长 * 项目开发的环境 * dev： 开发环境 * test：测试环境 * prod：生产环境*/ @Bean//表示当前插件对什么环境起作用@Profile({\"dev\",\"test\"})// 设置 dev test 环境开启public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100);//ms，超过此处设置的ms则sql不执行 performanceInterceptor.setFormat(true); return performanceInterceptor;} 2、设置springboot dev环境 12#环境设置：dev、test、prodspring.profiles.active=dev （8）复杂条件查询使用QueryWrapper构建查询条件 ge gt le lr ： &gt;= &gt; &lt;= &lt; eq ne ： == &lt;&gt; like： 模糊查询 orderByDesc： 排序 between ： 范围 last ：在sql语句的最后拼接一段sql语句 select：查询指定列的值 123456789101112131415161718192021222324@Testpublic void testQueryWrapper() { //创建QueryWrapper对象 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); //通过QueryWrapper设置查询条件 // ge,gt,le,lt // 查询age&gt;=30的记录 /*wrapper.ge(\"age\",30);*/ // eq,ne == != /*wrapper.eq(\"name\",\"lisi\");*/ // between /*wrapper.between(\"age\",10,100);*/ // like /*wrapper.like(\"name\",\"东方\");*/ // orderByDesc // last 直接拼接到sql /*wrapper.last(\"limit 1\");*/ // select 查询指定的列 wrapper.select(\"name\"); List&lt;User&gt; users = userMapper.selectList(wrapper); for (User user : users) { System.out.println(user); }}","link":"/posts/ac921773/"},{"title":"谷粒学院开发day13","text":"摘要： 微信扫码登录 一、登录前端整合 二、微信扫码登录1、OAuth2OAuth2是针对特定问题的一种解决方案 OAuth2主要解决两个问题 开放系统间授权 照片拥有者想要在云冲印服务上打印照片，云冲印服务需要访问云存储服务上的资源 分布式访问问题 （单点登录） 2、微信扫码登录 问题：cookie怎么都设置不了 就离谱 解决 ： localhost 和 127.0.0.1 在设置cookie domain属性是不一样 1、申请成为微信开发者 网址：https://open.weixin.qq.com/ 添加网站项目，得到相关参数 12345678wx: open: # 微信开放平台 appid appid: wxed9954c01bb89b47 # 微信开放平台 appsecret appsecret: a7482517235173ddb4083788de60b90e # 微信开放平台 重定向url（guli.shop需要在微信开放平台配置） redirecturl: http://guli.shop/api/ucenter/wx/callback 2、显示二维码界面 第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在PC端打开以下链接： https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect\\_uri=REDIRECT\\_URI&amp;response\\_type=code&amp;scope=SCOPE&amp;state=STATE#wechat\\_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或scope不为snsapi_login。 参数说明 参数 是否必须 说明 appid 是 应用唯一标识 redirect_uri 是 请使用urlEncode对链接进行处理 response_type 是 填code scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 返回说明 用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数 1redirect_uri?code=CODE&amp;state=STATE 若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数 1redirect_uri?state=STATE 在controller里实现 123456789101112131415161718192021222324252627282930313233343536373839@ApiOperation(\"生成微信扫描二维码\")@GetMapping(\"/login\")public String getWxCode() { // 微信开放平台授权baseUrl String baseUrl = \"https://open.weixin.qq.com/connect/qrconnect\" + \"?appid=%s\" + \"&amp;redirect_uri=%s\" + \"&amp;response_type=code\" + \"&amp;scope=snsapi_login\" + \"&amp;state=%s\" + \"#wechat_redirect\"; // 回调地址 String redirectUrl = WxConfig.WX_OPEN_REDIRECT_URL; //获取业务服务器重定向地址 try { redirectUrl = URLEncoder.encode(redirectUrl, \"UTF-8\"); //url编码 } catch (UnsupportedEncodingException e) { throw new GuliException(20001, e.getMessage()); } // 防止csrf攻击（跨站请求伪造攻击） //String state = UUID.randomUUID().toString().replaceAll(\"-\", \"\");//一般情况下会使用一个随机数 String state = \"imhelen\";// // 采用redis等进行缓存state 使用sessionId为key 30分钟后过期，可配置 //键：\"wechar-open-state-\" + httpServletRequest.getSession().getId() //值：satte //过期时间：30分钟 //生成qrcodeUrl String qrcodeUrl = String.format( baseUrl, WxConfig.WX_OPEN_APP_ID, redirectUrl, state); return \"redirect:\" + qrcodeUrl;} 3、用户扫码后得到用户信息，保存数据库 使用技术httpclient 模拟浏览器发送请求，接收返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * * @param code 类似于手机的验证码，随机唯一，每次不一样 * @param state 原样传递 * @return */@ApiOperation(\"微信登录回调方法\")@GetMapping(\"/callback\")public String callBack(String code,String state) { try { //1.根据code 请求微信api 得到access_token 和openid //向认证服务器发送请求换取access_token String baseAccessTokenUrl = \"https://api.weixin.qq.com/sns/oauth2/access_token\" + \"?appid=%s\" + \"&amp;secret=%s\" + \"&amp;code=%s\" + \"&amp;grant_type=authorization_code\"; //拼接参数 baseAccessTokenUrl = String.format(baseAccessTokenUrl, WxConfig.WX_OPEN_APP_ID, WxConfig.WX_OPEN_APP_SECRET, code); //请求这个拼接好的地址，得到返回的值 // ? 如何在程序中请求地址 =》 httpclient String result = HttpClientUtils.get(baseAccessTokenUrl); //进行json解析 Gson gson = new Gson(); HashMap map = gson.fromJson(result, HashMap.class); String access_token = (String) map.get(\"access_token\"); String openid = (String) map.get(\"openid\"); //判断是否需要注册 UcenterMember member = memberService.getOpenIdMember(openid); if (member == null) { //再请求微信提供的地址获取扫码人的信息 //访问微信的资源服务器，获取用户信息 String baseUserInfoUrl = \"https://api.weixin.qq.com/sns/userinfo\" + \"?access_token=%s\" + \"&amp;openid=%s\"; String userInfoUrl = String.format(baseUserInfoUrl, access_token, openid); String resultUserInfo = null; resultUserInfo = HttpClientUtils.get(userInfoUrl); //解析json HashMap mapUserInfo = gson.fromJson(resultUserInfo, HashMap.class); String nickname = (String)mapUserInfo.get(\"nickname\"); //昵称 String headimgurl = (String)mapUserInfo.get(\"headimgurl\"); //头像 //自动注册 member = new UcenterMember(); member.setOpenid(openid); member.setAvatar(headimgurl); member.setNickname(nickname); memberService.save(member); } //cookie存放用户信息 （X） //问题：cookie无法实现跨域 //根据微信信息使用jwt生成token，把token字符串传递到首页面 String token = JwtUtils.getJwtToken(member.getId(), member.getNickname()); return \"redirect:http://localhost:3000?token=\" + token; } catch (Exception e) { e.printStackTrace(); throw new GuliException(20001,e.getMessage()); }} 三、QQ扫码登录审核成为腾讯开发者，回头再添加这个功能 过了几天，这审核也太慢了，回头再说吧 过了几天，审核给我拒绝了，算了，不搞这个功能了","link":"/posts/5b87471e/"},{"title":"谷粒学院开发day12","text":"摘要： 单点登录 阿里云短信服务 一、用户登录业务介绍1、单一服务器模式 前面web项目的开发使用这种模式，将用户登录信息存储在session，登录成功将用户信息存在session，根据session里的用户信息判断用户是否登录 2、集群部署 此时显然不能使用session 单点登录（single sign on，SSO） 单点登录常见三种方式 session广播机制 – session复制 cookie + redis实现 token实现 项目选用token实现 token是什么？ 按照一定的规则生成的字符串，生成字符串里包含用户信息 二、JWT1、什么是jwt 典型的，一个JWT看起来如下图： 该对象为一个很长的字符串，字符之间通过”.”分隔符分为三个子串。 每一个子串表示了一个功能块，总共有以下三个部分：JWT头、有效载荷和签名 JWT头 JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。 1234{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} 在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。 有效载荷 有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。 1234567iss：发行人exp：到期时间sub：主题aud：用户nbf：在此之前不可用iat：发布时间jti：JWT ID用于标识该JWT 除以上默认字段外，我们还可以自定义私有字段，如下例： 12345{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;Helen&quot;, &quot;admin&quot;: true} 请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。 JSON对象也使用Base64 URL算法转换为字符串保存。 签名哈希 签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。 首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(claims), secret) 在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用”.”分隔，就构成整个JWT对象。 Base64URL算法 如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。 作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_“替换，这就是Base64URL算法。 2、项目中使用jwt1、引入依赖 12345&lt;!-- JWT--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt;&lt;/dependency&gt; 2、复制工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.cyfwlp.servicebase.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;import java.util.Date;/** * @author helen * @since 2019/10/16 */public class JwtUtils { //常量 public static final long EXPIRE = 1000 * 60 * 60 * 24; //设置token过期时间 public static final String APP_SECRET = \"ukc8BDbRigUDaY6pZFfWus2jZWLPHO\"; //秘钥 public static String getJwtToken(String id, String nickname){ String JwtToken = Jwts.builder() .setHeaderParam(\"typ\", \"JWT\") .setHeaderParam(\"alg\", \"HS256\") .setSubject(\"guli-user\") .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRE)) .claim(\"id\", id) .claim(\"nickname\", nickname) .signWith(SignatureAlgorithm.HS256, APP_SECRET) .compact(); return JwtToken; } /** * 判断token是否存在与有效 * @param jwtToken * @return */ public static boolean checkToken(String jwtToken) { if(StringUtils.isEmpty(jwtToken)) return false; try { Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); } catch (Exception e) { e.printStackTrace(); return false; } return true; } /** * 判断token是否存在与有效 * @param request * @return */ public static boolean checkToken(HttpServletRequest request) { try { String jwtToken = request.getHeader(\"token\"); if(StringUtils.isEmpty(jwtToken)) return false; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); } catch (Exception e) { e.printStackTrace(); return false; } return true; } /** * 根据token获取会员id * @param request * @return */ public static String getMemberIdByJwtToken(HttpServletRequest request) { String jwtToken = request.getHeader(\"token\"); if(StringUtils.isEmpty(jwtToken)) return \"\"; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken); Claims claims = claimsJws.getBody(); return (String)claims.get(\"id\"); }} 三、阿里云短息服务申请模板与签名 官方文档 1、引入依赖 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、发送短信方法 123456789101112131415161718192021222324252627282930//发送短信方法@Overridepublic Boolean send(Map&lt;String, Object&gt; param, String phone) { if(StringUtils.isEmpty(phone)) return false; DefaultProfile profile = DefaultProfile.getProfile(\"default\", \"LTAI4G7UBH87zGL5jp5sbmuX\", \"0J5xk6K0ftTbyrqlJq7iEt47JKJm7T\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); //request.setProtocol(ProtocolType.HTTPS); request.setMethod(MethodType.POST); request.setDomain(\"dysmsapi.aliyuncs.com\"); request.setVersion(\"2017-05-25\"); request.setAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", phone); request.putQueryParameter(\"SignName\", \"cyfwlp在线教育网站\"); request.putQueryParameter(\"TemplateCode\", \"SMS_205473183\"); request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(param)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); return response.getHttpResponse().isSuccess(); } catch (ClientException e) { e.printStackTrace(); } return false;} 3、redis解决验证码有效时间问题 12345678910111213141516171819202122@ApiOperation(\"发送短信方法\")@GetMapping(\"/sendSms/{phone}\")public R sendSms(@PathVariable String phone) { //1.redis获取验证码，获取到直接返回 String code = redisTemplate.opsForValue().get(\"phone\"); if (!StringUtils.isEmpty(code)) { return R.ok(); } //生成随机验证码 code = RandomUtil.getFourBitRandom(); Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(\"code\",code); //调用service方法发送短信 Boolean isSend = smsService.send(param,phone); if (isSend) { //发送成功，将发送成功的验证码放到redis，同时设置有效时间 redisTemplate.opsForValue().set(\"phone\",code,5, TimeUnit.MINUTES); return R.ok(); } else { return R.error().message(\"短信发送失败\"); }}","link":"/posts/2c807788/"}],"tags":[{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"资源分享","slug":"资源分享","link":"/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"springboot","slug":"笔记/springboot","link":"/categories/%E7%AC%94%E8%AE%B0/springboot/"},{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"javaweb","slug":"javaweb","link":"/categories/javaweb/"},{"name":"说说","slug":"说说","link":"/categories/%E8%AF%B4%E8%AF%B4/"},{"name":"操作系统","slug":"笔记/操作系统","link":"/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据结构与算法","slug":"笔记/数据结构与算法","link":"/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"谷粒学院项目","slug":"技术分享/谷粒学院项目","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/"}]}