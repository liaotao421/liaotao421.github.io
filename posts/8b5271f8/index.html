<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>二.进程，处理机调度与死锁（一） - TaoBlog</title><meta description="摘要： 进程的定义，组成，组织方式，特征 调度算法"><meta property="og:type" content="article"><meta property="og:title" content="二.进程，处理机调度与死锁（一）"><meta property="og:url" content="https://liaotao421.github.io/posts/8b5271f8/"><meta property="og:site_name" content="liaotao"><meta property="og:description" content="摘要： 进程的定义，组成，组织方式，特征 调度算法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s1.ax1x.com/2020/06/04/t0bPaj.jpg"><meta property="og:image" content="https://s1.ax1x.com/2020/06/04/t0bmsU.jpg"><meta property="og:image" content="https://s1.ax1x.com/2020/06/04/t0b1iR.jpg"><meta property="og:image" content="https://s1.ax1x.com/2020/09/08/wQ1Dns.jpg"><meta property="og:image" content="https://s1.ax1x.com/2020/09/08/wQ15u9.jpg"><meta property="og:image" content="https://s1.ax1x.com/2020/09/08/wQ39Et.jpg"><meta property="og:image" content="https://i.loli.net/2020/09/02/bzruxsyj4gTfLDH.jpg"><meta property="article:published_time" content="2020-09-02T13:36:02.000Z"><meta property="article:modified_time" content="2020-11-25T15:35:42.729Z"><meta property="article:author" content="liaotao"><meta property="article:tag" content="categories-java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s1.ax1x.com/2020/06/04/t0bPaj.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liaotao421.github.io/posts/8b5271f8/"},"headline":"二.进程，处理机调度与死锁（一）","image":["https://s1.ax1x.com/2020/06/04/t0bPaj.jpg","https://s1.ax1x.com/2020/06/04/t0bmsU.jpg","https://s1.ax1x.com/2020/06/04/t0b1iR.jpg","https://s1.ax1x.com/2020/09/08/wQ1Dns.jpg","https://s1.ax1x.com/2020/09/08/wQ15u9.jpg","https://s1.ax1x.com/2020/09/08/wQ39Et.jpg","https://i.loli.net/2020/09/02/bzruxsyj4gTfLDH.jpg"],"datePublished":"2020-09-02T13:36:02.000Z","dateModified":"2020-11-25T15:35:42.729Z","author":{"@type":"Person","name":"liaotao"},"description":"摘要： 进程的定义，组成，组织方式，特征 调度算法"}</script><link rel="alternative" href="/atom.xml" title="TaoBlog" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">TaoBlog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-02T13:36:02.000Z">2020-09-02</time><a class="commentCountImg" href="/posts/8b5271f8/#comment-container"><span class="display-none-class">1406e6edd40efb4123827ef143fcc36e</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="1406e6edd40efb4123827ef143fcc36e"> 99+</span>    </a><span class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="level-item">1 小时 读完 (大约 8588 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">二.进程，处理机调度与死锁（一）</h1><div class="content"><blockquote>
<p>摘要：</p>
<p>进程的定义，组成，组织方式，特征</p>
<p>调度算法</p>
</blockquote>
<a id="more"></a>

<h3 id="2-1-1-进程的定义，组成，组织方式，特征"><a href="#2-1-1-进程的定义，组成，组织方式，特征" class="headerlink" title="2.1_1 进程的定义，组成，组织方式，特征"></a>2.1_1 进程的定义，组成，组织方式，特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.进程的定义</span><br><span class="line">    *程序：就是一个指令序列</span><br><span class="line">    进程的定义：程序段，数据段，PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体</span><br><span class="line">        简称为进程，例如，所谓的创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销</span><br><span class="line">        进程实体中的PCB，PCB是进程存在的唯一标识</span><br><span class="line">    PCB:系统为每个运行的程序配置了一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息</span><br><span class="line">        （如程序代码存放的位置，设备的使用情况等等）</span><br><span class="line">        存不同的角度，进程可以有不同的定义  强调“动态性”</span><br><span class="line">    (1).进程是程序的一次执行过程</span><br><span class="line">    (2).进程是一个程序及其数据在CPU上顺序执行时所发生的动作</span><br><span class="line">    (3).进程是具有独立功能的程序在数据集合上的运行过程，它是系统进行资源分配和调用的一个独立单位</span><br><span class="line">    引入了进程实体的概念后，可把进程定义为</span><br><span class="line">    进程是进程实体的运行过程，数系统进行资源分配和调度的一个独立单位</span><br><span class="line"></span><br><span class="line">    注：严格来说，进程实体和很进程不一样，进程是动态的，进程实体是静态的。除非题目特地考察二者的</span><br><span class="line">        区别，否则可以认为进程实体就是进程，因此我们可以说“进程由程序段，数据段，PCB三部分组成”</span><br><span class="line">        程序段 程序代码即存放在此</span><br><span class="line">    数据段 程序运行时产生，使用的运算数据</span><br><span class="line">    PCB 操作系统通过PCB来管理进程，因此PCB中应包含操作系统对进程进行管理所需的各种信息</span><br><span class="line">    PCB:只要是操作系统所需的数据都在PCB中</span><br><span class="line">    进程描述信息</span><br><span class="line">        *  进程标识符 PID</span><br><span class="line">        *用户标识符 UID</span><br><span class="line">    进程控制和管理信息</span><br><span class="line">        * 进程当前状态</span><br><span class="line">        * 进程的优先级</span><br><span class="line">    资源分配清单</span><br><span class="line">        * 程序段指针</span><br><span class="line">        * 数据段指针</span><br><span class="line">        * 键盘</span><br><span class="line">        * 鼠标</span><br><span class="line">    处理机的相关信息 各种寄存器值</span><br><span class="line">2.进程的组织</span><br><span class="line">    链接方式：按照进程状态将PCB分成多个队列，操作系统持有指向各个队列的指针</span><br><span class="line">        执行指针</span><br><span class="line">        就绪队列指针</span><br><span class="line">        阻塞队列指针</span><br><span class="line">    索引方式：根据进程状态的不同，建立几张索引表，操作系统持有各个索引表的指针</span><br><span class="line">        执行指针</span><br><span class="line">        就绪表指针</span><br><span class="line">        阻塞表指针</span><br><span class="line">3.进程的特征</span><br><span class="line">    动态性：进程是程序的一次执行过程</span><br><span class="line">    并发性：内存中有多个进程实体，各进程可并发执行</span><br><span class="line">    独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位</span><br><span class="line">    异步性：各进程按各自独立的，不可预知的速度向前推进（操作系统要提供“进程同步机制”解决异步问题）</span><br><span class="line">    结构性：进程由程序段，数据段，PCB组成</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1_2 进程的状态与转换"></a>2.1_2 进程的状态与转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.三种基本状态</span><br><span class="line">    运行态：占有cpu,并在cpu上运行</span><br><span class="line">    就绪态：已具备了运行的条件，但由于没有空闲cpu，而暂时不能运行</span><br><span class="line">    阻塞态：因等待某一事件暂时不能运行</span><br><span class="line">2.另外两种状态</span><br><span class="line">    创建态：进程正在被创建，操作系统为进程分配资源，初始化PCB</span><br><span class="line">    终止态：进程正在系统中被撤销，操作系统会回收进程拥有的资源，撤销PCB</span><br><span class="line">3.进程状态的转换</span><br><span class="line">    就绪态 -&gt; 运行态：进程被调度</span><br><span class="line">    运行态 -&gt; 就绪态：时间片到，或cpu被其他优先级高的进程抢占</span><br><span class="line">    运行态 -&gt; 阻塞态：等待资源分配，或等待某个事件发生(主动行为)</span><br><span class="line">    阻塞态 -&gt; 就绪态：资源分配完成，等待的时间发生（被动行为）</span><br><span class="line">    创建态 -&gt; 就绪态：系统完成创建进程的相关工作</span><br><span class="line">    运行态 -&gt; 终止态：进程运行结束或运行过程遇到不可修复的错误</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1_3 进程控制"></a>2.1_3 进程控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.进程控制</span><br><span class="line">    进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现</span><br><span class="line">    进程转换等功能</span><br><span class="line">    简化理解：进程控制就是要实现进程状态转换</span><br><span class="line"></span><br><span class="line">2.原语</span><br><span class="line">    原语的特点是执行期间不允许中断，只能一气呵成</span><br><span class="line">    这种不可被打断的操作即原子操作</span><br><span class="line">    原语采用“关中断指令”和“开中断指令” -&gt;&gt; 特权指令，核心态下进行</span><br><span class="line">3.进程控制的相关原语</span><br><span class="line">    无论哪个原语，执行三件事</span><br><span class="line">        更新PCB信息</span><br><span class="line">        将PCB插入合适的队列</span><br><span class="line">        分配&#x2F;回收资源</span><br><span class="line">    进程的创建 创建原语</span><br><span class="line">        申请空白PCB</span><br><span class="line">        为新进程分配所需资源</span><br><span class="line">        初始化PCB</span><br><span class="line">        将pcb插入就绪队列</span><br><span class="line">    进程的终止 撤销原语</span><br><span class="line">        从PCB集合中找到终止进程的PCB</span><br><span class="line">        若进程正在运行，立即剥夺cpu,将cpu分配给其他进程</span><br><span class="line">        终止所有子进程</span><br><span class="line">        将该进程拥有的资源归还给操作系统或父进程</span><br><span class="line">        删除PCB</span><br><span class="line">    进程的阻塞 </span><br><span class="line">        阻塞原语：</span><br><span class="line">            找到要阻塞的进程对应PCB</span><br><span class="line">            保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程的运行</span><br><span class="line">            将PCB进程插入阻塞队列</span><br><span class="line">        唤醒原语：</span><br><span class="line">            在阻塞队列中找到PCB</span><br><span class="line">            将PCB从阻塞队列移除，设置进程为就绪态</span><br><span class="line">            将PCB插入就绪队列</span><br><span class="line">    进程的切换 切换原语</span><br><span class="line">        将运行环境信息存入PCB</span><br><span class="line">        PCB移入相应队列</span><br><span class="line">        选择一个进程执行，并更新其PCB</span><br><span class="line">        根据PCB恢复进程所需的运行环境</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1_4 进程通信"></a>2.1_4 进程通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">进程通信：进程之间的信息交换</span><br><span class="line">进程是分配系统资源的单位，因此各进程拥有的内存地址互相独立</span><br><span class="line"></span><br><span class="line">1.共享存储</span><br><span class="line">    两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）</span><br><span class="line"></span><br><span class="line">    （1）基于数据结构的共享</span><br><span class="line">        比如在共享空间只能存放一个长度为10的数组，这种方式速度慢，限制多，低级通信方式</span><br><span class="line">    （2）基于存储区的共享</span><br><span class="line">        在内存中画出一块共享存储区，数据的形势，存放位置都由进程控制，而不是操作系统</span><br><span class="line">        这种共享方式速度更快，是一种高级通信方式</span><br><span class="line">2.管道通信</span><br><span class="line">    管道：用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区</span><br><span class="line"></span><br><span class="line">    （1）管道只能采用半双工通信，某一时间内只能实现单向的传输，如果要实现双向同时通信，则需要设</span><br><span class="line">        置两个管道</span><br><span class="line">    （2）各进程需要互斥的访问管道</span><br><span class="line">    （3）数据已字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待写入的</span><br><span class="line">        数据被取走。当读进程把数据全部取走后，管道变空，此时读进程的read()系统调用被阻塞</span><br><span class="line">    （4）如果没写满，就不允许读。如何没读完，就不允许写</span><br><span class="line">    （5）数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能有读错数据的</span><br><span class="line">        情况</span><br><span class="line">3.消息传递</span><br><span class="line">    进程间的数据交换已格式化消息（Message）为单位，进程通过操作系统提供的“发出&#x2F;接受消息”两个原</span><br><span class="line">    语进行数据交换</span><br><span class="line"></span><br><span class="line">    （1）直接通信方式 消息直接挂在进程的消息缓存队列上</span><br><span class="line">    （2）间接通信方式（信箱通信方式）消息要先发送到中间实体（信箱）</span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-线程概念-多线程模型"><a href="#2-1-5-线程概念-多线程模型" class="headerlink" title="2.1_5 线程概念 多线程模型"></a>2.1_5 线程概念 多线程模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.什么是线程，为什么要引入线程</span><br><span class="line">    有的进程可能需要“同时”做很多事情而传统的进程只能串行的执行一系列程序，从而引入了线程，</span><br><span class="line">    来增加并发度</span><br><span class="line"></span><br><span class="line">    线程：轻量级进程</span><br><span class="line">    线程是一个基本的cpu执行单元，也是程序执行流的最小单位</span><br><span class="line"></span><br><span class="line">    引入线程带来的额变化</span><br><span class="line">        （1）进程是资源分配的基本单位，线程是调度的基本单位</span><br><span class="line">        （2）各线程之间也可以并发，提升了并发度</span><br><span class="line">        （3）如果是同一进程的线程切换，则不需要切换进程环境，并发所带来的的系统开销减少</span><br><span class="line">2.线程的属性</span><br><span class="line">    线程是处理机调度的单位</span><br><span class="line">    多CPU环境中，各个线程可占用不同的cpu</span><br><span class="line">    每个线程都有一个线程ID,线程控制块(TCB)</span><br><span class="line">    线程也有就绪，阻塞，运行三种基本状态</span><br><span class="line">    线程几乎不拥有系统资源</span><br><span class="line">    同一进程的不同线程之间共享进行的资源</span><br><span class="line">    由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预</span><br><span class="line">    同一进程中的线程切换，不会引起进程切换</span><br><span class="line">    不同进程中的线程切换，会引起进程切换</span><br><span class="line">    切换同进程内的线程，系统开销很小</span><br><span class="line">    切换进程，系统开销较大</span><br><span class="line">3.线程的实现方式</span><br><span class="line">    用户级线程</span><br><span class="line">        由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</span><br><span class="line">        “用户级线程”就是“从用户视角能看到的线程”</span><br><span class="line">    内核级线程</span><br><span class="line">        线程的管理由操作系统内核来完成，线程的调度，切换必须在核心态下完成</span><br><span class="line">        “内核级线程”就是“从操作系统内核视角看到的线程”</span><br><span class="line">    ** 操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机调度的基本单位</span><br><span class="line"></span><br><span class="line">4.多线程模型</span><br><span class="line">    在同时支持用户级线程和内核级线程的系统中，由多个用户级线程映射到多个内核级线程的问题引出了</span><br><span class="line">    “多线程模型”问题</span><br><span class="line"></span><br><span class="line">    多对一：多个用户级线程映射到一个内核级线程</span><br><span class="line">        优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，进程管理的系统开销小</span><br><span class="line">            效率高</span><br><span class="line">        缺点：一旦一个线程发送了阻塞导致其他线程也阻塞，导致并发度不高，多个线程不能在多核的</span><br><span class="line">            处理机上并行执行</span><br><span class="line">    一对一：一个用户级线程对应一个内核级线程</span><br><span class="line">        优点：当一个线程被阻塞，其他用户级线程可以继续执行，并发性能强，多个线程可以在多核</span><br><span class="line">            处理机下并行执行</span><br><span class="line">        缺点：进程的切换在内核空间进行，线程的管理成本高，开销大</span><br><span class="line">    多对多：n个用户级线程映射到M个内核级线程（n &gt;&#x3D; m）</span><br><span class="line">        克服了多对一并发度不高的缺点，又客服了一对一模型系统开销大的缺点</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-处理机调度-概念，层次"><a href="#2-2-1-处理机调度-概念，层次" class="headerlink" title="2.2_1 处理机调度 概念，层次"></a>2.2_1 处理机调度 概念，层次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.调度的基本概念</span><br><span class="line">    调度：有一堆任务需要处理，但不限同时处理，这时候就需要确定某种规则来决定处理这些任务</span><br><span class="line">        的顺序</span><br><span class="line">    在多道程序系统中，进程的数量往往是多于处理机个数的，这样不可能并行的处理各个进程</span><br><span class="line">        处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，已实现进程的并发执行   </span><br><span class="line">2.处理机调度的三个层次</span><br><span class="line">    高级调度</span><br><span class="line">        由于内存空间有限，操作系统无法将用户提交的所有作业全部加载进内存，因此需要某种规则来决定</span><br><span class="line">        将作业调入内存的顺序</span><br><span class="line"></span><br><span class="line">        高级调度（作业调度），按照一定的顺序从外存上处于后备队列的作业中选择一个或多个作业，给它</span><br><span class="line">        门分配内存等必要资源，建立相应进程的PCB，以使他们获得竞争处理机的权利</span><br><span class="line"></span><br><span class="line">        高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会创建PCB</span><br><span class="line">        作业调出时才撤销PCB。高级调度主要是指调入问题，因为只有调入的时机需要操作系统来决定，但</span><br><span class="line">        调出的时机必然是作业运行结束</span><br><span class="line">    中级调度</span><br><span class="line">        引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件或内存稍有空闲</span><br><span class="line">        ，再重新调入内存</span><br><span class="line">        这么做的目的是提高内存利用率和系统吞吐量</span><br><span class="line">        暂时调到外存的进程状态为挂起态，值得注意的是，处于挂起态的进程，PCB并不会调到外存，而是在内存记录</span><br><span class="line">        进程数据在外存存放的位置，进程状态等信息，操作系统通过PCB来保持对各个进程的监控，管理，被挂起进程</span><br><span class="line">        的PCB会被放入到挂起队列</span><br><span class="line"></span><br><span class="line">        中级调度（内存调度），就是要决定将哪个挂起态的进程重新调入内存</span><br><span class="line">        一个进程可能多次被调入，调出内存，因此中级调度发生的频率比高级调度更高</span><br><span class="line"></span><br><span class="line">    **********************************************************************************</span><br><span class="line">    补充知识：进程的挂起态和七状态模型 </span><br><span class="line">    暂时调到外存等待的进程状态为挂起状态</span><br><span class="line">    挂起状态又可以分为：就绪挂起，阻塞挂起</span><br><span class="line">        挂起和阻塞的区别 ：两种状态都是进程暂时不能获取cpu资源,挂起是把进程调度到外存，阻塞进程还在内存中</span><br><span class="line"></span><br><span class="line">    **********************************************************************************</span><br><span class="line"></span><br><span class="line">    低级调度</span><br><span class="line">        低级调度（进程调度）按照某中规则从就绪队列中选择一个进程，将处理机分配给它</span><br><span class="line">        进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须进行进程调度</span><br><span class="line">        进程调度的频率很高，一般几十毫秒一次</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-进程调度的时机切换与进程调度方式"><a href="#2-2-2-进程调度的时机切换与进程调度方式" class="headerlink" title="2.2_2 进程调度的时机切换与进程调度方式"></a>2.2_2 进程调度的时机切换与进程调度方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.进程调度（低级调度）按照一定的算法从就绪队列中选择一个进程为其分配处理机</span><br><span class="line"></span><br><span class="line">    需要进行进程调度与切换的情况</span><br><span class="line">        主动放弃处理机</span><br><span class="line">        被动放弃处理机</span><br><span class="line">    不能进行进程调度和切换的情况</span><br><span class="line">        在处理中断的过程</span><br><span class="line">        进程在操作系统内核程序临界区</span><br><span class="line">        在原子操作过程中（原语）</span><br><span class="line"></span><br><span class="line">    进程在处于临界区时不能进行处理机调度 ×</span><br><span class="line"></span><br><span class="line">    临界资源：一段时间内只允许一个进程使用的资源，各进程需要互斥的访问临界资源</span><br><span class="line">    临界区：访问临界资源的代码</span><br><span class="line">    内核程序临界区：一般是用来访问内核某种数据结构，比如进程的就绪队列（有各就绪进程的PCB组成）</span><br><span class="line"></span><br><span class="line">2.进程调度的方式</span><br><span class="line">    非剥夺调度方式，又称非抢占方式</span><br><span class="line">        只允许进程主动放弃处理机，在运行过程中即便有更紧急的任务到达，当前进程依然会使用处理机，直到该进程终止</span><br><span class="line">        或主动要求进入阻塞态</span><br><span class="line"></span><br><span class="line">        实现简单，系统开销小，但是无法处理紧急任务，适合早期的批处理系统</span><br><span class="line">    剥夺调度方式，又称抢占式</span><br><span class="line">        当一个进程在处理机上运行时，如果有一个更紧急的任务需要处理机，则立即暂停正在执行的进程，将处理机分配给</span><br><span class="line">        更紧急的那个进程</span><br><span class="line"></span><br><span class="line">        可以优先处理紧急的进程，也可以实现让各进程按时间片轮流执行的功能，适合于分时操作系统和实时操作系统</span><br><span class="line"></span><br><span class="line">3.进程的切换与过程</span><br><span class="line">    “狭义的进程调度”与“进程切换”的区别</span><br><span class="line">    狭义的进程调度是指按照一定的算法从就绪队列中选择一个要运行的进程（这个进程可以使刚刚被暂停执行的进程，也可以是</span><br><span class="line">    另一个进程，后一种情况就需要进程切换）</span><br><span class="line">    进程切换：是指让一个进程让出处理机，由另一个进程占用处理机的过程</span><br><span class="line"></span><br><span class="line">    广义的进程调度 包含了选择一个进程和进程切换两个步骤</span><br><span class="line"></span><br><span class="line">    进程切换的过程主要完成了</span><br><span class="line">        （1）对原来的运行进程的各种数据保存</span><br><span class="line">        （2）对新的进程各种数据进程恢复</span><br><span class="line">    注意：进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然会使整个系统的效率降低，使系统大部分时间花在了</span><br><span class="line">        进程切换上，而真正执行进程的时间减少</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2_3 调度算法的评价指标"></a>2.2_3 调度算法的评价指标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.cpu利用率</span><br><span class="line">    cpu忙碌实现&#x2F;总时间</span><br><span class="line"></span><br><span class="line">    利用率 &#x3D; 忙碌时间&#x2F;总时间</span><br><span class="line"></span><br><span class="line">2.系统吞吐量</span><br><span class="line">    计算机希望尽可能少的时间完成尽可能多的作业</span><br><span class="line"></span><br><span class="line">    系统吞吐量：单位时间内完成了多少道作业</span><br><span class="line"></span><br><span class="line">    系统吞吐量 &#x3D; 总共完成了多少道作业&#x2F;总时间</span><br><span class="line"></span><br><span class="line">3.周转时间</span><br><span class="line">    作业提交给系统开始，到作业完成这段时间间隔</span><br><span class="line"></span><br><span class="line">   （作业）周转时间&#x3D;作业完成时间-作业提交时间</span><br><span class="line"></span><br><span class="line">    平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数</span><br><span class="line"></span><br><span class="line">    带权周转时间&#x3D;作业周转时间&#x2F;作业实际运行的时间</span><br><span class="line"></span><br><span class="line">    平均带权周转时间 &#x3D; 带权周转时间&#x2F;作业数</span><br><span class="line"></span><br><span class="line">4.等待时间</span><br><span class="line">    进程&#x2F;作业处于等待处理机状态的时间之和，等待时间越长，用户满意度越低</span><br><span class="line"></span><br><span class="line">    对于进程来说，等待时间就是在进程建立后等待被服务的时间之和（等待I&#x2F;O完成时不计入等待时间）</span><br><span class="line">    对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列等待的时间</span><br><span class="line"></span><br><span class="line">    一个作业要被CPU服务多久，使用多久的I&#x2F;O设备一般是不变的，因此调度算法只会影响作业&#x2F;进程的等待时间，</span><br><span class="line">    “平均等待时间”评价整体性能</span><br><span class="line"></span><br><span class="line">5.响应时间</span><br><span class="line">    用户提出请求到首次产生响应的时间</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-FCFS-SJF-HRRN调度算法"><a href="#2-2-4-FCFS-SJF-HRRN调度算法" class="headerlink" title="2.2_4 FCFS,SJF,HRRN调度算法"></a>2.2_4 FCFS,SJF,HRRN调度算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Tips:各种调度算法的学习思路</span><br><span class="line">    1. 算法思想</span><br><span class="line">    2. 算法规则</span><br><span class="line">    3. 用于作业调度还是进程调度</span><br><span class="line">    4. 抢占式？非抢占式？</span><br><span class="line">    5. 优点和缺点</span><br><span class="line">    6. 是否会导致饥饿 饥饿：某个进程&#x2F;作业长期得不到服务</span><br><span class="line"></span><br><span class="line">先来先服务（FCFS,First Come First Serve）</span><br><span class="line"></span><br><span class="line">    算法思想：“公平”，类似生活中排队</span><br><span class="line">    算法规则：按照作业&#x2F;进程到达的先后顺序进行服务</span><br><span class="line">    用于进程&#x2F;作业调度：</span><br><span class="line">        用于进程调度，考虑哪个进程先到达就绪队列</span><br><span class="line">        对于作业调度，考虑哪个作业先到达后备队列</span><br><span class="line">    是否抢占：非抢占式的算法（类似排队的时候插队不行）</span><br><span class="line">    优缺点：</span><br><span class="line">        优点：公平，算法实现简单</span><br><span class="line">        缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短时间来说用户体验不好</span><br><span class="line">            即，FCFS算法对长作业有利，对短作业不利（Eg:排队上厕所） </span><br><span class="line">    是否会导致饥饿：不会</span><br><span class="line">    短作业优先（SJF,Shortest Job First）</span><br><span class="line"></span><br><span class="line">    算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间</span><br><span class="line">    算法规则：最短的作业&#x2F;进程最先得到服务（“最短”是指服务时间最短）</span><br><span class="line">    用于进程&#x2F;作业调度：</span><br><span class="line">        既可以用于作业调度，也可以用于进程调度</span><br><span class="line">        用于进程调度时称为“短进程优先（SPF,Shortest Process First）算法”</span><br><span class="line">    是否抢占：SJF和SPF是非抢占式算法，但是也有抢占式版本--最短剩余时间优先算法（SRTN,Shortest Remaining Time Next)</span><br><span class="line">    优缺点：</span><br><span class="line">        优点：得到“最短”平均等待时间，平均周转时间</span><br><span class="line">        缺点：不公平，对短作业有利，对长作业不利，可能产生饥饿现象</span><br><span class="line">    是否会导致饥饿：会，如果源源不断的有短作业&#x2F;进程到来，可能使长作业&#x2F;进程得不到服务，产生“饥饿现象”,如果一直得不到服务，</span><br><span class="line">        则成为饿死</span><br><span class="line"></span><br><span class="line">FCFS,SJF 的思考</span><br><span class="line">    FCFS选择等待时间最长的作业理解：可以理解为先来先等待（去网吧等空机子，先去的先等待）</span><br><span class="line">    考虑一种算法，既考虑到各个作业的等待时间，又兼顾到作业的运行时间</span><br><span class="line"></span><br><span class="line">高响应比优先算法（HRRN,Hign Responce Ratio Next）</span><br><span class="line"></span><br><span class="line">    算法思想：综合考虑作业&#x2F;进程的等待时间和要求服务的时间</span><br><span class="line">    算法规则：在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务</span><br><span class="line">        响应比 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间 （&gt;1）</span><br><span class="line">    用于进程&#x2F;作业调度：</span><br><span class="line">        既可以用于作业调度，也可以用于进程调度</span><br><span class="line">    是否抢占：非抢占式算法，因为只有进程&#x2F;作业主动放弃处理机时，才需要调度，才需要计算响应比</span><br><span class="line">    优缺点：</span><br><span class="line">        优点：综合考虑了等待时间和运行时间</span><br><span class="line">            等待时间相同时，要求服务时间短的优先（SJF的优点）</span><br><span class="line">            要求服务时间（运行时间）相同时，等待时间长的优先（FCFS的优先）</span><br><span class="line">            对于长作业来说，随着等待时间越来越久，响应比也会越来越大，从而避免了长作业饥饿的问题</span><br><span class="line">    是否会导致饥饿：不会</span><br><span class="line">    总结：这几种算法主要关系用户的公平性，平均周转时间，平均等待时间等评价系统整体性能的指标，但是不关心响应时间，也不区分    任务的紧急程度，因此对用户来说，交互性很糟糕，因此这三种算法一般适合于早期的批处理系统，当然，FCFS算法也进程结合    其他算法使用，选择也用的比较多。适用于交互式调度算法将在下个小结介绍</span><br></pre></td></tr></table></figure>

<p>例题：各进程到达就绪队列的时间，需要的运行时间如下表所示，依次使用FCFS,SJF,SRTN,HRRN 调度算法，计算各进程的等待时间 ，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。</p>
<ul>
<li>进程 到达时间 运行时间</li>
<li>p1    0     7</li>
<li>p2    2     4</li>
<li>p3    4     1</li>
<li>p4    5     4</li>
</ul>
<h2 id="FCFCS-amp-amp-SJF"><a href="#FCFCS-amp-amp-SJF" class="headerlink" title="FCFCS &amp;&amp; SJF"></a>FCFCS &amp;&amp; SJF</h2><p><img src="https://s1.ax1x.com/2020/06/04/t0bPaj.jpg" alt=""></p>
<h2 id="SRTN"><a href="#SRTN" class="headerlink" title="SRTN"></a>SRTN</h2><p><img src="https://s1.ax1x.com/2020/06/04/t0bmsU.jpg" alt=""></p>
<h2 id="HRRN"><a href="#HRRN" class="headerlink" title="HRRN"></a>HRRN</h2><p><img src="https://s1.ax1x.com/2020/06/04/t0b1iR.jpg" alt=""></p>
<h3 id="2-2-5-时间片轮转，优先级，多级反馈队列调度算法"><a href="#2-2-5-时间片轮转，优先级，多级反馈队列调度算法" class="headerlink" title="2.2_5 时间片轮转，优先级，多级反馈队列调度算法"></a>2.2_5 时间片轮转，优先级，多级反馈队列调度算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">Tips:各种调度算法的学习思路</span><br><span class="line"></span><br><span class="line">1. 算法思想</span><br><span class="line">2. 算法规则</span><br><span class="line">3. 这种调度算法是作业调度还是进程调度</span><br><span class="line">4. 抢占式？非抢占式</span><br><span class="line">5. 优点和缺点</span><br><span class="line">6. 是否会导致饥饿</span><br><span class="line">1.时间片轮转(RR,Round-Robin)</span><br><span class="line"></span><br><span class="line">    算法思想：公平的，轮流的为各个进程服务，让每个进程在一定的时间间隔内都可以得到相应</span><br><span class="line">    算法规则：</span><br><span class="line">        按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程</span><br><span class="line">        未在一个时间片内执行完则剥夺处理机，将进程重新放回就绪队列队尾排队</span><br><span class="line">    用于进程&#x2F;作业调度：</span><br><span class="line">        只能用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机</span><br><span class="line">        时间片）</span><br><span class="line">    是否抢占：</span><br><span class="line">        若进程未能在时间片内运行完，将被强行剥夺处理机使用权，所以时间片轮转调度算法</span><br><span class="line">        属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到</span><br><span class="line">    优缺点： </span><br><span class="line">        优点：公平，响应快，适合于分时操作系统</span><br><span class="line">        缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度</span><br><span class="line">    是否会导致饥饿：不会</span><br><span class="line">    补充：时间片太大或太小的影响</span><br><span class="line">        如何时间片太大，导致每一个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化</span><br><span class="line">        为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大</span><br><span class="line">        *增大响应时间理解：比如系统中有十个进程并发执行，如果时间片为1s，则一个进程被响应</span><br><span class="line">        可能需要等待9s</span><br><span class="line"></span><br><span class="line">        如何时间片太小，进程的调度，切换是有代价的（保存，恢复运行环境），导致进程切换过于</span><br><span class="line">        频繁，系统会话大量的时间来处理切换进程，导致用于执行进程的时间减少</span><br><span class="line">        （一般来说，设计时间片要让切换进程的开销比不超过1%）</span><br><span class="line"></span><br><span class="line">2.  优先级调度算法</span><br><span class="line">    算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的</span><br><span class="line">        紧急程度来决定处理顺序</span><br><span class="line">    算法规则：</span><br><span class="line">        每个作业&#x2F;进程都有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</span><br><span class="line">    用于进程&#x2F;作业调度：</span><br><span class="line">        既可以用于作业调度也可以用于进程调度，甚至还会用于之后学习的I&#x2F;O调度中</span><br><span class="line">    是否抢占：</span><br><span class="line">        抢占式，非抢占式都有，在计算的时候，非抢占式只需在进程主动放弃处理机时进行调度即可</span><br><span class="line">        而抢占式还需要在就绪队列发送时，检查是否会发生抢占</span><br><span class="line">    优缺点： </span><br><span class="line">        优点：使用优先级区分任务的紧急程度，适用于实时操作系统</span><br><span class="line">        缺点：如果源源不断的有高优先级的作业&#x2F;进程到来，可能会导致饥饿，甚至饿死</span><br><span class="line">    是否会导致饥饿：会（圆源源不断的有高优先级的进程到来）</span><br><span class="line"></span><br><span class="line">    补充：</span><br><span class="line">        就绪队列未必只有一个，可以按照不同的优先级组织，另外，也可以把优先级高的进程排在更靠近</span><br><span class="line">        队头的位置</span><br><span class="line">        根据优先级是否可以动态改变 可以将优先级分为 静态优先级 和 动态优先级两种</span><br><span class="line">        静态优先级：创建进程时确定，然后一直保持不变</span><br><span class="line">        动态优先级：创建进程时有一个初始值，之后会动态的调整优先级</span><br><span class="line"></span><br><span class="line">        思考：如何合理的设置进程的优先级</span><br><span class="line"></span><br><span class="line">        系统进程的优先级 高于 用户进程</span><br><span class="line">        前台进程的优先级 高于 后台进程</span><br><span class="line">        操作系统更偏好I&#x2F;O型进程（或称I&#x2F;O繁忙型进程）</span><br><span class="line">        与I&#x2F;O型进程对应的是计算型进程（或称cpu繁忙进程）</span><br><span class="line"></span><br><span class="line">        思考：如果采用动态优先级，什么时候跳转</span><br><span class="line"></span><br><span class="line">        可以从追求公平，提升资源利用率角度考虑</span><br><span class="line">        如果某进程在就绪队列等待了很长时间，可以适当提高优先级</span><br><span class="line">        如果某进程占用了处理机很长时间，可以适当降低其优先级</span><br><span class="line">        如果发现一个进程频繁的进程I&#x2F;O操作，可以适当的提高优先级</span><br><span class="line">            思考：</span><br><span class="line">        FCFS优点 公平 </span><br><span class="line">        SJF优点   平均等待时间&#x2F;周转时间等比较短</span><br><span class="line">        时间片轮转优点 每个进程得到及时的响应</span><br><span class="line">        优先级调度算法优点 灵活的调整每个进程被服务的机会</span><br><span class="line"></span><br><span class="line">        有没有一种算法结合上面所有优点？？</span><br><span class="line"></span><br><span class="line">3.多级反馈队列调度算法</span><br><span class="line">    算法思想：对其他算法的折中权衡</span><br><span class="line">    算法规则：</span><br><span class="line">        1. 设置多级就绪队列，各级就绪队列的优先级从高到低，时间片从大到小</span><br><span class="line">        2. 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束</span><br><span class="line">        则进程进入下一队列队尾，如果此时已经是在最下列的队列，则会放回改队列的队伍</span><br><span class="line">        3. 只有当K级队列为空时，才会为k+1级队头的进程分配时间片</span><br><span class="line">    用于进程&#x2F;作业调度：用于进程调度</span><br><span class="line">    是否抢占：抢占式算法，在K级队列的进程运行过程中，若更上级的队列中存入了一个新进程，则由于新</span><br><span class="line">        进程处于优先级更高的队列中，新进程会抢占处理机，原来运行的进程放回k级队列队尾</span><br><span class="line">    优缺点： </span><br><span class="line">        优点：对各个进程相对公平(FCFS优点)；每个新到达的进程都可以很快得到响应（RR的优点）；短进程</span><br><span class="line">            只需要很少的时间就能完成（SPF的优点）；不必实现估计进程运行时间（避免用户造假）；可以灵活</span><br><span class="line">            的跳转各类进程的偏好程度，比如cpu密集型进程，i&#x2F;o密集型进程（拓展：可以将因I&#x2F;O阻塞的进程</span><br><span class="line">            重新放回原队列，这样I&#x2F;O进程就可以保持较高的优先级）</span><br><span class="line">    是否会导致饥饿：会（源源不断的短进程）</span><br><span class="line"></span><br><span class="line">    比起早期的批处理系统，由于计算机造假大幅降低，因此之后出现的交互式操作系统（包括分时操作系统，</span><br><span class="line">    实时操作系统）更注重系统的响应时间，公平性，平衡性等指标。而这几种算法也恰好的满足交互式系统的</span><br><span class="line">    需求。因此这三种算法适合用于交互式系统（UNIX使用的就是多级反馈队列调度算法）</span><br><span class="line"></span><br><span class="line">    一定要做习题！！！！！！！！！！（明天）</span><br></pre></td></tr></table></figure>

<h2 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">各进程到达就绪队列的时间，需要运行的时间如下表所示</span><br><span class="line">进程  到达时间  运行时间</span><br><span class="line">p1      0       5</span><br><span class="line">p2      2       4</span><br><span class="line">p3      4       1</span><br><span class="line">p4      5       6</span><br><span class="line"></span><br><span class="line">使用时间片轮转（RR）算法,分析时间片大小是2,5时进程的运行情况</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/08/wQ1Dns.jpg" alt="wQ1Dns.jpg"> <img src="https://s1.ax1x.com/2020/09/08/wQ15u9.jpg" alt="wQ15u9.jpg"></p>
<h2 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">各进程到达就绪队列的时间，需要运行的时间，进程优先数如图所示。分别使用非抢占式的优先级调度算法，分析</span><br><span class="line">进程运行的情况（注：优先数越大，优先级越高）</span><br><span class="line"></span><br><span class="line">进程      到达时间        运行时间        优先数</span><br><span class="line">p1          0           7                1</span><br><span class="line">p2          2           4                2</span><br><span class="line">p3          4           1                3</span><br><span class="line">p4          5           4                2</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/08/wQ39Et.jpg" alt="wQ39Et.jpg"></p>
<h2 id="例题3："><a href="#例题3：" class="headerlink" title="例题3："></a>例题3：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">各进程到达就绪队列的时间，需要的运行时间如下图。使用多级反馈队列调度算法，分析进程运行的过程</span><br><span class="line"></span><br><span class="line">进程  到达时间  运行时间</span><br><span class="line">p1      0       8</span><br><span class="line">p2      1       4</span><br><span class="line">p3      5       1</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/02/bzruxsyj4gTfLDH.jpg" alt=""></p>
</div><div class="article-tags size-small is-uppercase mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><p class="text-right font1_1"><time datetime="2020-11-25T15:35:42.729Z"><strong><em> 本文最后修改于: 2020-11-25.</em></strong></time></p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://liaotao421.github.io/posts/8b5271f8/">二.进程，处理机调度与死锁（一）</a></li><li><strong>本文作者：</strong><a href="https://liaotao421.github.io">廖涛</a></li><li><strong>本文链接：</strong><a href="https://liaotao421.github.io/posts/8b5271f8/">https://liaotao421.github.io/posts/8b5271f8/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/posts/2d9963a8/" target="_blank">二、配置文件</a><br></span><span>  2.<a class="is-size-6" href="/posts/eb48756e/" target="_blank">idea插件,设置推荐</a><br></span><span>  3.<a class="is-size-6" href="/posts/56a9c9b0/" target="_blank">Vue入门（二）</a><br></span><span>  4.<a class="is-size-6" href="/posts/8f610a4b/" target="_blank">github上传自己的项目</a><br></span><span>  5.<a class="is-size-6" href="/posts/52c7f62f/" target="_blank">java web 项目中实现短信验证码登录，注册</a><br></span></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/bb449d20/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">二.进程，处理机调度与死锁（二）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/7568c2fe/"><span class="level-item">一.操作系统引论</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script src="/js/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: '1406e6edd40efb4123827ef143fcc36e',
            repo: 'liaotao421.github.io',
            owner: 'liaotao421',
            clientID: '966837d7c763617cda0d',
            clientSecret: '637d4169f4ae86b16d6c6c3e14f4173054b34187',
            admin: ["liaotao421"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://s3.ax1x.com/2020/11/25/Dal0xA.jpg" alt="孤独时代的cuber"></figure><p class="title is-size-4 is-block line-height-inherit">孤独时代的cuber</p><p class="is-size-6 is-block">cyfwlp</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://weibo.com/6706516056" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liaotao421"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/6706516056"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:121836908@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="twitter" href="https://mobile.twitter.com/CSI0KkZDeNlqtkR"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="youtube" href="https://www.youtube.com/channel/UCX2w_4m4yD_PLFP_hsipclQ?view_as=subscriber"><i class="fab fa-youtube"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" id="toc-item-2-1-1-进程的定义，组成，组织方式，特征" href="#2-1-1-进程的定义，组成，组织方式，特征"><span>2.1_1 进程的定义，组成，组织方式，特征</span></a></li><li><a class="is-flex" id="toc-item-2-1-2-进程的状态与转换" href="#2-1-2-进程的状态与转换"><span>2.1_2 进程的状态与转换</span></a></li><li><a class="is-flex" id="toc-item-2-1-3-进程控制" href="#2-1-3-进程控制"><span>2.1_3 进程控制</span></a></li><li><a class="is-flex" id="toc-item-2-1-4-进程通信" href="#2-1-4-进程通信"><span>2.1_4 进程通信</span></a></li><li><a class="is-flex" id="toc-item-2-1-5-线程概念-多线程模型" href="#2-1-5-线程概念-多线程模型"><span>2.1_5 线程概念 多线程模型</span></a></li><li><a class="is-flex" id="toc-item-2-2-1-处理机调度-概念，层次" href="#2-2-1-处理机调度-概念，层次"><span>2.2_1 处理机调度 概念，层次</span></a></li><li><a class="is-flex" id="toc-item-2-2-2-进程调度的时机切换与进程调度方式" href="#2-2-2-进程调度的时机切换与进程调度方式"><span>2.2_2 进程调度的时机切换与进程调度方式</span></a></li><li><a class="is-flex" id="toc-item-2-2-3-调度算法的评价指标" href="#2-2-3-调度算法的评价指标"><span>2.2_3 调度算法的评价指标</span></a></li><li><a class="is-flex" id="toc-item-2-2-4-FCFS-SJF-HRRN调度算法" href="#2-2-4-FCFS-SJF-HRRN调度算法"><span>2.2_4 FCFS,SJF,HRRN调度算法</span></a></li></ul><li><a class="is-flex" id="toc-item-FCFCS-amp-amp-SJF" href="#FCFCS-amp-amp-SJF"><span>FCFCS &amp;amp;&amp;amp; SJF</span></a></li><li><a class="is-flex" id="toc-item-SRTN" href="#SRTN"><span>SRTN</span></a></li><li><a class="is-flex" id="toc-item-HRRN" href="#HRRN"><span>HRRN</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-2-2-5-时间片轮转，优先级，多级反馈队列调度算法" href="#2-2-5-时间片轮转，优先级，多级反馈队列调度算法"><span>2.2_5 时间片轮转，优先级，多级反馈队列调度算法</span></a></li></ul></li><li><a class="is-flex" id="toc-item-例题1：" href="#例题1："><span>例题1：</span></a></li><li><a class="is-flex" id="toc-item-例题2：" href="#例题2："><span>例题2：</span></a></li><li><a class="is-flex" id="toc-item-例题3：" href="#例题3："><span>例题3：</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-12-01T13:40:00.000Z">2020-12-01</time></p><p class="title is-6"><a class="link-muted" href="/posts/2bedb391/">谷粒学院开发day16</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-30T14:15:00.000Z">2020-11-30</time></p><p class="title is-6"><a class="link-muted" href="/posts/b2e4e22b/">谷粒学院开发day15</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-27T07:29:00.000Z">2020-11-27</time></p><p class="title is-6"><a class="link-muted" href="/posts/e0cd336a/">电商系统源码分享</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/">资源分享</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-23T07:28:04.000Z">2020-11-23</time></p><p class="title is-6"><a class="link-muted" href="/posts/5b87471e/">谷粒学院开发day13</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-22T07:28:38.000Z">2020-11-22</time></p><p class="title is-6"><a class="link-muted" href="/posts/c5e3d2bd/">谷粒学院开发day14</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/javaweb/"><span class="level-start"><span class="level-item">javaweb</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">技术分享</span></span><span class="level-end"><span class="level-item tag">17</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">谷粒学院项目</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/springboot/"><span class="level-start"><span class="level-item">springboot</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%B4%E8%AF%B4/"><span class="level-start"><span class="level-item">说说</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">资源分享</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">TaoBlog</a><p class="size-small"><span>&copy; 2020 廖涛</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif" target="_blank">removeif</a> <br>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br><script type="text/javascript" src="/js/statistics.js"></script><span id="statistic-times">网站运行时间统计加载中...</span><br></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://liaotao421.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            MathJax.Hub.Config({
                'HTML-CSS': {
                    matchFontHeight: false
                },
                SVG: {
                    matchFontHeight: false
                },
                CommonHTML: {
                    matchFontHeight: false
                },
                tex2jax: {
                    inlineMath: [
                        ['$','$'],
                        ['\\(','\\)']
                    ]
                }
            });
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" async></script><script>document.addEventListener("DOMContentLoaded", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script src="/js/comment-issue-data.js" defer></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>