<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>二.进程，处理机调度与死锁（二） - TaoBlog</title><meta description="摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁"><meta property="og:type" content="article"><meta property="og:title" content="二.进程，处理机调度与死锁（二）"><meta property="og:url" content="https://liaotao421.github.io/posts/bb449d20/"><meta property="og:site_name" content="liaotao"><meta property="og:description" content="摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-09-02T13:37:39.000Z"><meta property="article:modified_time" content="2020-11-25T15:34:44.852Z"><meta property="article:author" content="liaotao"><meta property="article:tag" content="categories-java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://liaotao421.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liaotao421.github.io/posts/bb449d20/"},"headline":"二.进程，处理机调度与死锁（二）","image":["https://liaotao421.github.io/img/og_image.png"],"datePublished":"2020-09-02T13:37:39.000Z","dateModified":"2020-11-25T15:34:44.852Z","author":{"@type":"Person","name":"liaotao"},"description":"摘要： 进程同步，进程互斥 信号量机制，管程的概念 死锁"}</script><link rel="alternative" href="/atom.xml" title="TaoBlog" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/wico.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">TaoBlog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-02T13:37:39.000Z">2020-09-02</time><a class="commentCountImg" href="/posts/bb449d20/#comment-container"><span class="display-none-class">f0e146ffe1186c866024b1fd7bae40c5</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="f0e146ffe1186c866024b1fd7bae40c5"> 99+</span>    </a><span class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="level-item">1 小时 读完 (大约 11908 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">二.进程，处理机调度与死锁（二）</h1><div class="content"><blockquote>
<p>摘要：</p>
<p>进程同步，进程互斥</p>
<p>信号量机制，管程的概念</p>
<p>死锁</p>
</blockquote>
<a id="more"></a>

<h3 id="2-3-1-进程同步，进程互斥"><a href="#2-3-1-进程同步，进程互斥" class="headerlink" title="2.3_1 进程同步，进程互斥"></a>2.3_1 进程同步，进程互斥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.什么是进程同步</span><br><span class="line">    进程的异步，各个并发的进程，以各自独立的，不可预知的速度向前推进</span><br><span class="line"></span><br><span class="line">    同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在</span><br><span class="line">    某些位置上协调他们的工作次序而产生制约关系，进程间的直接制约关系就是源于他们之间的相互</span><br><span class="line">    合作</span><br><span class="line">2.什么是进程互斥</span><br><span class="line">    进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如</span><br><span class="line">    内存，打印机，摄像头这样的I&#x2F;O设备）</span><br><span class="line"></span><br><span class="line">    我们把一时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头，打印机）</span><br><span class="line">    都属于临界资源。此外还有许多变量，数据，内存缓冲区都属于临界资源</span><br><span class="line"></span><br><span class="line">    对临界资源的访问，必须互斥的进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界</span><br><span class="line">    资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束时，释放</span><br><span class="line">    资源后，另一个进程才能去访问临界资源</span><br><span class="line"></span><br><span class="line">    对临界资源的互斥访问，可以在逻辑上分为四个部分</span><br><span class="line"></span><br><span class="line">    进入区 负责检查是否可以进入临界区，若可进入，则应设置正在访问临界区的标志（上锁），</span><br><span class="line">            以阻止其他进程同时进入临界区</span><br><span class="line">    临界区 访问临界资源的那段代码</span><br><span class="line">    退出区 负责解除正在访问临界资源的标志（解锁）</span><br><span class="line">    剩余区 做其他处理</span><br><span class="line"></span><br><span class="line">    为了实现对临界进程的互斥访问，同时保证系统的整体性，需要遵循以下原则</span><br><span class="line"></span><br><span class="line">    1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</span><br><span class="line">    2.忙则等待。已经有程序进入临界区时，其他试图进入临界区的进程必须等待</span><br><span class="line">    3.有限等待。对请求访问的进程，应保证在有限的时间内进入临界区</span><br><span class="line">    4.让权等待。当进程不能进入处理机，应立即释放处理机，防止进程忙等待</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3_2 进程互斥的软件实现方法"></a>2.3_2 进程互斥的软件实现方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">    1.理解各个算法的思想，原理</span><br><span class="line">    2.结合上小结学习“实现互斥的四个逻辑部分”，重点理解各算法在进入区，退出区都做了什么</span><br><span class="line">    3.分析各算法存在的缺陷（结合“进程互斥的四个原则”进程分析）</span><br><span class="line"></span><br><span class="line">1.单标志法</span><br><span class="line">    算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程访问</span><br><span class="line">    临界区的权限只能由另一个进程赋予</span><br><span class="line"></span><br><span class="line">    int turn &#x3D; 0; &#x2F;&#x2F;turn 表示当前允许进入临界区的进程号</span><br><span class="line"></span><br><span class="line">    p0进程：                       p1进程</span><br><span class="line">    while(turn !&#x3D; 0);           while(turn !&#x3D; 1);</span><br><span class="line">    critical section;           critical section;</span><br><span class="line">    turn &#x3D; 1;                   turn &#x3D; 0;</span><br><span class="line">    remainder section;          remainder section;</span><br><span class="line"></span><br><span class="line">    对于临界区的访问，一定是按p0 -&gt; p1 -&gt; p0 -&gt; p1 这样轮流访问的。这种必须轮流访问带来的问题是</span><br><span class="line">    ，如果此时允许进入临界区的进程是p0,而p0一直不访问临界区，那么此时临界区空闲，但是并不允许p1</span><br><span class="line">    访问</span><br><span class="line"></span><br><span class="line">    因此但单标志法存在的主要问题是：违背“空闲让进”原则</span><br><span class="line"></span><br><span class="line">2.双标志先检查法</span><br><span class="line">    算法思想：设置一个布尔类型的数组flag[]，数组中的各个元素用来标记各个进程想进入临界区的意愿，</span><br><span class="line">        比如“flag[0] &#x3D; ture”意味着零号进程现在想要进入临界区，每个进程在进入临界区之前先检查当前</span><br><span class="line">        有没有别的进程想进入临界区，如果没有，则把自身对应的flag[i]设置为true,之后开始访问临界区</span><br><span class="line"></span><br><span class="line">    bool flag[2]; &#x2F;&#x2F;表示进入临界区意愿的数组</span><br><span class="line">    flag[0] &#x3D; false;</span><br><span class="line">    flag[1] &#x3D; false; &#x2F;&#x2F;刚开始两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：                   p1进程：</span><br><span class="line">    while(flag[1]);   1     while(flag[0]);   5</span><br><span class="line">    flag[0] &#x3D; true;   2     flag[1] &#x3D; true;   6</span><br><span class="line">    cirtical section; 3     critical section; 7</span><br><span class="line">    flag[0] &#x3D; false;  4     flag[1] &#x3D; false;  8</span><br><span class="line">    remainder section;      remainder section;</span><br><span class="line"></span><br><span class="line">    如果按照 1 5 2 6 3 7 4 8 的顺序执行，p0,p1将会同时访问临界区</span><br><span class="line">    双标志法存在的主要问题：违背“忙则等待”原则</span><br><span class="line">    原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换</span><br><span class="line"></span><br><span class="line">3.双标志后检查法</span><br><span class="line">    算法思想：双标志先检查法，前一个算法的问题是先“检查”，后“上锁”，但是这两个操作又无法一气呵成，</span><br><span class="line">        因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法来避免上述</span><br><span class="line">        问题</span><br><span class="line"></span><br><span class="line">    bool flag[2]; &#x2F;&#x2F;表示进入临界区意愿的数组</span><br><span class="line">    flag[0] &#x3D; false;</span><br><span class="line">    flag[1] &#x3D; false; &#x2F;&#x2F;刚开始两个进程都不想进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：                   p1进程：</span><br><span class="line">    flag[0] &#x3D; true;   1     flag[1] &#x3D; true;   5</span><br><span class="line">    while(flag[1]);   2     while(flag[0]);   6</span><br><span class="line">    cirtical section; 3     critical section; 7</span><br><span class="line">    flag[0] &#x3D; false;  4     flag[1] &#x3D; false;  8</span><br><span class="line">    remainder section;      remainder section;</span><br><span class="line"></span><br><span class="line">    如果按照 1 5 2 6 执行 p0和p1都无法进入临界区</span><br><span class="line"></span><br><span class="line">    双标志后检查法虽然解决了“忙则等待”的问题，但又导致了“空闲让进”，“有限等待”的原则，</span><br><span class="line">    会因各进程长期无法访问临界区资源而产生“饥饿”现象</span><br><span class="line"></span><br><span class="line">4.Peterson算法</span><br><span class="line">    算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后都无法进入临界区。</span><br><span class="line">        Gary L.Peterson 想到了一种方法，如果双方都争着进入临界区，那可以让进程尝试“孔融让梨”，</span><br><span class="line">        主动让对方先进入临界区</span><br><span class="line"></span><br><span class="line">    bool flag[2];&#x2F;&#x2F;表示进入临界区意愿的数组，初始值都是false</span><br><span class="line">    int turn &#x3D; 0;&#x2F;&#x2F;turn 表示优先让哪个进程进入临界区</span><br><span class="line"></span><br><span class="line">    p0进程：</span><br><span class="line">    flag[0] &#x3D; true;                     1</span><br><span class="line">    turn &#x3D; 1;                           2</span><br><span class="line">    while(flag[1] &amp;&amp; turn &#x3D;&#x3D; 1);        3</span><br><span class="line">    critical section;</span><br><span class="line">    flag[0] &#x3D; false;</span><br><span class="line">    remainder section;</span><br><span class="line"></span><br><span class="line">    p1进程：</span><br><span class="line">    flag[1] &#x3D; ture;                     4</span><br><span class="line">    turn &#x3D; 0;                           5</span><br><span class="line">    while(flag[0] &amp;&amp; turn &#x3D; 0);         6</span><br><span class="line">    critical section;</span><br><span class="line">    flag[1] &#x3D; false;</span><br><span class="line">    remainder section;</span><br><span class="line"></span><br><span class="line">    Peterson算法解决了进程互斥问题，遵循“空闲让进”，“忙则等待”，“有限等待”三个原则，但依然未能遵循</span><br><span class="line">    “让权等待”,想比之前三种算法，是最好的，但是依然不够好</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3_3 进程互斥的硬件实现方法"></a>2.3_3 进程互斥的硬件实现方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">    1.理解各个方法的原理</span><br><span class="line">    2.了解各个方法的优缺点</span><br><span class="line"></span><br><span class="line">1.自断屏蔽方法</span><br><span class="line">    利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被</span><br><span class="line">    中断，也就不能实现进程切换，因此避免了同时访问临界区）</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    关中断； 关中断即不允许当前进程被中断，也必然不会发生进程切换</span><br><span class="line">    临界区；</span><br><span class="line">    开中断；    直到进程访问完临界区，再执行开中断指令，才有可能别的进程上处理机并访问临界区</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    优点：简单，高效</span><br><span class="line">    缺点：不适合多处理机的操作系统；只使用与内核进程，不使用用户进程（开&#x2F;关中断指令只能运行在内核态</span><br><span class="line">    这组指令让用户随意使用会很危险）</span><br><span class="line"></span><br><span class="line">2.TestAndSet</span><br><span class="line">    简称TS指令，也有地方TestAndSetLock指令，或TSL指令</span><br><span class="line">    TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下使用c语言实现的逻辑</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;bool共享变量lock 表示当前临界区是否加锁</span><br><span class="line">    &#x2F;&#x2F;true 表示已经加锁，false 表示未加锁</span><br><span class="line"></span><br><span class="line">    bool TestAndSet(bool *lock)&#123;</span><br><span class="line">        bool old;</span><br><span class="line">        old &#x3D; *lock;  &#x2F;&#x2F;old存放lock原来的值</span><br><span class="line">        *lock &#x3D; true; &#x2F;&#x2F;加锁</span><br><span class="line">        return old; &#x2F;&#x2F;返回lock原来的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(TearAndSet(&amp;lock));&#x2F;&#x2F;上锁并检查</span><br><span class="line">    临界区代码段...</span><br><span class="line">    lock &#x3D; false &#x2F;&#x2F;解锁</span><br><span class="line">    剩余区代码段...</span><br><span class="line"></span><br><span class="line">    相比软件实现的方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</span><br><span class="line">    优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</span><br><span class="line">    缺点：不满足“让权等待” 产生忙等现象</span><br><span class="line"></span><br><span class="line">3.Swap</span><br><span class="line">    有的地方也叫Exchange指令，或简称XCHG指令。</span><br><span class="line">    swap指令是硬件实现的执行的过程不允许被中断，只能一气呵成，以下是C语言逻辑</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Swap指令的作用是交换两个变量的值</span><br><span class="line">    Swap(bool *a,bool *b)&#123;</span><br><span class="line">        bool temp;</span><br><span class="line">        temp &#x3D; *a;</span><br><span class="line">        *a &#x3D; *b;</span><br><span class="line">        *b &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; bool型 lock 表示当前临界区是否被加锁</span><br><span class="line">    bool old &#x3D; true;</span><br><span class="line">    while(old &#x3D;&#x3D; true)</span><br><span class="line">        swap(&amp;lock,&amp;old);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    lock &#x3D; false;</span><br><span class="line">    剩余区代码段...</span><br><span class="line"></span><br><span class="line">    逻辑上个和TS无太大区别</span><br><span class="line"></span><br><span class="line">    相比软件实现的方法，SWAP指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</span><br><span class="line">    优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</span><br><span class="line">    缺点：不满足“让权等待” 产生忙等现象</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3_4 信号量机制"></a>2.3_4 信号量机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题？</span><br><span class="line"></span><br><span class="line">进程互斥的四种软件实现方式（单标志法，双标志法先检查，双标志后检查，Peterson）</span><br><span class="line">进程互斥的三种硬件实现方式（中断屏蔽法，TS&#x2F;TSL指令，Swap&#x2F;XCHG指令） </span><br><span class="line"></span><br><span class="line">1.单标志检查法只能轮换的执行进程，不满足“空闲让进”</span><br><span class="line">2.双标志先检查法，进入区的“检查”，“上锁”操作无法一气呵成，从而导致了两个进程可能同时进入临界区</span><br><span class="line">    不满足：“忙则等待”</span><br><span class="line">3.双标志后检查法，进去区的“上锁”，“检查”操作无法一气呵成，导致了两个进程都无法进入临界区</span><br><span class="line">    不满足：“空闲让进”，“有限等待”</span><br><span class="line">4.peterson算法,无法实现“让权等待”</span><br><span class="line">5.所有解决方案都无法实现“让权等待”</span><br><span class="line"></span><br><span class="line">1965年,荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥，同步的方法 -- 信号量机制</span><br><span class="line"></span><br><span class="line">1.信号量机制</span><br><span class="line">    用户进程可以通过操作系统提供的一对原语来对信号量进行操作，从而方便的实现了进程互斥与同步</span><br><span class="line"></span><br><span class="line">    信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量表示系统中</span><br><span class="line">    某种资源的数量</span><br><span class="line"></span><br><span class="line">    原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由开中断&#x2F;关中断指令实现的。软件解决方</span><br><span class="line">    案的主要问题是“进入区的操作不能一气呵成”，因此如果把进入区，退出区的操作使用原语实现，使这些操作</span><br><span class="line">    一气呵成，就能解决问题</span><br><span class="line"></span><br><span class="line">    一对原语：wait(S),signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号</span><br><span class="line">    里的信号量S其实就是函数调用时传入的一个参数</span><br><span class="line"></span><br><span class="line">    wait,signal原语常简称为P,V（来自荷兰语）因此，做题的时候可能遇到P(S),V(S)</span><br><span class="line"></span><br><span class="line">2.整型信号量</span><br><span class="line">    用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</span><br><span class="line">    与普通整数型变量的区别:对信号量操作只有三种 初始化，P操作，V操作</span><br><span class="line">    --------------------------------------------------------------------</span><br><span class="line">    EG:某系统只有一台打印机</span><br><span class="line"></span><br><span class="line">    int S &#x3D; 1;&#x2F;&#x2F;初始整数型信号量S，表示当前系统中可用的打印机资源数</span><br><span class="line"></span><br><span class="line">    void wait(int S)&#123;</span><br><span class="line">        while(S&lt;&#x3D;0); &#x2F;&#x2F;如果资源数不够，就一直循环等待    存在的问题：不满足让权等待，会发生忙等</span><br><span class="line">        S &#x3D; S - 1;  &#x2F;&#x2F;如果有资源数够，则占用一个资源</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void signal(int S)&#123;</span><br><span class="line">        S &#x3D; S + 1; &#x2F;&#x2F;释放资源</span><br><span class="line">    &#125;</span><br><span class="line">    进程p0:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p1:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line">    -------------------------------------------------------------------</span><br><span class="line">    3.记录型信号量 （*超高频出题点）</span><br><span class="line">    整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构标志信号量</span><br><span class="line"></span><br><span class="line">    &#x2F;*记录型信号量的定义*&#x2F;</span><br><span class="line">    typedef struct &#123;</span><br><span class="line">        int value; &#x2F;&#x2F;剩余资源数</span><br><span class="line">        struct process *L; &#x2F;&#x2F;等待队列</span><br><span class="line">    &#125; semaphore</span><br><span class="line"></span><br><span class="line">    void wait(S)&#123;</span><br><span class="line">        S.value --;</span><br><span class="line">        if(S.value &lt; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（阻塞队列）</span><br><span class="line">            block(S.L); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void signal(S)&#123;</span><br><span class="line">        S.value ++;</span><br><span class="line">        if(S.value &lt;&#x3D; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F;释放资源后，若还有别的进程在等待使用这种资源，则使用wakeup唤醒等待队列中的一个进程，该进程</span><br><span class="line">            从阻塞态变为就绪态</span><br><span class="line">            wakeup(S.L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line">    EG:某计算机系统中有两台打印机，则可在初始化信号量S时将value设为1，就绪队列S设为空</span><br><span class="line"></span><br><span class="line">    typedef struct &#123;</span><br><span class="line">        int value; &#x2F;&#x2F;剩余资源数              &#x3D;&#x3D;2</span><br><span class="line">        struct process *L; &#x2F;&#x2F;等待队列       &#x3D;&#x3D;null</span><br><span class="line">    &#125; semaphore</span><br><span class="line"></span><br><span class="line">    进程p0:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p1:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p2:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    进程p3:</span><br><span class="line">    ...</span><br><span class="line">    wait(S)       &#x2F;&#x2F;进入区，申请资源</span><br><span class="line">    使用打印机资源 &#x2F;&#x2F;临界区，访问资源</span><br><span class="line">    signal(S)     &#x2F;&#x2F; 退出区，释放资源</span><br><span class="line">    ...</span><br><span class="line">    （纸上运行一遍....）</span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    block原语进行了自我阻塞（当前运行进程从运行态-&gt;就绪态）主动放弃处理机，满足“让权等待”</span><br><span class="line"></span><br><span class="line">    住：若考试中出现了P(S),V(S)操作，除非特殊说明，默认S为记录型信号量</span><br></pre></td></tr></table></figure>

<h2 id="2-3-5-信号量机制"><a href="#2-3-5-信号量机制" class="headerlink" title="2.3_5 信号量机制"></a>2.3_5 信号量机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1.信号量机制实现进程互斥</span><br><span class="line">    （1）分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区）</span><br><span class="line">    （2）设置互斥信号量mutex,初值为1</span><br><span class="line">    （3）在临界区之前执行P(mutex)</span><br><span class="line">    （4）在临界区之后执行V(mutex)</span><br><span class="line"></span><br><span class="line">    &#x2F;*信号量机制实现互斥*&#x2F;</span><br><span class="line">    semaphore mutex  &#x3D; 1; &#x2F;&#x2F;初始化信号量</span><br><span class="line"></span><br><span class="line">    p1()&#123;</span><br><span class="line">        ...</span><br><span class="line">        P(mutex);</span><br><span class="line">        临界区代码段...</span><br><span class="line">        V(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p2()&#123;</span><br><span class="line">        ...</span><br><span class="line">        P(mutex);</span><br><span class="line">        临界区代码段...</span><br><span class="line">        V(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">2.信号量机制实现进程同步</span><br><span class="line">    进程同步：要让并发执行的进程有序的推进</span><br><span class="line"></span><br><span class="line">    （1）分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</span><br><span class="line">    （2）设置同步信号量S，初值为0</span><br><span class="line">    （3）在“前操作”之后执行V(S)   &#x2F;&#x2F;前V后P</span><br><span class="line">    （4）在“后操作”之前执行P(S)</span><br><span class="line"></span><br><span class="line">    要求：代码p4执行一定是在p2之后</span><br><span class="line">    &#x2F;*信号量机制实现同步*&#x2F;</span><br><span class="line">    semaphore S &#x3D; 0； &#x2F;&#x2F;初始化信号量</span><br><span class="line"></span><br><span class="line">    P1()&#123;</span><br><span class="line">        代码1;</span><br><span class="line">        代码2;</span><br><span class="line">        P(S);</span><br><span class="line">        代码3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P1()&#123;</span><br><span class="line">        V(S);</span><br><span class="line">        代码4;    </span><br><span class="line">        代码5;</span><br><span class="line">        代码6;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3.信号量实现进程的前驱关系</span><br><span class="line">    每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</span><br><span class="line">    因此：</span><br><span class="line">        （1）要为每一对前驱关系各设置一个同步变量</span><br><span class="line">        （2）在“前操作”之后相对应的同步变量执行V操作</span><br><span class="line">        （3）在“后操作”之前相对应的同步变量执行P操作</span><br></pre></td></tr></table></figure>

<h3 id="2-3-6-生产者消费者问题"><a href="#2-3-6-生产者消费者问题" class="headerlink" title="2.3_6 生产者消费者问题"></a>2.3_6 生产者消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次产生一个产品放入缓存区，消费者进程每次从缓冲区拿出一个进程并使用（注：这里的产品理解为某种数据）生产者，消费者共享一个初始为空，大小为n的缓冲区 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从缓冲区取出产品，否则必须等待 缓冲区 是临界资源，各进程必须互斥的访问</p>
<h5 id="pv操作题目分析步骤："><a href="#pv操作题目分析步骤：" class="headerlink" title="pv操作题目分析步骤："></a>pv操作题目分析步骤：</h5><p>1.关系分析。找出题目中描述的各个进程，分析它们之间的同步，互斥关系 2.整理思路。根据各进程的操作流程确定P,V操作的大致顺序 3.设置信号量。设置需要的信号量，并根据题目条件确定信号量初值（互斥信号量一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex &#x3D; 1; &#x2F;&#x2F;互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore empty &#x3D; n; &#x2F;&#x2F;同步信号量，表示空闲缓冲区的数量</span><br><span class="line">semaphore full &#x3D; 0; &#x2F;&#x2F; 同步信号量，表示产品的数量（非空缓冲区的数量）</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        生产一个产品；</span><br><span class="line">        P(empty);&#x2F;&#x2F;消耗一个空闲缓冲区</span><br><span class="line">        p(mutex);</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);&#x2F;&#x2F;增加一个产品</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(full);&#x2F;&#x2F;消耗一个产品（非空缓冲区）</span><br><span class="line">        p(mutex);</span><br><span class="line">        从缓冲区拿出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);&#x2F;&#x2F;增加一个空闲缓冲区</span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：能否改变相邻的P,V操作顺序 不能，会发生死锁现象 <strong>实现互斥的P操作一定要放在实现同步的P操作之后</strong> V操作不会导致进程阻塞，因此 <strong>两个V操作的顺序可以交换</strong></p>
<h5 id="知识回顾与重要考点"><a href="#知识回顾与重要考点" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>生产者消费者问题是一个互斥，同步的综合问题，对于初学者来说最难的是发现题目中隐含的两对同步关系，有时候是消费者需要等待生产者，有时候是生产者要等待消费者，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量</p>
<h3 id="2-3-7-多生产者消费者问题"><a href="#2-3-7-多生产者消费者问题" class="headerlink" title="2.3_7 多生产者消费者问题"></a>2.3_7 多生产者消费者问题</h3><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放 橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才 可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。</p>
<h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>互斥关系：对缓冲区（盘子）的访问需要互斥的进行 同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取到苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取得橘子</li>
<li>只有<strong>盘子为空</strong>时，<strong>父亲或母亲</strong>才能放入水果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex &#x3D; 1;&#x2F;&#x2F;实现对互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple &#x3D; 0;&#x2F;&#x2F;表示盘子里有几个苹果</span><br><span class="line">semaphore orange &#x3D; 0;&#x2F;&#x2F;表示盘子里有几个橘子</span><br><span class="line">semaphore plate &#x3D; 0;&#x2F;&#x2F;表示盘子里还能放多少个水果</span><br><span class="line"></span><br><span class="line">dad() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    准备放一个苹果；</span><br><span class="line">    P(palte);</span><br><span class="line">    p(mutex);</span><br><span class="line">    把苹果放入盘子；</span><br><span class="line">    V(mutex)</span><br><span class="line">    V(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mom() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    准备放一个橘子；</span><br><span class="line">    P(plate);</span><br><span class="line">    p(mutex);</span><br><span class="line">    把橘子放入盘子；</span><br><span class="line">    Vmutex);</span><br><span class="line">    V(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sun() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    p(mutex);</span><br><span class="line">    从盘子中取出苹果；</span><br><span class="line">    Vmutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉苹果；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    p(mutex);</span><br><span class="line">    从盘0子中取出橘子；</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去掉实现互斥访问缓冲区的信号量mutex，不会发生多个进程同时访问临界区的现象 原因在于：本题中缓冲区的大小为1，在任何时刻，apple,orange,plate三个同步信号量中最多只有一个是1，因此在任何一个时刻，至少有一个进程的P操作不会被阻塞，并顺利的进入临界区</p>
<h5 id="知识回顾与重要考点-1"><a href="#知识回顾与重要考点-1" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><ol>
<li>在生产者消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现访问缓冲区的功能，当然这不是绝对的，要根据问题具体分析</li>
<li>如果在考试过程中来不及分析，可以加上互斥信号量，保证各进程一定互斥的访问临界区，再次注意，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起死锁</li>
<li>解决多生产者消费者问题的关键在于理清复杂的同步关系，在分析同步问题的时候不能从<strong>单个进程行为的角度</strong>来分析，要把<strong>“一前一后”发生的事看做两种“事件的前后关系“</strong></li>
</ol>
<h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3_8 吸烟者问题"></a>2.3_8 吸烟者问题</h3><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。每个抽烟者不停地卷烟并抽掉它，但是要卷 起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，<strong>第一个拥有烟草、</strong> <strong>第二个拥有纸、第三个拥有胶水</strong>。供应者进程无限地提供三种材料，供应者每次将两种材料放桌 子上，<strong>拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了</strong>，供 应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><p>物品组合 组合1:纸 + 胶水 组合2:烟草 + 胶水 组合3: 烟草 + 纸 互斥关系： 桌子可以抽象为容量为1的缓冲区，需要互斥访问（缓冲区容量为1可以不设置互斥信号量） 同步关系（从事件的角度分析）</p>
<ol>
<li>桌上有组合1 -&gt; 第一个吸烟者取走东西</li>
<li>桌上有组合2-&gt; 第二个吸烟者取走东西</li>
<li>桌上有组合3 -&gt; 第三个吸烟者取走东西</li>
<li>发出完成信号 -&gt; 供应者将下一个组合放到桌上</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓冲区容量为1无需设置互斥信号线</span></span><br><span class="line">semphore s1 = <span class="number">0</span>; <span class="comment">//桌子上组合1的数量</span></span><br><span class="line">semphore s2 = <span class="number">0</span>;<span class="comment">//桌子上组合2的数量</span></span><br><span class="line">semphore s3 = <span class="number">0</span>;<span class="comment">//桌子上组合3的数量</span></span><br><span class="line">sephore finish = <span class="number">0</span>;<span class="comment">//是否有人完成吸烟</span></span><br><span class="line">pruducer()&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">1</span>放到桌子上；</span><br><span class="line">            V(S1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">2</span>放到桌子上；</span><br><span class="line">            V(S2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(finish);</span><br><span class="line">            把组合<span class="number">3</span>放到桌子上；</span><br><span class="line">            V(S3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker1() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s1);</span><br><span class="line">        从桌上拿走组合<span class="number">1</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker2() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s2);</span><br><span class="line">        从桌上拿走组合<span class="number">2</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">smoker3() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(s3);</span><br><span class="line">        从桌上拿走组合<span class="number">3</span>，卷烟，吸烟；</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3_9 读者-写者问题"></a>2.3_9 读者-写者问题</h3><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不 会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致 数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者 往文件中写信息;③任一写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作 前，应让已有的读者和写者全部退出。</p>
<h5 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h5><p>两类进程：读进程，写进程 互斥关系：写进程 - 写进程 ，写进程-读进程。读进程与读进程不存在互斥问题 写进程与任何进程都互斥，设置一个信号量rw，在写进程访问共享文件前后分别执行P,V操作。 读者进程和写者进程也要互斥，因此读者进程访问共享文件前后也要对rw执行P,V操作 如果所有读者进程在访问共享文件时都执行P(rw)操作会导致各个读进程之间也无法同时访问文件 <strong>读者-写者问题的核心–怎么解决该问题</strong> <strong>P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问。而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程加锁，让最后一个访问共享文件的读进程解锁。设置一个整型变量count来记录当前有几个读进程在访问文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">seamphore rw &#x3D; 1;&#x2F;&#x2F;用于实现对文件的互斥访问，表示当前是否有进程在访问共享文件</span><br><span class="line">int count &#x3D; 0; &#x2F;&#x2F;记录当前有几个读进程在访问文件</span><br><span class="line">semaphore mutex &#x3D; 1; &#x2F;&#x2F;用于保证对于count变量的互斥访问</span><br><span class="line">semaphore w &#x3D; 1; &#x2F;&#x2F;用于实现“写优先”(解决写进程饥饿)</span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw); &#x2F;&#x2F;写之前“加锁”</span><br><span class="line">        写文件...；</span><br><span class="line">        V(rw); &#x2F;&#x2F;写之后“解锁”</span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        p(W);</span><br><span class="line">        P(mutex); &#x2F;&#x2F;各读进程互斥的访问count</span><br><span class="line">        if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            P(rw); &#x2F;&#x2F;第一个读进程负责“加锁”</span><br><span class="line">        &#125;</span><br><span class="line">        count ++; &#x2F;&#x2F;访问文件的进程数 +1</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(w);</span><br><span class="line">        读文件；</span><br><span class="line">        P(mutex);</span><br><span class="line">        count --; &#x2F;&#x2F;访问文件的进程数-1</span><br><span class="line">        if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            V(rw); &#x2F;&#x2F;最后一个读进程负责“解锁”</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="知识回顾与重要考点-2"><a href="#知识回顾与重要考点-2" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。 其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的进程数，我们可以用count的值来判断当前进入的进程是否是第一个/最后一个进程，从而做出不同的处理。 另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果要<strong>实现“一气呵成”，自然应该想到使用互斥信号量</strong> 最后，还需要体会是如何解决写饥饿问题的</p>
<h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3_10 哲学家进餐问题"></a>2.3_10 哲学家进餐问题</h3><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学 家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时， 才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲 学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<h5 id="问题分析-3"><a href="#问题分析-3" class="headerlink" title="问题分析"></a>问题分析</h5><p>1.关系分析：系统中有五个哲学家进程，五位哲学家与左右邻居对其中间筷子的访问是互斥关系 2.整理思路：这个问题中只有互斥关系，但与之前的问题不同的是，每个哲学家进程需要同时拥有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓 3.信号量设置：定义互斥信号量数组chopstick[5] = {1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0-4编号，哲学界左边的筷子编号为i，右边筷子的编号为（i + 1）% 5。 如何防止死锁的发生</p>
<ul>
<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家正好相反。用这种方式可以保证如果两个相邻两个哲学家都想吃饭，那么只会有一个可以拿起第一只筷子，另一个就会被阻塞，这就避免了占有一只再等待另一只的情况</li>
<li>仅当哲学家左右都有筷子时才允许进餐 （这种方法不能保证当两边的筷子可用时，哲学家可以进餐）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex &#x3D; 1; &#x2F;&#x2F;表示哲学家左右是否有筷子</span><br><span class="line">pi() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+1)%5]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+1)%5]);</span><br><span class="line">        思考...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="知识回顾与重要考点-3"><a href="#知识回顾与重要考点-3" class="headerlink" title="知识回顾与重要考点"></a>知识回顾与重要考点</h5><p>哲学家进餐问题的关键是解决进餐死锁 这些进程之间只存在互斥关系，但与之前不同的是每个进程需要持有两个临界资源，因此有了“死锁”的问题隐患 如果在考试中遇到了一个进程需要持有多个临界资源的情况，应该参考哲学家问题的思想，分析题目中的进程之间是否会发生循环等待，是否会发生死锁 可以参考哲学家就餐问题解决死锁的三种思路</p>
<h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3_11 管程"></a>2.3_11 管程</h3><h5 id="（1）为什么要引入管程"><a href="#（1）为什么要引入管程" class="headerlink" title="（1）为什么要引入管程"></a>（1）为什么要引入管程</h5><p>信号量机制存在到的问题：编写程序困难，易出错 能不能设计一种机制，让程序员写程序时不需要关注复杂的P,V操作，让写代码更加轻松 1973年，Brinch Hansen 首次在程序设计语言（Pascal）中引入了“管程”成分——一种高级同步机制</p>
<h5 id="（2）管程的定义和基本特征"><a href="#（2）管程的定义和基本特征" class="headerlink" title="（2）管程的定义和基本特征"></a>（2）管程的定义和基本特征</h5><p>管程是一种特殊的软件模块，有这些部分组成</p>
<ol>
<li>局域于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>；</li>
<li>对局部与管程的共享数据设置初始值的语句；</li>
<li>管程有一个名字；</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部与管程的数据只能被局部与管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
</ol>
<h5 id="拓展1：使用管程解决生产者消费者问题"><a href="#拓展1：使用管程解决生产者消费者问题" class="headerlink" title="拓展1：使用管程解决生产者消费者问题"></a>拓展1：使用管程解决生产者消费者问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">    condition full,empty; &#x2F;&#x2F;条件变量用来实现同步</span><br><span class="line">    int count &#x3D; 0; &#x2F;&#x2F;缓冲区中的产品数</span><br><span class="line">    void insert (Item item) &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; N) &#123;</span><br><span class="line">            wait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        count ++:</span><br><span class="line">        insert_item(item);</span><br><span class="line">        if (count &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            signal(empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Item remove() &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            wait(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        count --;</span><br><span class="line">        if (count &#x3D;&#x3D; N - 1) &#123;</span><br><span class="line">            signal(full);</span><br><span class="line">        &#125;</span><br><span class="line">        return remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item &#x3D; 生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        item &#x3D; PruducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入管程的目的无非就是更方便的实现进程互斥和同步</p>
<ol>
<li>需要在管程中定义共享数据</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数</li>
<li>只有<strong>通过这些“入口”才能访问共享数据</strong></li>
<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个入口</strong>，且<strong>每次只能让一个进程或者线程进入</strong>（注意：互斥是由编辑器实现的）</li>
<li>可以在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>解决同步问题，可以让一个进程或者线程在条件变量上等待；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li>
</ol>
<h5 id="拓展2-java中类似管程的机制"><a href="#拓展2-java中类似管程的机制" class="headerlink" title="拓展2 java中类似管程的机制"></a>拓展2 java中类似管程的机制</h5><p>synchronized关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class monitor &#123;</span><br><span class="line">    private Item buffer[] &#x3D; new Item[N];</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void insert(Item item) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4_1 死锁的概念"></a>2.4_1 死锁的概念</h3><h5 id="（1）什么是死锁"><a href="#（1）什么是死锁" class="headerlink" title="（1）什么是死锁"></a>（1）什么是死锁</h5><p>在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>
<h5 id="（2）死锁，饥饿，死循环的区别"><a href="#（2）死锁，饥饿，死循环的区别" class="headerlink" title="（2）死锁，饥饿，死循环的区别"></a>（2）死锁，饥饿，死循环的区别</h5><p>死锁：在并发环境下，各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。 死循环：某进程执行过程中一直跳不出某个循环的现象，有时是程序逻辑bug导致，有时是程序员设计</p>
<h5 id="（3）死锁产生的必要条件"><a href="#（3）死锁产生的必要条件" class="headerlink" title="（3）死锁产生的必要条件"></a>（3）死锁产生的必要条件</h5><ol>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li><strong>请求和保持条件</strong>：进程已经保持了一个至少一个资源，但是又提出了新的资源请求，而资源已经被其他进程占有，此时请求被阻塞，但是又对自己已有资源保持不放</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ol>
<p>如果同类资源数大于1，即时有循环等待也未必发生死锁 但如果同类资源只有一个，发生循环等待必定发生死锁</p>
<h5 id="（4）什么时候会发生死锁"><a href="#（4）什么时候会发生死锁" class="headerlink" title="（4）什么时候会发生死锁"></a>（4）什么时候会发生死锁</h5><ol>
<li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能会引起死锁，对可剥夺的资源（CPU）是不会引起死锁的</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当</li>
<li>信号量的使用不当</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p>
<h5 id="（5）死锁的处理策略"><a href="#（5）死锁的处理策略" class="headerlink" title="（5）死锁的处理策略"></a>（5）死锁的处理策略</h5><ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会检测出死锁的发生，然后采取某种措施解除死锁</li>
</ol>
<h3 id="2-4-2-死锁的处理——预防死锁"><a href="#2-4-2-死锁的处理——预防死锁" class="headerlink" title="2.4_2 死锁的处理——预防死锁"></a>2.4_2 死锁的处理——预防死锁</h3><h5 id="（1）破坏互斥条件"><a href="#（1）破坏互斥条件" class="headerlink" title="（1）破坏互斥条件"></a>（1）破坏互斥条件</h5><p>互斥条件：只有对必须互斥使用的资源争抢才会导致死锁 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术，操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备 缺点：并不是所有设备可以改为共享设备，为了系统安全，有很多地方必须保持这种互斥条件，因此很多时候不能破坏互斥条件</p>
<h5 id="（2）破坏不剥夺条件"><a href="#（2）破坏不剥夺条件" class="headerlink" title="（2）破坏不剥夺条件"></a>（2）破坏不剥夺条件</h5><p>不剥夺条件：进程所获得得资源在未使用完之前，不能由其他进程强行夺走，只能主动释放 方案1：当某个进程请求新的资源得不到满足时，它必须立即释放所保持的所有资源，待以后需要的使用重新申请。也就是说，即时某些资源尚未使用完，也要主动释放，从而破坏了不可剥夺条件 方法2:当某个进程需要的资源被其他进程占有的时候，可以由操作系统协助，将需要的资源强行剥夺。这种方式一般考虑进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用) 缺点：</p>
<ol>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能会导致前一阶段的工作实效。因此这种方法一般使用与易宝存和恢复状态的资源，如cpu</li>
<li>反复的申请和释放资源会增加系统开销，降低系统的吞吐量</li>
<li>若采用方案1，会导致饥饿</li>
</ol>
<h5 id="（3）破坏请求和保持条件"><a href="#（3）破坏请求和保持条件" class="headerlink" title="*（3）破坏请求和保持条件"></a>*（3）破坏请求和保持条件</h5><p>请求和保证条件：进程已经持有了至少一个资源，又需要一个被其他进程持有的资源，此时请求进程被阻塞但又不释放已经持有的资源 可以采用<strong>静态分配方</strong>法，即进程在运行前一次申请完它所需要的全部资源，在他的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，改进程就不会再请求别的任何资源了 改策略实现起来简单，但也有缺点 有些资源可能只需要使用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源换利用率极低</strong>。此外，<strong>可能导致某些进程饥饿</strong></p>
<h5 id="（4）破坏循环等待条件"><a href="#（4）破坏循环等待条件" class="headerlink" title="（4）破坏循环等待条件"></a>（4）破坏循环等待条件</h5><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完 原理分析：一个进程只有已经占有小编号的资源时，才有资格更申请大编号的资源，按此规则，已经持有大编号资源的进程不可能逆向的回来申请小编号的资源，从而不会产生循环等待现象 缺点：</p>
<ol>
<li>不方便添加新的设备，可能需要重新下编号</li>
<li>进程实际使用资源的顺序可能和编号递增的顺序不一致，会导致资源浪费</li>
<li>必须按照规定次序申请资源，用户编程很麻烦</li>
</ol>
<h3 id="2-4-3-死锁的处理策略——避免死锁"><a href="#2-4-3-死锁的处理策略——避免死锁" class="headerlink" title="2.4_3 死锁的处理策略——避免死锁"></a>2.4_3 死锁的处理策略——避免死锁</h3><h5 id="（1）什么是安全序列"><a href="#（1）什么是安全序列" class="headerlink" title="（1）什么是安全序列"></a>（1）什么是安全序列</h5><p>你是一位成功的银行家，手里掌握着100个亿的资金… 有三个企业想找你贷款，分别是企业B、企业A、企业T，为描述方便，简称BAT。 B表示:“大哥，我最多会跟你借70亿…” A表示:“大哥，我最多会跟你借40亿…” 干表示:“大哥，我最多会跟你借50亿..” 然而…江湖中有个不成文的规矩:<strong>如果你借给企业的钱总数达不到企业提出的最</strong> <strong>大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了….</strong> 刚开始，BAT三个企业分别从你这儿借了20、10、30亿….</p>
<h5 id="（2）安全状态，不安全状态，死锁的联系"><a href="#（2）安全状态，不安全状态，死锁的联系" class="headerlink" title="（2）安全状态，不安全状态，死锁的联系"></a>（2）安全状态，不安全状态，死锁的联系</h5><p>安全序列：系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态，当然，安全序列可以有多个 如果分配了资源后，系统找不到任何一个安全序列，系统就进入了不安全状态，就以为着之后可能所有进程都无法顺利的执行下去，当然，如果有进程提前归还了一部分资源，系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁 因此可以在系统分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源的分配请求。这也是“银行家算法”的核心思想。</p>
<h5 id="（3）银行家算法"><a href="#（3）银行家算法" class="headerlink" title="（3）银行家算法"></a>（3）银行家算法</h5><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况，后来算法被用在操作系统中，用于<strong>避免死锁</strong>。 <strong>核心思想</strong>：在进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞 思考：bat的例子中，只有一种类型的资源——钱，但是在计算机系统中有多种资源，怎么将算法拓展为多种资源的情况呢</p>
<h5 id="（4）知识回顾于重要考点"><a href="#（4）知识回顾于重要考点" class="headerlink" title="（4）知识回顾于重要考点"></a>（4）知识回顾于重要考点</h5><p>数据结构: 长度为m的一维数组 Available表示还有多少可用资源 n_m矩阵Max表示各进程对资源的最大需求数 n_m矩阵Allocation表示已经给各进程分配了多少资源 Max-Allocation = Need矩阵表示各进程最多还需要多少资源 用长度为m的一位数组 Request表示进程此次申请的各种资源数 银行家算法步骤: ①检查此次申请是否超过了之前声明的最大需求数 ②检查此时系统剩余的可用资源是否还能满足这次请求 ③试探着分配，更改各数据结构 ④用安全性算法检查此次分配是否会导致系统进入不安全状态 安全性算法步骤: 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁</p>
<h3 id="2-4-4-死锁的处理策略——死锁的检测和解除"><a href="#2-4-4-死锁的处理策略——死锁的检测和解除" class="headerlink" title="2.4_4 死锁的处理策略——死锁的检测和解除"></a>2.4_4 死锁的处理策略——死锁的检测和解除</h3><h5 id="（1）死锁的检测"><a href="#（1）死锁的检测" class="headerlink" title="（1）死锁的检测"></a>（1）死锁的检测</h5><p>为了能对系统中是否已经发生了死锁进行检测，必须：</p>
<ol>
<li>用某种数据结构来保存资源请求和分配信息</li>
<li>提供一种算法，根据上述信息来检测系统是否已进入死锁状态</li>
</ol>
<p>资源分配图 两种节点</p>
<ul>
<li>进程节点：对应一个进程</li>
<li>资源节点：对应一类资源，一类资源可能有多个</li>
</ul>
<p>两种边</p>
<ul>
<li>进程节点 -&gt; 资源节点 ：表示进程想要申请几个资源（每一条边代表一个）</li>
<li>资源节点 -&gt; 进程节点 ： 表示为进程分配了几个资源（每一条边代表一个）</li>
</ul>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会被阻塞的，可以顺利的执行下去 如果这个进程执行结束后吧资源归还给系统，就可以是某个正在等待资源的进程被激活，并且顺利的执行下去 相应的，这些被激活的进程执行完了之后又会归还一些资源，这样又可能会激活另外一些被阻塞的进程 如果按照上述过程分析，最终能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁（想到与找到一个安全序列） 如果最终不能消除所有边，那么就发生了死锁 最终连着边的进程就是处于死锁状态的进程</p>
<h5 id="（2）死锁的解除"><a href="#（2）死锁的解除" class="headerlink" title="（2）死锁的解除"></a>（2）死锁的解除</h5><p>解除死锁的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是一个防止被挂起的进程长时间得不到资源而饥饿</li>
<li><strong>撤销进程法</strong>：（终止进程法）强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但付出的代价可能会很大。因为有些进程可能已经运行了很长时间，或者已经接近结束了，一旦被终止可能功亏一篑</li>
<li><strong>进程回退法</strong>：让一个或多个死锁进程回退到足以避免死锁的地步，这就要系统记录进程的历史消息，设置还原点</li>
</ol>
</div><div class="article-tags size-small is-uppercase mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><p class="text-right font1_1"><time datetime="2020-11-25T15:34:44.852Z"><strong><em> 本文最后修改于: 2020-11-25.</em></strong></time></p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://liaotao421.github.io/posts/bb449d20/">二.进程，处理机调度与死锁（二）</a></li><li><strong>本文作者：</strong><a href="https://liaotao421.github.io">廖涛</a></li><li><strong>本文链接：</strong><a href="https://liaotao421.github.io/posts/bb449d20/">https://liaotao421.github.io/posts/bb449d20/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/posts/2d9963a8/" target="_blank">二、配置文件</a><br></span><span>  2.<a class="is-size-6" href="/posts/7ff872e6/" target="_blank">五、Docker</a><br></span><span>  3.<a class="is-size-6" href="/posts/66bf2568/" target="_blank">Vue入门（一）</a><br></span><span>  4.<a class="is-size-6" href="/posts/8f610a4b/" target="_blank">github上传自己的项目</a><br></span><span>  5.<a class="is-size-6" href="/posts/56a9c9b0/" target="_blank">Vue入门（二）</a><br></span></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/1535395b/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">三.内存</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/8b5271f8/"><span class="level-item">二.进程，处理机调度与死锁（一）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script src="/js/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'f0e146ffe1186c866024b1fd7bae40c5',
            repo: 'taoblog',
            owner: 'liaotao421',
            clientID: '966837d7c763617cda0d',
            clientSecret: '637d4169f4ae86b16d6c6c3e14f4173054b34187',
            admin: ["liaotao421"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://s3.ax1x.com/2020/11/25/Dal0xA.jpg" alt="孤独时代的cuber"></figure><p class="title is-size-4 is-block line-height-inherit">孤独时代的cuber</p><p class="is-size-6 is-block">cyfwlp</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://weibo.com/6706516056" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liaotao421"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/6706516056"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:121836908@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="twitter" href="https://mobile.twitter.com/CSI0KkZDeNlqtkR"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="youtube" href="https://www.youtube.com/channel/UCX2w_4m4yD_PLFP_hsipclQ?view_as=subscriber"><i class="fab fa-youtube"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" id="toc-item-2-3-1-进程同步，进程互斥" href="#2-3-1-进程同步，进程互斥"><span>2.3_1 进程同步，进程互斥</span></a></li><li><a class="is-flex" id="toc-item-2-3-2-进程互斥的软件实现方法" href="#2-3-2-进程互斥的软件实现方法"><span>2.3_2 进程互斥的软件实现方法</span></a></li><li><a class="is-flex" id="toc-item-2-3-3-进程互斥的硬件实现方法" href="#2-3-3-进程互斥的硬件实现方法"><span>2.3_3 进程互斥的硬件实现方法</span></a></li><li><a class="is-flex" id="toc-item-2-3-4-信号量机制" href="#2-3-4-信号量机制"><span>2.3_4 信号量机制</span></a></li></ul><li><a class="is-flex" id="toc-item-2-3-5-信号量机制" href="#2-3-5-信号量机制"><span>2.3_5 信号量机制</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-2-3-6-生产者消费者问题" href="#2-3-6-生产者消费者问题"><span>2.3_6 生产者消费者问题</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-知识回顾与重要考点" href="#知识回顾与重要考点"><span>知识回顾与重要考点</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-3-7-多生产者消费者问题" href="#2-3-7-多生产者消费者问题"><span>2.3_7 多生产者消费者问题</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-知识回顾与重要考点-1" href="#知识回顾与重要考点-1"><span>知识回顾与重要考点</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-3-8-吸烟者问题" href="#2-3-8-吸烟者问题"><span>2.3_8 吸烟者问题</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-问题分析-1" href="#问题分析-1"><span>问题分析</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-3-9-读者-写者问题" href="#2-3-9-读者-写者问题"><span>2.3_9 读者-写者问题</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-知识回顾与重要考点-2" href="#知识回顾与重要考点-2"><span>知识回顾与重要考点</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-3-10-哲学家进餐问题" href="#2-3-10-哲学家进餐问题"><span>2.3_10 哲学家进餐问题</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-知识回顾与重要考点-3" href="#知识回顾与重要考点-3"><span>知识回顾与重要考点</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-3-11-管程" href="#2-3-11-管程"><span>2.3_11 管程</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-拓展2-java中类似管程的机制" href="#拓展2-java中类似管程的机制"><span>拓展2 java中类似管程的机制</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-4-1-死锁的概念" href="#2-4-1-死锁的概念"><span>2.4_1 死锁的概念</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-（5）死锁的处理策略" href="#（5）死锁的处理策略"><span>（5）死锁的处理策略</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-4-2-死锁的处理——预防死锁" href="#2-4-2-死锁的处理——预防死锁"><span>2.4_2 死锁的处理——预防死锁</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-（4）破坏循环等待条件" href="#（4）破坏循环等待条件"><span>（4）破坏循环等待条件</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-4-3-死锁的处理策略——避免死锁" href="#2-4-3-死锁的处理策略——避免死锁"><span>2.4_3 死锁的处理策略——避免死锁</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-（4）知识回顾于重要考点" href="#（4）知识回顾于重要考点"><span>（4）知识回顾于重要考点</span></a></li></ul></li><li><a class="is-flex" id="toc-item-2-4-4-死锁的处理策略——死锁的检测和解除" href="#2-4-4-死锁的处理策略——死锁的检测和解除"><span>2.4_4 死锁的处理策略——死锁的检测和解除</span></a><ul class="menu-list"><li><a class="is-flex" id="toc-item-（2）死锁的解除" href="#（2）死锁的解除"><span>（2）死锁的解除</span></a></li></ul></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-23T07:28:04.000Z">2020-11-23</time></p><p class="title is-6"><a class="link-muted" href="/posts/5b87471e/">谷粒学院开发day13</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-22T07:28:38.000Z">2020-11-22</time></p><p class="title is-6"><a class="link-muted" href="/posts/c5e3d2bd/">谷粒学院开发day14</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-17T14:44:45.000Z">2020-11-17</time></p><p class="title is-6"><a class="link-muted" href="/posts/2c807788/">谷粒学院开发day12</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-16T11:10:12.000Z">2020-11-16</time></p><p class="title is-6"><a class="link-muted" href="/posts/b5892632/">谷粒学院开发day11</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-11-15T12:11:34.000Z">2020-11-15</time></p><p class="title is-6"><a class="link-muted" href="/posts/c28e16a4/">谷粒学院开发day10</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a> / <a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/">谷粒学院项目</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/javaweb/"><span class="level-start"><span class="level-item">javaweb</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">技术分享</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E8%B0%B7%E7%B2%92%E5%AD%A6%E9%99%A2%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">谷粒学院项目</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/springboot/"><span class="level-start"><span class="level-item">springboot</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AF%B4%E8%AF%B4/"><span class="level-start"><span class="level-item">说说</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"><span class="level-start"><span class="level-item">资源分享</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springboot/"><span class="tag">springboot</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">TaoBlog</a><p class="size-small"><span>&copy; 2020 廖涛</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif" target="_blank">removeif</a> <br>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br><script type="text/javascript" src="/js/statistics.js"></script><span id="statistic-times">网站运行时间统计加载中...</span><br></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://liaotao421.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            MathJax.Hub.Config({
                'HTML-CSS': {
                    matchFontHeight: false
                },
                SVG: {
                    matchFontHeight: false
                },
                CommonHTML: {
                    matchFontHeight: false
                },
                tex2jax: {
                    inlineMath: [
                        ['$','$'],
                        ['\\(','\\)']
                    ]
                }
            });
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" async></script><script>document.addEventListener("DOMContentLoaded", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script src="/js/comment-issue-data.js" defer></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>